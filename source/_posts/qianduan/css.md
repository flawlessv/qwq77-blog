---
title: CSS笔记
cover: "https://www.dmoe.cc/random.php"
tags:
  - CSS
---

**本文作者**[秋一](https://godv.cc/readme/)

### font-weight

| 属性值  | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| normal  | 默认值(不加粗的)，相当于**number=400**                       |
| bold    | 定义粗体(加粗的)，相当于**number=700**                       |
| bolder  | 定义特粗体                                                   |
| 100-900 | 400 等同于 normal，700 等同于 bold，注意这个数字后面不跟单位 |

### font-style

| 属性值 | 作用                               |
| ------ | ---------------------------------- |
| normal | 默认值，浏览器会显示标准的字体样式 |
| italic | 浏览器会显示**斜体**的字体样式     |

### 字体属性复合写法

**顺序：文字样式 文字粗细 文字大小 文字字体**

### text-decoration

| 属性值       | 描述                           |
| ------------ | ------------------------------ |
| none         | 默认。没有装饰线(最常用)       |
| underline    | 下划线，链接自带下划线（常用） |
| overline     | 上划线(几乎不用)               |
| line-through | 删除线 (不常用)                |

### text-indent

- text-indent 属性用于指定文本的第一行缩进，通常是将段落的首行缩进
- em 是一个相对单位，就是当前元素(font-size)**1 个文字的大小**

### 子代选择器

只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。

```
元素1 > 元素2{
    样式声明
}
```

### 并集选择器

并集选择器是各选择器通过**英文逗号**连接而成，任何形式的选择器都可以作为并集选择器的一部分

### focus 选择器

- focus`伪类选择器用于**选取获得焦点的表单元素**
- 焦点就是光标，一般情况`<input>`类表单元素才能获取，因此这个选择器也主要针对表单元素来说

```‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’css
input : focus {
    background-color:yellow;
}
```

### CSS 元素显示模式

#### 块元素

常见的块元素有`<h1>~<h6>`、`<p>、<div>、<ul>、<ol>、<li>`等，其中`<div>` 标签是最典型的块元素。

1：块级元素的特点：

①：比较霸道，自己独占一行

②：高度，宽度，外边距以及内边距都可以控制

③：宽度默认是容器（父级宽度）的 100%

④：是一个容器及盒子，里面可以放行内或块级元素

2：注意：

①：文字类的元素内不能使用块级元素

②：`<p>` 标签主要用于存放文字，因此`<p>`里面不能放块级元素，特别是不能放`<div>`

③：同理，`<h1>`~`<h6>`等都是文字类块级标签，里面也不能存放其他块级元素。

#### 行内元素

常见的行内元素有`<a>`、`<strong>`、`<b>`、`<em>`、`<i>`、`<del>`、`<s>`、`<ins>`、`<u>`、`<span>`等

其中`<span>`标签是最典型的行内元素。有的地方也将行内元素称为内联元素。

行内元素的特点：

①：相邻行内元素在一行上，一行可以显示多个

②：高，宽直接设置是无效的

③：默认宽度就是它本身内容的宽度

④：行内元素只能容纳文本或其他行内元素

注意：

链接里面不能再放链接
特殊情况链接`<a>`里面可以放块级元素，但是给`<a>`转换一下块级模式最安全

### 行内块元素

在行内元素中有几个特殊的标签 —— `<img />、<input />、<td>`，它们同时具有块元素和行内元素的特点

有些资料称它们为行内块元素

特点：

①：和相邻行内元素在一行上，但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点)

②：默认宽度就是它本身内容的宽度(行内元素特点)

③：高度，行高，外边距以及内边距都可以控制(块级元素特点)

### 元素显示模式转换

- 转换为块元素： `display:block`
- 转换为行内元素： `display:inline`
- 转换为行内块元素: `display:inline-block`

### 文字垂直居中

**让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中。**

如果是行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字偏下

### background-position

- 参数：X 坐标 Y 坐标

- 可以使用 方位名词 或者 精确单位

- | 参数值   | 说明                                                        |
  | -------- | ----------------------------------------------------------- |
  | length   | 百分数\|由浮点数字和单位标识符组成的长度值                  |
  | position | top\| center \| bottom \|left \|center \|right **方位名词** |

参数是方位名词

①：如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left

②：如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐

参数是精准单位

①：如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标

②：如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中

参数是混合单位

①：如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标

### background-attachment

background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动

| 参数   | 作用                     |
| ------ | ------------------------ |
| scroll | 背景图像是随对象内容滚动 |
| fixed  | 背景图像固定             |

### 背景复合写法

- `background` ： 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置

```css
background: transparent url(image.jpg) repeat-y fixed top;
```

### 背景色半透明

CSS3 为我们提供了背景颜色半透明的效果

`background : rgba(0,0,0,0.3)`;

最后一个参数是 alpha 透明度 ，取值范围在 0~1 之间

我们习惯把 0.3 的 0 省略掉，写为`background(0,0,0,.3)`;

注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响

### 背景总结

| 属性                  | 作用           | 值                                                |
| --------------------- | -------------- | ------------------------------------------------- |
| background-color      | 背景颜色       | 预定义的颜色值/十六进制/RGB 代码                  |
| background-image      | 背景图片       | url(图片路径)                                     |
| background-repeat     | 是否平铺       | repeat/ no-repeat /repeat-x/repeat-y              |
| background-position   | 背景位置       | length/position 分别是 x 和 y 坐标                |
| background-attachment | 背景附着       | scroll(背景滚动) /fixed(背景固定)                 |
| 背景简写              | 书写更简单     | 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置  |
| 背景色半透明          | 背景颜色半透明 | background : rgba(0,0,0,0.3);**后面必须是四个值** |

### 优先级

| 选择器                   | 权重       |
| ------------------------ | ---------- |
| 继承或者 \*              | 0，0，0，0 |
| 元素选择器（标签选择器） | 0，0，0，1 |
| 类选择器，伪类选择器     | 0，0，1，0 |
| ID 选择器                | 0，1，0，0 |
| 行内样式 style=""        | 1，0，0，0 |
| ！important 重要的       | 无穷大     |

- 等级判断是从左到右，如果某一位数值相同，则判断下一位数值
- **继承的权重是 0**
- 权重可以叠加，**但是永远不会有进位**

### border-style

1. `none`:没有边框即忽略所有边框的宽度（默认值）
2. `solid` :边框为单实线（最为常用的）
3. `dashed`: 边框为虚线
4. `dotted`: 边框为点线

### border-collapse

- border-collapse 属性控制浏览器绘制表格边框的方式，它控制相邻单元格的边框
- `border-coppapse` 表格的细线边框

```css
border-collapse: collapse;
```

- 表示相邻边框合并在一起
- collapse 单词是合并的意思

### 边框会影响盒子实际大小

边框会额外增加盒子的实际大小，因此我们有两种方案解决：

1. 测量盒子大小的时候，不量边框
2. 如果测量的时候包含了边框，则需要 width/height 减去边框宽度

### padding

padding 属性(简写属性)可以有一到四个值

| 值的个数                    | 表达意思                                                            |
| --------------------------- | ------------------------------------------------------------------- |
| padding : 5px;              | 1 个值，代表**上下左右**都有 5 像素内边距                           |
| padding :5px 10px;          | 2 个值，代表上下内边距是 5 像素，左右内边距是 10 像素               |
| padding: 5px 10px 20px;     | 3 个值，代表上内边距 5 像素，左右内边距 10 像素，下内边距 20 像素   |
| padding :5px 10px 20px 30px | 4 个值，上是 5 像素，右是 10 像素，下 20 像素，左是 30 像素，顺时针 |

当我们给盒子指定 padding 值之后，发生了 2 件事情：

1. 内容和边框有了距离，添加了内边距
2. padding 影响了盒子实际大小
   - **也就是说，如果盒子已经有了宽度和高度，此时再指定内边距，会撑大盒子**

解决方案：

如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可

**如果盒子本身没有指定 width/height 属性，则此时 padding 不会撑开盒子大小**

### margin

外边距可以让**块级盒子水平居中**，但是必须满足两个条件

1. 盒子必须制定了宽度(width)
2. 盒子**左右的外边距**都设置为 auto

行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可

### 外边距合并

使用 margin 定义块级元素的垂直外边距时，可能会出现外边距的合并。

主要有两种情况：

1. 相邻块元素垂直外边距的合并
2. 嵌套块元素垂直外边距的塌陷

① 相邻块元素垂直外边距的合并

当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。

解决方案：

**尽量只给一个盒子添加 margin 值**

② 嵌套块元素垂直外边距的塌陷

对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值

### 去掉 li 前面的小圆点

```css
li {
  list-style: none;
}
```

### 圆角边框

```css
border-top-left-radius:
border-top-right-radius:
border-bottom-right-radius:
border-bottom-left-radius:
```

### 盒子阴影

```css
box-shadow: h-shadow v-shadow blur spread color inset;
```

| 值       | 描述                                   |
| -------- | -------------------------------------- |
| h-shadow | 必需。水平阴影的位置，允许负值         |
| v-shadow | 必需。垂直阴影的位置，允许负值         |
| blur     | 可选。模糊距离。                       |
| spread   | 可选，阴影的尺寸。                     |
| color    | 可选，阴影的颜色。                     |
| inset    | 可选，将外部阴影（outset）改为内部阴影 |

模糊距离：影子的虚实
阴影尺寸：影子的大小
::: warning 注意：
默认的是外阴影（outset），但是不可以在后面写这个单词，否则导致阴影无效
盒子阴影不占用空间，不会影响其他盒子排列
:::

#### 开发中阴影常用

```css
div:hover {
  box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, 0.3);
}
```

### 文字阴影

```css
text-shadow: h-shadow v-shadow blur color;
```

| 值       | 描述                           |
| -------- | ------------------------------ |
| h-shadow | 必需。水平阴影的位置，允许负值 |
| v-shadow | 必需。垂直阴影的位置，允许负值 |
| blur     | 可选。模糊距离                 |
| color    | 可选，阴影的颜色。             |

### 传统网页布局的三种方式

CSS 提供了三种传统布局方式：

- 普通流（标准流）
- 浮动
- 定位

#### 标准流

- 所谓的标准流，就是标签按照规定好默认方式排列
- 块级元素会独占一行，从上向下顺序排列。
- 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table
- 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。
- 常用元素：span、a、i、em 等

以上都是标准流布局，我们前面学习的就是标准流，标准流是最基
本的布局方式。

这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局
自然就完成了。

注意：实际开发中，一个页面基本都包含了这三种布局方式（后面
移动端学习新的布局方式） 。

#### 浮动

- 浮动最典型的应用：**可以让多个块级元素一行内排列显示。**
- 网页布局第一准则：**多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。**
- 网页布局第二准则：**先设置盒子大小，之后设置盒子的位置**

#### 浮动的特性

::: tip 脱标
浮动元素会脱离标准流

​ 浮动的盒子**不再保留原先的位置**
:::

::: warning
如果多个盒子都设置了浮动，则它们会按照属性值**一行内显示并且顶端对齐排列**

​ 浮动的元素是相互贴靠在一起的（**不会有缝隙**），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。
:::

::: tip 浮动元素会具有行内块元素特性

- 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。
- 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定
- 如果行内元素有了浮动，则不需要转换块级\行内块元素就可以直接给高度和宽度
- 浮动的盒子中间是没有缝隙的，是紧挨着一起的
  :::

#### 浮动元素经常和标准流父级搭配使用

为了约束浮动元素位置, 我们网页布局一般采取的策略是:

**先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置**

![](https://img-blog.csdnimg.cn/1eb22d8b2c8543d19d0078f8acc2575a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

#### 浮动的注意点

- 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置
- 一个元素浮动了，理论上其余兄弟元素也要浮动
  - 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动
- 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流

#### 清除浮动

##### 清除浮动的本质

- 清除浮动的本质是**清除浮动元素造成的影响**
- 如果父盒子本身有高度，则不需要清除浮动
- 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。

语法：

```
选择器 {
    clear: 属性值;
}
```

| 属性值 | 描述                                     |
| ------ | ---------------------------------------- |
| left   | 不允许左侧有浮动元素(清除左侧浮动的影响) |
| right  | 不允许右侧有浮动元素(清除右侧浮动的影响) |
| both   | 同时清除左右两侧浮动的影响               |

我们实际工作中，几乎只用`clear:both`

清除浮动的策略是：**闭合浮动**

只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子

#### 清除浮动的方法

- 额外标签法也称为隔墙法，是 W3C 推荐的做法
- 父级添加 overflow 属性

- 父级添加 after 伪元素

- 父级添加双伪元素

① 额外标签法

- 额外标签法会在浮动元素末尾添加一个空的标签,例如：

- 例如`<div style="clear:both"></div>`，或者其他标签（如`</br>`等）

- 注意：要求这个新的空标签必须是块级元素

- 优点：通俗易懂，书写方便

- 缺点：添加许多无意义的标签，结构化较差

- 实际工作可能会遇到,但是不常用-
  ②overflow

- 可以给父级添加 overflow 属性，将其属性值设置为 hidden,auto 或 scroll
- 优点：代码简洁
- 缺点：无法显示溢出的部分

③after 伪元素法

:after 方式是额外标签法的升级版。也是给父元素添加

```css
.clearfix:after {
  content: "";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
.clearfix {
  /* IE6,7专有*/
  *zoom: 1;
}
```

- 优点：没有增加标签，结构更简单
- 缺点：需要照顾低版本浏览器
- 代表网站：百度、淘宝、网易等

④ 双伪元素

也是给父元素添加

```css
.clearfix:before,
.clearfix:after {
  content: "";
  display: table;
}
.clearfix:after {
  clear: both;
}
.clearfix {
  *zoom: 1;
}
```

- 优点：代码更简洁
- 缺点：需要照顾低版本浏览器
- 代表网站：小米、腾讯等

#### 浮动总结

> 为什么需要清除浮动？

①：父级没高度

②：子盒子浮动了

③：影响下面布局了，我们就应该清除浮动了。

| 清除浮动方式          | 优点               | 缺点                                 |
| --------------------- | ------------------ | ------------------------------------ |
| 额外标签法(隔墙法)    | 通俗易懂，书写方便 | 添加许多无意义的标签，结构化较差     |
| 父级 overflow:hidden; | 书写简单           | 溢出隐藏                             |
| 父级 after 伪元素     | 结构语义化正确     | 由于 IE6-7 不支持：after，兼容性问题 |
| 父级双伪元素          | 结构语义化正确     | 由于 IE6-7 不支持：after，兼容性问题 |

### 定位

定位 = 定位模式 +边偏移

| 值       | 语义     |
| -------- | -------- |
| static   | 静态定位 |
| relative | 相对定位 |
| absolute | 绝对定位 |
| fixed    | 固定定位 |

#### 相对定位 relative

原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待。（不脱标，继续保留原来位置）

#### 绝对定位 absolute

绝对定位不再占用原先的位置（脱标)

##### 绝对定位盒子水平居中

- 加了绝对定位的盒子不能通过`margin: 0 auto`水平居中
- 但是可以通过以下计算方法实现水平和垂直居中
  - `left:50%` ； 让盒子的左侧移动到父级元素的水平中心位置
  - `margin-left: -100px`; 让盒子向左移动自身宽度的一半

#### 子绝父相

意思：子级使用绝对定位，父级则需要相对定位

①：子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。

②：父盒子需要加定位限制子盒子在父盒子内显示

③：父盒子布局时，需要占有位置，因此父亲只能是相对定位。

总结：因为父级需要占有位置，因此是相对定位，子盒子不要占有位置，则是绝对定位

#### 固定定位 fixed

固定定位是元素固定于浏览器的可视区的位置

主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变

- 特点：
  - 以浏览器的可视窗口为参照点移动元素
  - 跟父元素没有任何关系
  - 不随滚动条滚动
  - 固定定位不再占有原先的位置(脱标)

固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。

##### 固定定位小技巧

固定定位小技巧： 固定在版心右侧位置

小算法：

1. 让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。
2. 让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置

就可以让固定定位的盒子贴着版心右侧对齐了。

#### 定位叠放次序 z-index

- 在使用定位布局时候，可能会出现盒子重叠的情况
- 此时，可以用 z-index 来控制盒子的前后次序(z 轴)
- 数值可以是正整数，负整数或者 0，默认是 auto，数值越大，盒子越靠上
- 如果属性值相同，则按照书写顺序，后来居上
- 数字后面不能加单位
- **只有定位**的盒子才有 z-index 属性

#### 定位特殊特性

绝对定位和固定定位也和浮动类似。

①：行内元素添加绝对或者固定定位，可以直接设置高度和宽度

②：块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。

#### 脱标的盒子不会触发外边距塌陷

浮动元素、绝对定位(固定定位)元素都不会触发外边距合并的问题。

#### 绝对定位(固定定位)会完全压住盒子

①：浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）

②：但是绝对定位（固定定位） 会压住下面标准流所有的内容。

③：浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素

### 元素的隐藏与显示

#### display 显示隐藏

`display`属性用于设置一个元素应如何显示

```css
display: none;  /*隐藏对象*/

display: block; /*除了转换为块级元素之外，同时还有显示元素的意思*/
123
```

- **display 隐藏元素后，不再占有原来的位置**

#### visibility 显示隐藏

`visibility`属性用于指定一个元素应可见还是隐藏,**继续占有原来的位置**

```css
visibility: visible; /*元素可视*/

visibility: hidden; /*元素隐藏*/
```

#### overflow 溢出显示隐藏

overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。

| 属性值  | 描述                                       |
| ------- | ------------------------------------------ |
| visible | 不剪切内容也不添加滚动条                   |
| hidden  | 不显示超过对象尺寸的内容，超出的部分隐藏掉 |
| scroll  | 不管超出内容否，总是显示滚动条             |
| auto    | 超出自动显示滚动条，不超出不显示滚动条     |

一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。
但是如果有定位的盒子， 请慎用 overflow:hidden 因为它会隐藏多余的部分。

### 新增选择器

#### 属性选择器

- 属性选择器可以根据元素特定的属性来选择元素，**这样就可以不用借助于类或者 id 选择器**

| 选择符        | 简介                                        |
| ------------- | ------------------------------------------- |
| E[att]        | 选择具有 att 属性的 E 元素                  |
| E[att=“val”]  | 选择具有 att 属性且属性值等于 val 的 E 元素 |
| E[att^=“val”] | 匹配具有 att 属性且值以 val 开头的 E 元素   |
| E[att$=“val”] | 匹配具有 att 属性且值以 val 结尾的 E 元素   |
| E[att*=“val”] | 匹配具有 att 属性且值中含有 val 的 E 元素   |

### 结构伪类选择器

- 结构伪类选择器主要根据**文档结构**来选择元素
- 常用于根据父级选择器选择里面的子元素、
- 类选择器，属性选择器，伪类选择器，权重为 10

| 选择符             | 简介                          |
| ------------------ | ----------------------------- |
| E:first-child      | 匹配父元素中的第一个子元素 E  |
| E:last-child       | 匹配父元素中最后一个 E 元素   |
| E:nth-child(n)     | 匹配父元素中的第 n 个子元素 E |
| E:first-of-type    | 指定类型 E 的第一个           |
| E:last-of-type     | 指定类型 E 的最后一个         |
| E:nth-of-type（n） | 指定类型 E 的第 n 个          |

#### `nth-child(n)`和`nth-of-type(n)`区别

1. **nth-child 对父元素里面所有孩子排序选择(序号是固定的)，先找到第 n 个孩子，然后看看是否和 E 匹配**
2. **nth-of-type 对父元素里面指定子元素进行排序选择，先去匹配 E,然后再根据 E 找第 n 个孩子**

### 伪元素选择器

- 伪元素选择器可以帮我们利用 CSS**创建新标签元素**，而不需要 HTML 标签，从而简化 HTML 结构

| 选择符   | 简介                     |
| -------- | ------------------------ |
| ::before | 在元素内部的前面插入内容 |
| ::after  | 在元素内部的后面插入内容 |

**注意：**

1. before 和 after 创建一个元素，但是是属于**行内元素**
   - before 和 after 都是一个盒子，都作为父元素的孩子
2. 新创建的这个元素在文档树中是找不到的，所以我们称为**伪元素**
3. before 和 after 必须有 **content** 属性
4. before 在父元素内容的前面创建元素 ，after 在父元素内容的后面插入元素
5. **伪元素选择器** 和 **标签选择器** 一样，权重为 1

### CSS3 盒子模型

```css
box-sizing: border-box;
```

### C3 其他特性

#### 滤镜 filter

- `filter`: CSS 属性将模糊或颜色偏移等图形效果应用于元素(图片变模糊)

- 语法：

  ```css
  filter: 函数(); //注意数值要加px单位
  ```

- 模糊处理：`blur`,数值越大越模糊

#### calc 函数

`alc()` 此 CSS 函数让你在声明 CSS 属性值时执行一些计算（计算盒子宽度 width: calc 函数）

```css
width: calc(100% - 80px);
```

括号里面可以使用 + - \* / 来进行计算 **运算符两边要用空格隔开**

#### transition 过渡

过渡动画：是从一个状态渐渐的过渡到另外一个状态

**过渡经常和：hover 一起搭配使用**

```css
transition: 要过渡的属性 花费时间 运动曲线 何时开始;
```

要过渡的属性：想要变化的 CSS 属性，宽度高度，背景颜色，内外边距都可以，如果想要所有的属性都变化过渡，写一个 all 就可以。
花费时间：单位是秒(必须写单位) 比如 0.5s
运动曲线：默认是 ease(可以省略)
何时开始：单位是秒(必须写单位)，可以设置延迟触发事件，默认是 0s(可以省略)
过渡的口诀：**谁做过渡给谁加**

```html
/* 如果想要写多个属性，利用逗号进行分割 */ transition: width 0.5s, height 0.5s;
```

#### 2D 转换

![二维坐标系](https://img-blog.csdnimg.cn/b00b7fe0cb594342ad86ea06bf2b0123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

##### ① 移动 translate

1. 定义 2D 转换中的移动，沿着 X 和 Y 轴移动元素
2. translate 最大的优点：**不会影响到其他元素的位置**
3. translate 中的百分比单位是相对于自身元素的
   - `translate:(50%,50%);`
4. 对行内标签没有效果

##### ② 旋转 rotate

1. rotate 里面跟度数，单位是 deg 比如 rotate(45deg)
2. **角度为正时，顺时针，负时，为逆时针**
3. 默认旋转的中心点是元素的中心点

###### ③ 旋转中心点 transform-origin

2D 转换中心点：我们可以设置元素转换的中心点 transform-origin

transform-origin: x y;

::: warning
注意后面的参数 x 和 y 用空格隔开
x y 默认转换的中心点是元素的中心点(50% 50%)
还可以给 x y 设置 像素或者方位名词(top bottom left right center)
:::

##### 缩放 scale

注意其中的 x 和 y 用逗号分割
transform:scale(1,1): 宽和高都放大一倍，相当于没有放大
transform:scale(2,2)：宽和高都放大了 2 倍
transform:scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2)
transform:scale(0.5,0.5)：缩小
sacle 缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子

#### 2D 转换综合写法

1. 同时使用多个转换，其格式为: transform:translate() rotate() scale() 移动-旋转-缩放
2. 其顺序会影响转换的效果(先旋转会改变坐标轴方向)
3. **当我们同时有位移和其他属性时候，记得要将位移放到最前面**

### C3 动画

制作动画分为两步：

- 先定义动画
- 再使用（调用）动画

#### 用 keyframs 定义动画

用 keyframes 定义动画（类似定义类选择器）

```css
@keyframes 动画名称 {
  0% {
    width: 100px;
  }
  100% {
    width: 200px;
  }
}
```

- 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。
- 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果
- 动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的次数。
- 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。-

#### 动画常用属性

| **属性**                  | **描述**                                                        |
| ------------------------- | --------------------------------------------------------------- |
| @keyframes                | 规定动画。                                                      |
| animation                 | 所有动画属性的简写属性，除了 animation-play-state 属性。        |
| animation-name            | 规定@keyframes 动画的名称。（**必须的**）                       |
| animation-duration        | 规定动画完成一个周期所花费的秒或毫秒，默认是 0。（**必须的**）  |
| animation-timing-function | 规定动画的速度曲线，默认是“ease”。                              |
| animation-delay           | 规定动画何时开始，默认是 0。                                    |
| animation-iteration-count | 规定动画被播放的次数，默认是 1，还有 infinite                   |
| animation-direction       | 规定动画是否在下一周期逆向播放，默认是“normal“,alternate 逆播放 |
| animation-play-state      | 规定动画是否正在运行或暂停。默认是"running",还有"paused"。      |
| animation-fill-mode       | 规定动画结束后状态，保持 forwards 回到起始 backwards            |

#### 动画的简写属性

```css
/* animation：动画名称 持续时间 运动曲线  何时开始  播放次数  是否反方向  动画起始或者结束的状态 */

animation: myfirst 5s linear 2s infinite alternate;
```

写属性里面不包含 animation-play-state
暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用
l 想要动画走回来 ，而不是直接跳回来：animation-direction: alternate
盒子动画结束后，停在结束位置： animation-fill-mode : forwards

#### 速度曲线细节

`animation-timing-function`：规定动画的速度曲线，默认是“ease”

| **值**      | **描述**                                       |
| ----------- | ---------------------------------------------- |
| linear      | 动画从头到尾的速度是相同的。匀速               |
| ease        | 默认。动画以低速开始，然后加快，在结束前变慢。 |
| ease-in     | 动画以低速开始。                               |
| ease-out    | 动画以低速结束。                               |
| ease-in-out | 动画以低速开始和结束。                         |
| steps()     | 指定了时间函数中的间隔数量（步长）             |

### 3D 转换

#### 三维坐标系

![](https://img-blog.csdnimg.cn/8b3f76c171604b64975e75c1e3d7367b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

3D 转换我们主要学习工作中最常用的 3D 位移 和 3D 旋转

#### 3D 位移 translate3d

3D 移动在 2D 移动的基础上多加了一个可以移动的方向，就是 z 轴方向

- translform:translateX(100px)：仅仅是在 x 轴上移动
- translform:translateY(100px)：仅仅是在 Y 轴上移动
- translform:translateZ(100px)：仅仅是在 Z 轴上移动（注意：translateZ 一般用 px 单位）
- transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离

因为 z 轴是垂直屏幕，由里指向外面，所以默认是看不到元素在 z 轴的方向上移动

#### 透视 perspective

透视：在 2D 平面产生近大远小视觉立体，但是只是效果二维的

- 如果想要在网页产生 3D 效果需要透视（理解成 3D 物体投影在 2D 平面内）
- 模拟人类的视觉位置，可认为安排一只眼睛去看
- 透视我们也称为视距：视距就是人的眼睛到屏幕的距离
- 距离视觉点越近的在电脑平面成像越大，越远成像越小
- 透视的单位是像素

**透视写在被观察元素的父盒子上面的**

#### 3D 旋转 rotate3d

3D 旋转：3D 旋转指可以让元素在三维平面内沿着 x 轴，y 轴，z 轴或者自定义轴进行旋转。

- transform: rotateX(45deg) ：沿着 X 轴正方向旋转 45 度
- transform: rotateY(45deg) ：沿着 Y 轴正方向旋转 45 度
- transform: rotateZ(45deg) ：沿着 Z 轴正方向旋转 45 度
- transform: rotate3d(x,y,z,deg) ：沿着自定义轴旋转 deg 为角度(了解即可)

xyz 是表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度。

#### 左手准则

- 左手的手拇指指向 x 轴的正方向
- 其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向

#### 3D 呈现 transform-style

3D 呈现：transform-style

1. 控制子元素是否开启三维立体环境
2. `transform-style: flat` 子元素不开启 3d 立体空间 默认的
3. `transform-style: preserve-3d` 子元素开启立体空间
4. **代码写给父级**，但是影响的是子盒子
5. 这个属性很重要

### 精灵图 Sprites

- 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术
- 核心原理：**将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了**

### 鼠标样式 cursor

| 属性值      | 描述       |
| ----------- | ---------- |
| default     | 小白，默认 |
| pointer     | 小手       |
| move        | 移动       |
| text        | 文本       |
| not-allowed | 禁止       |

### 轮廓线 outline

- 给表单添加 `outline:0`; 或者`outline: none`;样式后，就可以去掉默认的蓝色边框

```css
input {
  outline: none;
}
```

### 防止拖拽文本域

防止拖拽文本域`resize`

```css
textarea {
  resize: none;
}
```

### vertical-align

- 使用场景：经常用于设置**图片**或者**表单（行内块元素）\*\*和\*\*文字垂直对齐**。

- 官方解释：用于设置一个元素的垂直对齐方式，但是它只针对于**行内元素**或者**行内块元素**有效

- ```css
  vertical-align: baseline | top | middle | bottom;
  ```

| 值       | 描述                                               |
| -------- | -------------------------------------------------- |
| baseline | 默认，元素放置在父元素的基线上                     |
| top      | 把元素的顶端与行中最高元素的顶端对齐（顶线对齐）   |
| middle   | 把此元素放置在父元素的中部（中线对齐）             |
| bottom   | 把元素的顶端与行中最低的元素的顶端对齐（底线对齐） |

![](https://img-blog.csdnimg.cn/2f7832a64527405181bd3edbcd3a736a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1Z2Vuc3Rlcm5fUVhM,size_16,color_FFFFFF,t_70#pic_center)

图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。

此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 `middle` 就可以让文字和图片垂直居中对齐了。

#### 图片底侧空白缝隙解决

bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐（给图片加边框就可以看见）

主要解决办法有两种：

1. 给图片添加 `vertical-align : middle | top |bottom` 等
2. 把图片转换为块级元素 `display:block;`，因为块级元素不会有`vertical-align` 属性

### 溢出文字省略显示

#### 单行文本溢出省略号显示

必须满足三个条件：

```css
/* 1.先强制一行内显示文本 */
white-space: nowrap; /*默认 normal 是自动换行，nowrap是强制一行显示文本*/

/* 2.超出的部分隐藏 */
overflow: hidden;

/* 3.文字用省略号替代超出的部分*/
text-overflow: ellipsis;
/*ellipsis:省略号*/
```

#### 多行文本溢出显示省略号显示

多行文本溢出显示省略号，有较大的兼容性问题，适合于 webKit 浏览器或移动端(移动端大部分是 webKit 内核)

```css
overflow: hidden;
text-overflow: ellipsis;
/* 弹性伸缩盒子模型显示 */
display: -webkit-box;
/* 限制在一个块元素显示的文本的行数 */
-webkit-line-clamp: 2;
/* 设置或检索伸缩盒对象的子元素的排列方式 */
-webkit-box-orient: vertical;
```

### 常见布局技巧

#### margin 负值的运用

- 两个盒子加边框 1px，浮动，贴紧会出现 1 + 1 = 2px
- 给右边盒子添加`margin-left: -1px`
- 正数向右边走，负数向左边走

当我们有多个盒子时的解决办法：

1. 让每个盒子 margin 往左侧移动 -1px 正好压住相邻盒子边框
2. 鼠标经过某个盒子的时候，提高当前盒子的层级即可
   - 如果没有定位，则加相对定位(保留位置)
   - 如果有定位，则加 z-index

#### 文字围绕浮动元素

巧妙运用浮动元素不会压住文字的特性

#### 行内块巧妙运用

页码在页面中间显示：

1. 把这些链接盒子转换为行内块，之后给父级指定 `text-align: center`
2. 利用行内块元素中间有缝隙，并且给父级添加 `text-align: center` ，行内块元素会水平居中

### 视口 viewport

- 视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为**布局视口、视觉视口和理想视口**
- 我们只需要关注理想视口

#### 布局视口 layout viewport

一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的 PC 端页面在手机上显示的问题。

iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页

![](https://img-blog.csdnimg.cn/a6b00357d121434a8915238dc232ea0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

#### 视觉视口 visual viewport

- 字面意思，它是用户正在看到的网站的区域。**注意：是网站的区域。**
- 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。

![](https://img-blog.csdnimg.cn/f12230ebf9d3415fbda4e33a1188554f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center)

#### 理想视口 ideal viewport

- 为了使网站在移动端有最理想的浏览和阅读宽度而设定
- 理想视口，对设备来讲，是最理想的视口尺寸
- 需要手动添写 meta 视口标签通知浏览器操作
- meta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽(乔布斯提出的哟)

#### 总结

- 视口就是浏览器显示页面内容的屏幕区域
- 视口分为布局视口、视觉视口和理想视口
- 我们移动端布局想要的是理想视口就是手机屏幕有多宽，我们的布局视口就有多宽
- 想要理想视口，我们需要给我们的移动端页面添加 meta 视口标签

#### meta 视口标签

<meta name="viewport" content="width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

| 属性          | 解释说明                                                                 |
| ------------- | ------------------------------------------------------------------------ |
| width         | 宽度设置的是 viewport 宽度，可以设置 device-width 特殊值(宽度是设备宽度) |
| initial-scale | 初始缩放比，大于 0 的数字                                                |
| maximum-scale | 最大缩放比，大于 0 的数字                                                |
| minimum-scale | 最小缩放比，大于 0 的数字                                                |
| user-scalable | 用户是否可以缩放，yes 或 no（1 或 0）                                    |

#### 标准的 viewport 设置

- 视口宽度和设备保持一致
- 视口的默认缩放比例 1.0
- 不允许用户自行缩放
- 最大允许的缩放比例 1.0
- 最小允许的缩放比例 1.0

### 二倍图

#### 物理像素和物理像素比

- 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果 6\7\8 是 750\* 1334

- 我们开发时候的 1px 不是一定等于 1 个物理像素的

- PC 端页面，1 个 px 等于 1 个物理像素的，但是移动端就不尽相同

- 一个 px 的能显示的物理像素点的个数，称为物理像素比或屏幕像素比

- PC 端 和 早前的手机屏幕 / 普通手机屏幕: 1CSS 像素 = 1 物理像素的

Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。由于 Retina 的出现，对于一张 50px \* 50px 的图片,在手机 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊。

例如：我们需要一个 50*50 像素(css 像素)的图片，直接放到我们的手机里面会放大 2 倍变成 100 * 100，这样就会模糊。

解决办法：我们直接放一个 100 _ 100 图片，然后手动的把这个图片缩小为 50 _ 50。这样将图放到手机里面，手机自动放大 2 倍变成 100 \* 100，这样就不会造成图片模糊

我们准备的图片，比我们实际需要的大小大 2 倍，这种方式就是二倍图

#### 背景缩放 background-size

我们的图片需要进行放大处理，那么我们的背景图片也是需要进行缩放处理。

background-size: 背景图片宽度 背景图片高度;

- 单位： 长度|百分比|cover|contain
- cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。
- contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域

### 移动端开发选择

1. 单独制作移动端页面(主流)，通常情况下，网址域名前面加 m(mobile) 可以打开移动端。
   - m.taobao.com
   - m.jd.com
   - m.suning.com
   - 通过判断设备，如果是移动设备打开，则跳到移动端页面。
2. 响应式页面兼容移动端(其次)

### 移动端浏览器

- 移动端浏览器基本以 webkit 内核为主，因此我们就考虑 webkit 兼容性问题。
- 我们可以放心使用 H5 标签和 CSS3 样式。
- 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可

### CSS 初始化 normalize.css

移动端 CSS 初始化推荐使用 normalize.css

官网地址：http://necolas.github.io/normalize.css/

### 特殊样式

```css
/*CSS3盒子模型*/
box-sizing: border-box;
-webkit-box-sizing: border-box;

/*点击高亮我们需要清除 设置为transparent 完成透明*/
-webkit-tap-highlight-color: transparent;

/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
-webkit-appearance: none;

/*禁用长按页面时的弹出菜单*/
img,
a {
  -webkit-touch-callout: none;
}
```

### 移动端常见布局

![](https://img-blog.csdnimg.cn/31944f6dcdbe424b95efb6209f9fc7d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

### 流式布局(百分比布局)

- 流式布局，就是百分比布局，也称非固定像素布局。
- 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。

### flex 布局

| 传统布局                       | flex 弹性布局                            |
| ------------------------------ | ---------------------------------------- |
| 兼容性好                       | 操作方便，布局极为简单，移动端应用很广泛 |
| 布局繁琐                       | PC 端浏览器支持情况较差                  |
| 局限性，不能再移动端很好的布局 | IE 11 或更低版本，不支持或仅部分支持     |

#### flex 布局原理

flex 是 flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。

- 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。
- 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 =flex 布局

采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。
总结 flex 布局原理：**就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式。**

#### flex 布局常见父项属性

以下有 6 个属性是对父元素设置的

```css
flex-direction：设置主轴的方向
justify-content：设置主轴上的子元素排列方式
flex-wrap：设置子元素是否换行
align-content：设置侧轴上的子元素的排列方式（多行）
align-items：设置侧轴上的子元素排列方式（单行）
flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap
```

#### flex-direction 设置主轴方向

主轴和侧轴：在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x 轴和 y 轴

- 默认主轴方向就是 x 轴方向，水平向右

- 默认侧轴方向就是 y 轴方向，水平向下

- lex-direction 属性决定主轴的方向（即项目的排列方向）

  注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的

| 属性值         | 说明               |
| -------------- | ------------------ |
| **row**        | **默认值从左到右** |
| row-reverse    | 从右到左           |
| **column**     | **从上到下**       |
| column-reverse | 从下到上           |

#### justify-content 设置主轴上的子元素排列方式

- justify-content 属性定义了项目在主轴上的对齐方式
- **注意： 使用这个属性之前一定要确定好主轴是哪个**

| 属性值            | 说明                                              |
| ----------------- | ------------------------------------------------- |
| **flex-start**    | **默认值从头部开始，如果主轴是 x 轴，则从左到右** |
| flex-end          | 从尾部开始排列                                    |
| **center**        | **在主轴居中对齐(如果主轴是 x 轴则水平居中)**     |
| **space-around**  | **平分剩余空间**                                  |
| **space-between** | **先两边贴边，再平分剩余空间 🔥**                 |

#### flex-wrap 设置子元素是否换行

默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，flex 布局中默认是不换行的。

意思就是如果按照我们设置的盒子大小，一行只能装 3 个盒子，但是我们有 5 个盒子，那么 flex 布局默认会给我们塞上去，自动缩小盒子大小。

| 属性值   | 说明           |
| -------- | -------------- |
| nowrap   | 默认值，不换行 |
| **wrap** | **换行**       |

#### align-items 设置侧轴上的子元素排列方式(单行)

该属性是控制子项在侧轴（默认是 y 轴）上的排列方式 在子项为单项（**单行**）的时候使用

| 属性值         | 说明                       |
| -------------- | -------------------------- |
| **flex-start** | **从上到下**               |
| flex-end       | 从下到上                   |
| **center**     | **挤在一起居中(垂直居中)** |
| **stretch**    | **拉伸(默认值)**           |

#### align-content 设置侧轴上的子元素的排列方式(多行)

设置子项在侧轴上的排列方式 并且只能用于子项出现 **换行** 的情况（多行），在单行下是没有效果的。

| 属性值            | 说明                                       |
| ----------------- | ------------------------------------------ |
| **flex-start**    | **默认值在侧轴的头部开始排列**             |
| flex-end          | 在侧轴的尾部开始排列                       |
| **center**        | **在侧轴中间显示**                         |
| **space-around**  | **子项在侧轴平分剩余空间**                 |
| **space-between** | **子项在侧轴先分布在两头，再平分剩余空间** |
| **stretch**       | **设置子项元素高度平分父元素高度**         |

#### flex-flow

lex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性

```css
flex-flow: row wrap;
```

#### flex 布局子项常见属性

- flex 子项目占的份数
- align-self 控制子项自己在侧轴的排列方式
- order 属性定义子项的排列顺序（前后顺序）

#### flex-shrink

`flex-shrink` 接受数值作为属性值。 数值越大，则该元素与其他元素相比会被压缩得更厉害；相应地，`flex-grow` 会在容器太大时对子元素作出调整。

#### flex-basis

`flex-basis` 属性定义了在使用 CSS 的 `flex-shrink` 或 `flex-grow` 属性对元素进行调整前，元素的初始大小。

### opacity

CSS 里的 `opacity` 属性用来设置元素的透明度。

透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色。

### 背景颜色渐变

```
linear-gradient
```

### rem 适配布局

#### rem 基础

rem (root em)是一个相对单位，类似于 em，em 是父元素字体大小。
不同的是 rem 的基准是相对于 html 元素的字体大小。

- 比如，根元素（html）设置 font-size=12px; 非根元素设置 width:2rem; 则换成 px 表示就是 24px
- rem 的优势：父元素文字大小可能不一致， 但是整个页面只有一个 html，可以很好来控制整个页面的元素大小

### 媒体查询

媒体查询（Media Query）是 CSS3 新语法。

- 使用 @media 查询，可以针对不同的媒体类型定义不同的样式
- @media 可以针对不同的屏幕尺寸设置不同的样式
- 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面
- 目前针对很多苹果手机、Android 手机，平板等设备都用得到多媒体查询

语法如下：

```css
@media mediatype and|not|only(media feature){
    CSS-code
}
```

- 用 @media 开头 注意@符号
- mediatype 媒体类型
- 关键字 and not only
- media feature 媒体特性 必须有小括号包含

#### mediatype 查询类型

将不同的终端设备划分成不同的类型，称为媒体类型

| 值        | 解释说明                               |
| --------- | -------------------------------------- |
| all       | 用于所有设备                           |
| print     | 用于打印机和打印预览                   |
| **scree** | **用于电脑屏幕、平板电脑、智能手机等** |

#### 关键字

关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。

- and：可以将多个媒体特性连接到一起，相当于“且”的意思。
- not：排除某个媒体类型，相当于“非”的意思，可以省略。
- only：指定某个特定的媒体类型，可以省略。

#### 媒体特性

每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。**注意他们要加小括号包含**。

| 值        | 解释                               |
| --------- | ---------------------------------- |
| width     | 定义输出设备中页面可见区域的宽度   |
| min-width | 定义输出设备中页面最小可见区域宽度 |
| max-width | 定义输出设备中页面最大可见区域宽度 |

注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁

### 媒体查询+rem 实现元素动态大小变化

- rem 单位是跟着 html 来走的，有了 rem 页面元素可以设置不同大小尺寸
- 媒体查询可以根据不同设备宽度来修改样式
- 媒体查询+rem 就可以实现不同设备宽度，实现页面元素大小的动态变化

#### 引入资源

- 当样式比较繁多的时候，我们可以针对不同的媒体使用不同 stylesheets（样式表）。
- 原理，就是直接在 link 中判断设备的尺寸，然后引用不同的 css 文件。

语法：

```html
<link
  rel="stylesheet"
  media="mediatype and|not|only (media feature)"
  href="mystylesheet.css"
/>
```

示例：

```html
<link
  rel="stylesheet"
  href="styleA.css"
  media="screen and (min-width: 400px)"
/>
```

#### rem 适配方案

::: tip
让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。
使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。
:::
实际开发中适配方案：

- 按照设计稿与设备宽度的比例，动态计算并设置 html 根标签的 font-size 大小；（媒体查询）
- CSS 中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 为单位的值；

rem 适配方案技术使用

![适配方案](https://img-blog.csdnimg.cn/a0b6ea5dab89442096a4d3595c121dc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

#### rem 实际开发适配方案一

一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果。现在基本以 750 为准。

```apl
动态设置 html 标签 font-size 大小
假设设计稿是750px
假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份）
每一份作为html字体大小，这里就是50px
那么在320px设备的时候，字体大小为320/15 就是 21.33px
用我们页面元素的大小 除以不同的 html 字体大小会发现他们比例还是相同的
比如我们以 750为标准设计稿
一个100*100像素的页面元素 在 750屏幕下， 就是 100 / 50 转换为rem 是 2rem * 2 rem 比例是 1比1
320屏幕下， html 字体大小为 21.33 则 2rem = 42.66px 此时宽和高都是 42.66 但是 宽和高的比例还是 1比1
但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果
```

> 元素大小取值方法

1. 最后的公式： 页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）
2. 屏幕宽度/划分的份数 就是 html font-size 的大小
3. 或者： 页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小

## LESS

CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。

- CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。
- 不方便维护及扩展，不利于复用。
- CSS 没有很好的计算能力
- 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。

Less （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也成为 CSS 预处理器。

- 做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性。

- 它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS - 维护成本，就像它的名称所说的那样，Less 可以让我们用更少的代码做更多的事情。

- Less 中文网址： http://lesscss.cn/

- Less 是一门 CSS 预处理语言，它扩展了 CSS 的动态特性。

### Less 变量

```less
@变量名: 值;
```

变量命名规范

- 必须有@为前缀
- 不能包含特殊字符
- 不能以数字开头
- 大小写敏感

### Less 编译

我们需要把我们的 less 文件，编译生成为 css 文件，这样我们的 html 页面才能使用。

我们可以在 vscode 安装 `Easy LESS` 插件来把 less 文件编译为 css。安装完毕插件，重新加载下 vscode。只要保存一下 Less 文件，会自动生成 CSS 文件。

### Less 嵌套

我们经常用到选择器的嵌套

```less
#header .logo {
  width: 300px;
}

#header {
  .logo {
    width: 300px;
  }
}
```

如果遇见 （交集|伪类|伪元素选择器）

- 内层选择器的前面没有 & 符号，则它被解析为父选择器的后代
- 如果有 & 符号，它就被解析为父元素自身或父元素的伪类

```less
a:hover {
  color: red;
}

a {
  &:hover {
    color: red;
  }
}
```

### Less 运算

任何数字、颜色或者变量都可以参与运算。就是 Less 提供了加（+）、减（-）、乘（\*）、除（/）算术运算。

```less
@width: 10px + 5;
div {
  border: @width solid red;
}

/* 生成的css */
div {
  border: 15px solid red;
}

/* Less甚至还可以这样 */
width: (@width + 5) * 2;
```

注意：

- 乘号（\*）和除号（/）的写法
- 运算符中间左右有个空格隔开 1px + 5
- 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位
- 如果两个值之间只有一个值有单位，则运算结果就取该单位
