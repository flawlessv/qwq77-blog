---
title: 动态规划01背包问题
tags:
  - 动态规划
categories: 算法
---
动态规划01背包问题是一个经典的优化问题，它的核心思想是将一个大问题分解为若干个小问题，然后通过求解子问题的最优解来得到原问题的最优解。在这个问题中，我们有一个容量为C的背包和N个物品，每个物品有一定的价值和重量。我们需要在不超过背包容量的前提下，选择一些物品放入背包，使得背包中物品的总价值最大。

下面我们用TypeScript来实现一个动态规划01背包问题的解决方案：

```typescript
function knapsack(C: number, weights: number[], values: number[]): number {
  const n = weights.length;
  const dp = Array.from({ length: n + 1 }, () => Array(C + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= C; j++) {
      if (j < weights[i - 1]) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);
      }
    }
  }

  return dp[n][C];
}
```

在这个代码中，我们首先定义了一个二维数组`dp`,用于存储每个子问题的最优解。接下来，我们使用两层循环遍历所有物品和背包容量的情况。对于每个物品，我们都有两种选择：要么不放入背包，此时最优解就是上一个物品的最优解；要么放入背包，此时最优解就是上一个物品不放入背包时的最优解加上当前物品的价值。最后，我们返回最后一个物品放入背包时的最优解。

首先，我们定义了一个函数`knapsack`,它接受三个参数：背包的容量`C`,物品的重量数组`weights`和物品的价值数组`values`。这个函数的目的是计算在不超过背包容量的前提下，能够获得的最大价值。

接下来，我们在函数内部定义了一个二维数组`dp`,用于存储每个子问题的最优解。数组的行数为物品的数量加一(因为我们需要考虑不放入任何物品的情况),列数为背包的容量加一(因为我们需要考虑背包容量为0的情况)。我们使用`Array.from`方法创建了这个数组，并用`fill`方法将所有元素初始化为0。

然后，我们使用两层循环遍历所有物品和背包容量的情况。外层循环变量`i`表示当前考虑的物品，从1开始到物品数量；内层循环变量`j`表示当前考虑的背包容量，从1开始到背包容量。

在每次循环中，我们都有两种选择：要么不放入当前物品，此时最优解就是上一个物品的最优解；要么放入当前物品，此时最优解就是上一个物品不放入当前物品时的最优解加上当前物品的价值。为了确定这两种情况中的最优解，我们需要比较`dp[i - 1][j]`(即不放入当前物品时的最优解)和`dp[i - 1][j - weights[i - 1]] + values[i - 1]`(即放入当前物品时的最优解)的大小。如果当前物品的重量小于等于背包剩余容量，那么我们就可以放入当前物品，此时最优解就是较大的那个；否则，我们就不放入当前物品，此时最优解就是较小的那个。

最后，当所有物品和所有背包容量的情况都考虑完毕后，我们就返回了最后一个物品放入背包时的最优解，即`dp[n][C]`。
