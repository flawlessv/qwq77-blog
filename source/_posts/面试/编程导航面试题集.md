---
title: 【编程导航】前端经典面试题合集
tags:
  - 面试
# categories:
#   - 前端
---

##### 分类汇总 90 道经典前端面试题目 + 题解

##### 作者：编程导航知识星球 + 星球⻥友们

## HTML

## 1 、有哪些常用的 HTML 标签？

#### 官方解析

HTML（Hyper Text Markup Language）是一种用于创建 Web ⻚面的标准标记语言。常用的 HTML 标签有：

```
标题标签（<h1>~<h6>）：定义⻚面中的标题，h1 表示最高级别的标题，h6 表示最低级别的标题。
段落标签（<p>）：定义一个段落，通常用于组织⻚面内容。
链接标签（<a>）：定义一个超链接，指向另一个文档或 Web ⻚面。
图像标签（<img>）：插入一个图像，可以通过指定图像的 URL 或相对路径来显示。
列表标签（<ul>、<ol>、<li>）：用于创建无序列表和有序列表。
表格标签（<table>、<tr>、<th>、<td>）：用于创建表格。
表单标签（<form>、<input>、<textarea>、<select>、<button>）：用于创建用户输入表单。
样式标签（<style>）：定义 CSS 样式。
脚本标签（<script>）：用于嵌入 JavaScript 脚本代码。
分割线标签（<hr>）：用于在⻚面中插入一条水平分割线。
```

以上是一些常用的 HTML 标签，通过组合使用这些标签，可以创建出各种复杂的 Web ⻚面。

#### ⻥友的精彩回答

**Stitch 的回答**

1.标题标签：h1~h

2.段落标签：p

3.换行标签：br

4.水平线标签：hr

5.图片标签：img

6.链接标签：a

7.div 和 span 标签

8.表单标签：form、input、label、textarea、select、button

9.文本格式化标签：b 和 strong、i 和 em、s 和 del、u 和 ins

10.表格标签：table、tr、td、th

11.列表标签：ul、ol、li、dl、dt、dd

12.语义化标签：header、nav、footer、article、section、aside

13.媒体标签：audio、video

14.头部标签：head

15.样式标签：style

16.脚本标签：script

17.其他基本标签：link、title、sub、sup

### 2 、什么是 HTML5，HTML5 有哪些新特性？

#### 官方解析

HTML5 是 HTML 的第五个版本，是用于创建网⻚和其他 web 应用程序的标记语言。与之前的 HTML 版本相比，
HTML5 引入了许多新特性和改进，包括以下几个方面：

```
语义化标签：HTML5引入了很多新的标签，如<header>、<footer>、<nav>、<article>、<section>等，这
些标签都是为了更好地表达文档内容的语义而设计的。
多媒体支持：HTML5 支持多媒体内容，包括音频、视频、SVG 和 Canvas 等图形元素，这些都可以直接在网
⻚中嵌入，无需使用第三方插件。
新的表单控件：HTML5 引入了一些新的表单控件，如日期选择器、搜索框、滑块等，这些控件都能够提高用
户体验。
Web 存储：HTML5 提供了两种新的客户端存储机制：localStorage 和 sessionStorage，它们可以让 Web 应
用程序在客户端上存储数据，从而提高性能和用户体验。
Web Workers：HTML5 提供了一种新的机制，即 Web Workers，它们可以让 Web 应用程序在后台运行，从
而提高性能和响应速度。
地理位置支持：HTML5 提供了一种新的 API，即 Geolocation API，它可以让 Web应用程序获取用户的地理
位置信息。
```

HTML5 的新特性为 Web 开发提供了更多的功能和工具，让开发者能够更加方便地开发 Web 应用程序，并提高用
户体验。

#### ⻥友的精彩回答

##### 你还费解吗 的回答

##### HTML5 是 HTML 最新的标准，它比 HTML 更加规范，并添加了许多新的特性：

##### 语义化元素：即语义程度更强的 HTML 元素，能增强代码的可读性，使代码结构更加清晰，比如：

```
<header>：定义整个文档或文档某一部分的头部区域。
<nav>：定义文档的导航链接部分，仅对文档中关键的链接使用。
<article>：定义文档中的内容区域，且内容必须是独立于文档的其它部分。
<section>：定义文档的节，可对文档的某一部分进行分块或分段。
```

##### 内容相关的额外内容区域。

```
<aside>：定义与某个
```

```
<footer>：定义整个文档或文档某一部分的底部区域。
表单元素：<datalist>、<keygen>、<output>
<input>的类型，如：
color：定义拾色器。
date：定义日期控件，包含年、月、日。
datetime：定义日期时间控件，包含年、月、日、时、分，基于 UTC 时区。
datetime-local：定义日期时间控件，包含年、月、日、时、分，无时区。
month：定义月份控件，包含月和年。
week：定义周控件，包含周和年。
<input>的属性，如：
required：规定当前输入域为必填项，当提交表单时会自动验证，若输入域为空则给出提示。
placeholder：用于设置当输入域为空时给出的提示信息。
autofocus：规定⻚面加载后，自动获取输入域的焦点。
autocomplete：是一个布尔值，若设置为true，则用户在输入时，浏览器会基于之前提交的值，显示出
在字段中填写的选项。
form：指定输入域所属的表单。
媒体元素：<video>（视频）和<audio>（音频）
拖放：用于将某个对象拖放到另一个位置。
地理定位：用于获取当前的位置。
Canvas：画布，通过 JavaScript 可以在画布中绘制各种图形。
SVG：可缩放矢量图形。
Web 存储：一种在浏览器本地存储数据的方法，通过两个全局对象实现：
sessionStorage（会话存储）：当关闭浏览器窗口后，数据会被删除。
localStorage（本地存储）：除非手动清除，否则数据将一直存在。
Web Socket：一种新的通信协议，允许服务端主动向客户端推送数据。
```

### 3 、iframe 标签的作用是什么？有哪些优缺点？

#### 官方解析

`<iframe>` 标签是 HTML 中的一个元素，用于在当前 HTML 文档中嵌入另一个 HTML 文档。它可以在一个 HTML
⻚面中嵌入另一个 HTML ⻚面或其他类型的文档，比如 PDF 文件或视频文件。

`<iframe>` 标签的主要作用是将一个⻚面嵌入到另一个⻚面中。例如，在一个⻚面中嵌入一个地图或一个视频，或
者在一个⻚面中嵌入一个在线表单，都可以使用 `<iframe>` 标签。

`<iframe>` 标签的优点包括：

```
可以让⻚面嵌入其他网站或文档，从而扩展⻚面的功能。
可以使用一个单独的文档来管理⻚面的内容，从而简化⻚面的管理。
可以在一个⻚面中嵌入多个 ，从而允许多个不同的内容在同一⻚面中显示。
```

`<iframe>` 标签的缺点包括：

```
可能会影响⻚面的加载速度和性能，特别是在⻚面中嵌入大型媒体文件时。
可能会影响⻚面的可访问性，因为屏幕阅读器可能无法读取嵌入的内容。
可能会导致安全⻛险，因为嵌入的文档可以访问父⻚面的 JavaScript 对象，从而可能被用于恶意攻击。
```

要实现 `<iframe>` 的效果，可以使用以下代码：

其中 src 属性指定要嵌入的文档的 URL，可以是一个 HTML ⻚面、一个 PDF 文件或一个视频文件等等。通过设置
width 和 height 属性可以指定 `<iframe>` 元素的尺寸。

```
⻥皮补充：这题如果有同学能提到部分微前端的实现是基于 iframe 的，会加分
```

### 4 、什么是 HTML 语义化？为什么要语义化？

#### 官方解析

##### HTML 语义化是指在编写 HTML 代码时，使用具有含义的标签来描述⻚面内容的结构和意义，而不是只关注⻚面的

表现形式。比如使用 <header> 标签来表示⻚面头部，使用 <nav> 标签来表示⻚面导航，使用 <article> 标签来表
示文章内容等。

HTML 语义化的目的在于增强⻚面的可读性和可维护性，使得开发人员和搜索引擎更容易理解⻚面的结构和内容。
此外，语义化的 HTML 代码也更符合无障碍标准，使得视力受限的用户等特定人群能够更方便地访问⻚面。

除此之外，语义化的 HTML 代码还有利于 SEO（搜索引擎优化），可以使得搜索引擎更好地抓取⻚面内容，提高
网站在搜索引擎中的排名。

综上所述，HTML 语义化可以使得⻚面更易读、易维护、易访问和易优化。

```
<iframe src="http://example.com"></iframe>
```

#### ⻥友的精彩回答

**H.lj**

##### !

##### ᯤᯤ ⁶ᴳ 的回答

##### HTML 语义化是指在编写 HTML 文档时，使用恰当的标签和属性，以及正确的结构来描述文档的内容、结构和意

义。HTML 语义化可以让 Web 开发人员更好地组织和呈现⻚面内容，使⻚面更具有可读性和可访问性，同时也有助
于提高 SEO 优化效果。

具体来说，HTML 语义化可以带来以下几个好处：

1. 代码可读性：通过语义化的标签和结构，可以更好地描述文档的结构和意义，使代码更加清晰易懂，方便维护
   和修改。
2. 改善用户体验：语义化的 HTML 结构可以提高⻚面的可读性和可访问性，使⻚面内容更容易被用户理解和使
   用，从而提高用户体验。
3. 提高 SEO 优化效果：语义化的 HTML 结构可以提高搜索引擎对⻚面的理解和评价，使网站更容易被搜索引擎收
   录和排名，从而提高 SEO 优化效果。
4. 更好的跨平台支持：语义化的 HTML 结构可以使⻚面更好地适应不同的浏览器和设备，提高⻚面的跨平台支持
   性和兼容性。
5. 更好的可维护性：通过语义化的 HTML 结构，可以更好地区分⻚面的内容和样式，使 CSS 和 JavaScript 的编写更
   加简单和直观，从而提高代码的可维护性。

因此，HTML 语义化是 Web 开发中非常重要的一个概念，它可以帮助开发人员更好地组织和呈现⻚面内容，提高
⻚面的可读性、可访问性和 SEO 优化效果，同时也有助于提高代码的可维护性和可扩展性

##### 作者：编程导航知识星球 + 星球⻥友们

## CSS 布局

### 1 、CSS 选择器有哪些？优先级分别是什么？

#### 官方解析

##### CSS 选择器可以根据不同的属性、标签名、类名、ID 等条件来选择⻚面中的元素，常用的选择器包括：

1. 标签选择器：通过标签名选取元素，如 p、h1、div 等。
2. 类选择器：以 "." 开头，选取具有相同类名的元素，如 .red、.bold 等。
3. ID 选择器：以 "#" 开头，选取具有相同 ID 的元素，如 #header、#content 等。
4. 属性选择器：根据元素的属性值选取元素，如 [href]、[title]、[src] 等。
5. 后代选择器：选取元素的后代元素，如 div p 选取所有 div 元素的后代 p 元素。
6. 相邻兄弟选择器：选取元素的相邻兄弟元素，如 h1 + p 选取紧接在 h1 元素后面的 p 元素。
7. 通用选择器：选取所有元素，使用 \* 表示。
   CSS 选择器的优先级按照如下规则计算：
8. 标签内部样式（内联样式）具有最高优先级，其次是 ID 选择器，然后是类选择器和属性选择器，最后是标签
   选择器和通用选择器。

##### 9. 如果存在多个选择器的优先级相同，那么后面出现的选择器具有更高的优先级。

10. !important 声明具有最高优先级。
    使用 CSS 选择器，可以选择⻚面中的特定元素，并对其应用样式，从而实现对⻚面布局和样式的控制。

#### ⻥友的精彩回答

##### 九仞的回答

##### CSS 选择器还有：

```
伪类选择器：通过class值：来定义伪类，常用：hover，如：.class值:hover{样式}
伪元素选择器：通过：：来定义伪元素，常用::before,::after，如：CSS选择器::after{样式}
```

关于 CSS 优先级

个人这样理解

!important，优先级最高！！！

1. 内联样式的 style， 权重 999
2. id 选择器，权重 100
3. 类，伪类，属性选择器，权重 10
4. 标签，伪元素选择器，权重 1

如果两个优先级相同，则以其定义的上下位置来生效，以最下方定义的样式为准

```
tip：内嵌样式>内联样式>外部样式
```

插一嘴，关于如何理解伪类和伪元素区别，个人这样理解，仅供参考。

首先它们都不存在与 dom 树中，伪类是为选择器提供一些特殊效果，如鼠标悬停展示伪类样式等，而伪元素是创造
一个元素，一个不在文档树中的元素，可以被审查到，一般用来创造有内容的虚拟容器。

因此伪类不产生新对象，伪元素会产生新对象，它们都不存在 dom 树中，伪类只是该选择器的元素的不同状态。

### 2 、有哪些常⻅的 CSS 布局？

#### 官方解析

##### CSS 布局是指在网⻚上排版并定位元素的方式，常⻅的 CSS 布局包括：

1. 盒模型布局：盒模型布局是指通过设置元素的 margin、padding、border 等属性，控制元素在⻚面中的位置
   和大小。
2. 浮动布局：浮动布局是通过设置元素的 float 属性，使元素脱离文档流并向左或向右浮动，从而实现对⻚面布
   局的控制。
3. 定位布局：定位布局是指通过设置元素的 position 属性为 relative、absolute 或 fixed，控制元素在⻚面上的
   位置。

4. 弹性布局：弹性布局是通过设置元素的 display 属性为 flex 或 inline-flex，控制元素在⻚面中的位置和大小，
   从而实现响应式布局。
5. 网格布局：网格布局是通过设置元素的 display 属性为 grid，使用网格线将⻚面分为若干行和列，控制元素在
   ⻚面中的位置和大小。
6. 还有表格布局，以及一些衍生的布局，比如：圣杯布局、双⻜翼布局
   以上是常⻅的 CSS 布局，开发者可以根据具体的需求和情况选择合适的布局方式，从而实现对⻚面布局和样
   式的控制。

#### ⻥友的精彩回答

##### 事已至此，先吃饭吧的回答：

grid 布局：分割⻚面，将其分为若干行列，从而进行快速布局，显示结果也较清晰

两栏布局：左边为导航栏，右边为⻚面内容，左边用绝对定位 absolution，右边宽度拉满 100%

圣杯布局：两边固定，中间内容，中间记得加 margin 和 width 为 100%拉满，或者弹性布局 flex 用 justofy-content 设
置 space-between，可均匀分布各个元素。常用的还有 center 等

**useGieGie 的回答：**

块级布局（Block layout）：这是最基本的布局方式，它使元素在⻚面上垂直堆叠。这种布局适用于单个⻚面元素
或简单的⻚面结构。

响应式布局（Responsive layout）：响应式布局可以根据设备屏幕的大小和方向自动调整⻚面布局，以提供更好
的用户体验。

流式布局（Flow Layout）：元素按照文档流自上而下排列，宽度自适应父容器或内容。这是 Web 开发中最常⻅的
布局方式

定位布局（Positioning Layout）：使用 position 属性将元素定位在文档中的特定位置。常用于实现悬浮菜单、弹
出框等效果。

多列布局（Multi-column Layout）：将内容分为多列，可以通过 column-count 和 column-width 属性来定义列
的数量和宽度。

瀑布流布局（Masonry Layout）：将元素按照不同高度和宽度自适应排列，以实现类似 Pinterest 等网站的瀑布流
效果。

块级格式化上下文布局（Block Formatting Context Layout）：通过创建块级格式化上下文来实现布局。例如，可
以使用 display: inline-block; 或 float: left; 等属性来创建块级格式化上下文，以实现列布局或流式布局等效果。

粘性布局（Sticky Layout）：将元素粘贴在视图中的特定位置，通常在滚动时保持可⻅。可以使用 position:
sticky; 属性来实现。

流体布局（Fluid Layout）：使用百分比宽度来创建自适应的布局，可以根据不同设备的屏幕大小自动调整。在这
种布局中，元素的宽度随着视口大小的变化而变化。

混合布局（Hybrid Layout）：使用多个布局技术的组合来实现复杂的布局需求，例如将弹性布局和网格布局结合
使用。

### 3 、CSS 中的 1 像素问题是什么？有哪些解决方案？

#### 官方解析

##### CSS 中的 1 像素问题指的是在高分辨率屏幕上显示的 1 像素边框或者细线在实际显示时会比 1 个物理像素更宽或更

##### 粗，从而导致边框或者细线看上去比预期的更粗或者更宽，影响⻚面的美观性和用户体验。

##### 造成这个问题的原因是由于高分辨率屏幕的像素密度比传统的屏幕要高，所以在屏幕上显示的一个 CSS 像素对应的

物理像素个数也会相应地增多，当使用 CSS 中的 1px 来设置边框或者细线时，实际上渲染出来的线条在屏幕上会
被拆分为多个物理像素，从而导致看上去更粗。

解决这个问题的方法有以下几种：

1. 使用图片代替边框或细线，这种方法能够保证显示效果的一致性，但是需要制作多张图片，增加了⻚面加载的
   开销。
2. 使用 scale 进行缩放，使用 transform 缩放 0.5 像素大小的边框，以达到渲染 1 像素的效果。例如：
3. 使用 border-image，border-image 可以实现将一张图片作为边框样式，图片会自动拉伸或者重复以填充边
   框。这种方法需要制作一张边框的图片，但是可以通过 CSS 控制图片的填充方式和边框样式，比较灵活。例
   如：
4. 使用 CSS3 的 box-shadow，可以用 box-shadow 属性来模拟边框。例如：

```
.border {
position: relative;
border: 1px solid #000;
}
.border:after {
content: "";
position: absolute;
top: -1px;
left: -1px;
right: -1px;
bottom: -1px;
border: 1px solid #000;
transform: scale(0.5);
}
```

```
.border {
border: 1px solid transparent;
border-image: url(border.png) 1 1 stretch;
}
```

```
.border {
box-shadow: 0 0 0 1px #000;
}
```

使用 viewport，在 head 中添加如下代码可以解决 1px 问题：

#### ⻥友的精彩回答

##### 一的回答

CSS 中的 1px 问题指的是,由于屏幕像素无法精确显示 1px,导致 1px 边框、阴影等在不同屏幕下显示效果不一致。
这一问题困扰了无数 CSS 开发者,因为实现均匀、一致的 1px 效果对 UI 设计至关重要。

为了解决 1px 问题,CSS 开发社区总结了一系列解决方案:

```
利用 GPU 加速绘制的特性,采用 outline、box-shadow 或 transform: scale(1); 来代替 border,从而获得更清
晰的 1px 效果。
outline 与 border 类似但会触发 GPU 绘制
box-shadow 也会触发 GPU 绘制
transform: scale(1); 则会强制触发 GPU 绘制
使用与屏幕大小相关的 viewport units(如 vw、vh 等)来代替固定的 px 单位。viewport units 会根据屏幕大小
进行缩放,从而可以在不同屏幕下实现更平滑、自然的 1px 效果。
简单地使用 2px 代替 1px,因为 2px 在大多数屏幕下都足够 thick,能以清晰、连续的形式显示。
使用 border-image 来绘制复杂的 1px 边框,border-image 支持使用 SVG 路径绘制多段式或圆⻆边框,能在高
像素密度屏幕下实现清晰的 1px 效果。
采用 CSS 变量和 media queries 的组合来针对不同设备像素密度调整 1px 值。在 @media (min-resolution:
2dppx) { /* 设置较大值,如 2px */ } 中为高像素密度屏幕设置较大的 1px 值是一种比较优雅的解决方法。
另外,确保采用 box-sizing: border-box; 以避免 border 和 padding 对元素宽度的影响,因为这会导致 1px 边
框的模糊不清。
```

总之,通过灵活运用上述各种方法,我们可以在保证 UI 设计效果的前提下,巧妙地解决 CSS 中棘手的 1px 问题。

### 4 、什么是 CSS 盒子模型？

#### 官方解析

CSS 盒子模型（CSS box model）指的是用于布局和设计网⻚的 CSS 样式规范。CSS 盒子模型将每个 HTML 元素
表示为一个矩形的盒子，这个盒子包括内容（content）、内边距（padding）、边框（border）和外边距
（margin）四个部分。

具体来说，盒子模型中各个部分的含义如下：

```
内容（content）：元素的实际内容，由 width 和 height 属性决定。
内边距（padding）：内容和边框之间的空间，由 padding 属性决定。
边框（border）：内容和外边距之间的边框，由 border 属性决定。
```

```
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-
scale=1.0,maximum-scale=1.0,user-scalable=no">
```

```
外边距（margin）：盒子边缘和其它元素之间的空间，由 margin 属性决定。
```

CSS 盒子模型中，盒子的总大小由这四个部分加起来决定，即 width + padding + border + margin。需要注意的
是，CSS 盒子模型有两种，分别是标准盒子模型和怪异盒子模型。

```
标准盒子模型中，盒子的大小 = width + padding + border + margin
怪异盒子模型中，盒子的大小 = width + margin，因为 width 已经包含了 padding + border
```

#### ⻥友的精彩回答

##### 你还费解吗的回答

盒子模型是构成 Web ⻚面的基本元素，所有 HTML 元素都可看作是盒子，一个网⻚一般是由多个盒子模型组成
的。
一个盒子模型由四部分组成，由内向外依次是：

```
Content box：内容，用于显示文本或其他内容。大小可通过 width 和 height 属性设置。
Padding box：内边距，用于调整内容区域与边框之间的距离，会受到盒子背景颜色的影响。大小可通过
padding 及其相关属性设置。
Border box：边框，包裹了内边距和内容区域，一般用于给盒子添加装饰。大小可通过 border 及其相关属性
设置。
Margin box：外边距，用于调整不同盒子之间的距离，不受盒子背景颜色的影响。大小可通过 margin 及其
相关属性设置。
```

盒子模型可以分为标准盒模型和替代（IE）盒模型，它们之间的区别如下：

```
标准盒模型：盒子的 width 和 height 属性对应的是内容区域，也就是说，一个盒子的实际大小是由设置的
width 和 height（内容区域）、内边距以及边框共同决定的。
替代（IE）盒模型：盒子的 width 和 height 属性对应的是包含边框在内的区域，也就是说，一个盒子的实际
大小仅仅是由设置的 width 和 height（边框、内边距、内容区域）决定的。
注意：尽管 Margin Box 会影响盒子在⻚面所占据的空间，但影响的是盒子的外部空间，与盒子的内部区域无
关，因此它不计入盒子的实际大小。盒子的范围到边框为止，不会延伸到 Margin box。
```

在 CSS 当中，可以通过设置元素的 box-sizing 属性来决定元素显示为哪种盒模型：

```
content-box：默认值，当前元素会显示为标准盒模型。
border-box：当前元素会显示为替代（IE）盒模型。
```

### 5 、哪些 CSS 属性可以继承？

#### 官方解析

##### 在 CSS 中，并不是所有的属性都可以继承。下面是一些常⻅的可继承属性：

```
font-family
font-size
```

```
font-weight
font-style
color
letter-spacing
word-spacing
line-height
text-align
text-indent
text-transform
visibility
```

这些属性在父元素中设置后，子元素可以继承相同的属性值。但需要注意的是，这些属性只能继承，而不能被子元
素覆盖。此外，并不是所有的 HTML 元素都可以继承这些属性，具体需要查看相关属性的文档。

⻥皮补充：这道题目如果能补充回答 “你在什么情况下用到了继承” 会更好

#### ⻥友的精彩回答

##### 一的回答

所谓继承就是指 html 元素可以从父元素那里继承一部分 css 属性，即使当前元素没有定义该属性。

**可以被继承的属性** :

1. 字体系列属性

字体系列属性主要包括： font-size、font-family、font-variant、font-style、font-weight、font、letter-
spacing、word-spacing、text-transform 和 line-height。如果没有在一个元素上设置这些属性，则其继承上层的
相应属性。

2. 文本系列属性

文本系列属性主要包括： color、direction、text-align、text-indent、text-decoration、text-shadow、white-
space、word-wrap 和 hyphens。只有 color 属性可以被继承自父元素，其它都不能继承。

3. 其他系列属性

其他系列属性主要包括： visibility、cursor、list-style 和 quotes。list-style 属性可以继承，但 quotes 属性不能
被继承。

**inherit（继承）值**

每一个属性可以指定值为“inherit”，即：对于给定的元素，该属性和它父元素相对属性的计算值取一样的值。继承
值通常只用作后备值，它可以通过显式地指定“inherit”而得到加强，例如：

##### 继承的局限性

```
p { font-size: inherit; }
```

继承虽然减少了重复定义的麻烦，但是，有些属性是不能继承的，例如 border（边框）、margin（边距）、
padding（补白）和背景等。

这样设定是有道理的，例如设定了边框，如果此属性也继承的话，那么在这个内所有的元素都会有边框，这无疑会
产生一个让人眼花缭乱的结果。

同样的，影响元素位置的属性，例如 margin（边距）和 padding（补白），也不会被继承。

同时，浏览器的缺省样式也在影响着继承的结果。例如：

<h2>2级标题的文字不是12px。// </h2> H2中文字将是标题 2 样式的文字而非12px大小的文字。

这是因为浏览器的缺省样式设定了<h2>的 CSS 规则。

同时，有些老版本的浏览器可能对继承支持的不太好，例如某些浏览器当遇到<table>的时候，就会丢失所有的继
承的属性。

**css 属性一旦继承了不能被取消，只能重新定义样式。**

⻥皮评论：分类记忆，不错

##### "

### 6 、什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？

#### 官方解析

##### 响应式设计是指通过一些技术手段，使得网站或应用在不同终端设备（如桌面电脑、平板电脑、手机等）上能够自

##### 适应地呈现最佳的用户体验。

##### 响应式设计的基本原理是根据屏幕的尺寸和分辨率等信息，动态调整⻚面的布局和元素的样式，以便使⻚面在不同

的设备上呈现出最佳的效果。实现响应式设计通常需要使用 HTML、CSS 和 JavaScript 技术，其中 CSS 媒体查询是
实现响应式设计的核心技术之一。

为了实现响应式设计，开发人员需要为不同屏幕尺寸和分辨率等场景提供不同的布局和样式。一种实现方式是使用
流体网格布局和百分比尺寸等技术，以便根据设备屏幕的宽度和高度等信息自适应地调整⻚面的布局和元素的大
小。另一种实现方式是使用 CSS 媒体查询，根据设备的屏幕尺寸和分辨率等信息，加载不同的样式文件或应用不同
的样式规则，以便实现不同场景下的最佳效果。

响应式设计的优点包括可以提高用户体验、提高网站访问率和转化率、降低开发成本等。同时，响应式设计也有一
些缺点，例如需要在各种设备上进行充分的测试和调试、可能需要加载大量的 CSS 和 JavaScript 文件等。

总之，响应式设计是一种非常重要的前端开发技术，能够帮助开发人员在不同终端设备上提供最佳的用户体验，提
高网站的访问率和转化率，同时也能减少开发成本和维护成本。

```
⻥皮补充：这道题的最后一问 “如何实现” 非常好，能直接反映你的前端经验，可以从最原始的实现（媒体查
询）、CSS 响应式布局、组件库框架等方面回答，聊聊自己尝试过的布局
```

```
body { font-size: 12px; }
```

### 7 、CSS3 新增了哪些特性？

#### 官方解析

##### CSS3 新增了很多新的特性，其中一些主要的特性包括：

1. Flexbox 弹性布局
2. Grid 网格布局
3. Animation 动画效果
4. Transform 变换效果
5. Transition 过渡效果
6. Box-sizing 盒模型
7. Shadow 阴影效果
8. Text-shadow 文字阴影效果
9. Gradient 渐变效果
10. Border-radius 圆⻆效果

这些特性可以大大增强 CSS 的功能，帮助开发者更方便地实现一些复杂的布局和动画效果。同时，这些特性也使得
网⻚的视觉效果更加丰富和生动。

```
⻥皮补充：这题的标准题解不够具体，大家可以针对某一类特性聊聊自己在项目中是如何使用的
```

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### CSS3 是 CSS 的第三个版本，也是最新的 CSS 标准，它包含了 CSS2.1 的所有功能，并且增加了许多丰富的特性：

##### 1. 替代（IE）盒模型

##### 2. 选择器：属性选择器、结构伪类选择器、伪元素选择器

3. 边框与圆⻆： border-radius、border-image、box-shadow
4. 文本：text-overflow、word-wrap、word-break、text-shadow
5. calc()：cal() 是 CSS3 新增的函数，用于动态计算属性值。
6. 滤镜（filter）：filter 用于定义元素（一般是）的可视效果（如模糊、饱和度）。
7. 背景：background-image 、background-size、background-origin、background-clip
8. 渐变（Gradients）：可以实现元素背景中两种或多种颜色之间的渐进过渡效果。
9. 字体图标：字体图标是一种使用字体文件中的符号来代替图像的技术。与传统的图像图标相比，字体图标具有
   许多优点，如易于使用、可调整大小、可缩放等。
10. 过渡（Transition）：用于将元素从一种状态平滑过渡到另一种状态，即实现动画效果。只有在某些特定的事
    件触发时才能过渡，比如鼠标悬停等。
11. 动画（Animation）：通过定义关键帧和时间函数来精确控制动画，可以实现比过渡更加自由和复杂的动画效
    果，且无需通过事件触发。

##### 12. 多列布局：多列布局是 CSS3 中一种用于分隔文本和内容的布局方式，它可以将一段文本分成多列，从而使⻚

##### 面更加紧凑和易读。

13. 弹性盒子（Flex Box）：弹性盒子是 CSS3 提供的一种新的布局方式，相比于传统的浮动定位布局更加灵活高
    效，常用在移动端。
14. 2D 转换：2D 转换是指在二维平面中对元素进行变换，包括平移、缩放、旋转和倾斜，不影响⻚面布局。
15. 多媒体查询：CSS3 支持多媒体查询，即根据设备类型来适应不同的屏幕尺寸，从而为用户带来更好的体验。
16. 3D 转换：3D 转换是指在三维空间中对元素进行变换，包括平移、缩放、旋转、倾斜和透视，不影响⻚面布
    局。

总之，CSS3 是一种强大、灵活、易于维护的样式表语言，它包含了许多新的特性和功能，可以帮助开发者更加高
效地创建网⻚。

### 8 、怎么用 CSS 实现一个宽高自适应的正方形？

#### 官方解析

可以使用 CSS 的 padding 或者利用 vw 单位来实现一个宽高自适应的正方形。

一种比较常⻅的实现方法是：

上面的代码中，利用 vw 单位设置了正方形的宽度为屏幕宽度的 1/4（25%），同时利用 padding-top 设置正方形的
高度也为屏幕宽度的 1/4，这样就实现了一个宽高自适应的正方形。

另外，也可以使用伪元素来实现：

```
<div class="square"></div>
```

```
.square {
width: 25vw; /* 利用vw单位实现自适应宽度 */
padding-top: 25vw; /* 利用padding实现自适应高度 */
background-color: red;
}
```

```
<div class="square"></div>
```

```
.square {
position: relative;
width: 50%;
background-color: red;
}
```

```
.square::before {
content: "";
display: block;
padding-top: 100%;
}
```

上面的代码中，通过设置 div 元素的宽度为 50% ，再利用 ::before 伪元素设置 padding-top 为 100% ，就可以实
现一个宽高自适应的正方形。

```
⻥皮评论：这题建议大家自己实现一下
```

#### ⻥友的精彩回答

**Kristen 的回答**

方法 1 、CSS3 vw 单位 CSS3 中新增了一组相对于可视区域百分比的⻓度单位 vw, vh, vmin, vmax。其中 vw 是相对
于视口宽度百分比的单位，1vw = 1% viewport width， vh 是相对于视口高度百分比的单位，1vh = 1% viewport
height；vmin 是相对当前视口宽高中 较小 的一个的百分比单位，同理 vmax 是相对当前视口宽高中 较大 的一个
的百分比单位。

##### 优点：简洁方便 缺点：浏览器兼容不好

方法 2 、设置垂直方向的 padding 撑开容器

在 CSS 盒模型中，margin, padding 的百分比数值是相对 父元素的宽度计算的。只需将元素垂直方向的一个
padding 值设定为与 width 相同的百分比就可以制作出自适应正方形

padding 百分比+height 设置 0 ； 这种方案简洁明了，且兼容性好；通常会给父元素设置固定的高度，子元素设置
width 百分比布局，通过 padding 是基于父元素宽度前提下，进行适配

方法 3 、利用伪元素的 margin(padding)-top 撑开容器

```
<div class="box"></div>
<style>
.box{width: 100vw;height: 100vw;background: #F2DEDE;}
</style>
```

```
<div class="box"></div>
```

```
<style>
.box{
width: 100%;
padding-bottom: 100%;/* padding百分比相对父元素宽度计算 */
height: 0;//避免被内容撑开多余的高度
}
</style>
```

```
<div class="box"></div>
```

```
<style>
.box {
width: 100%;
overflow:hidden;
background: #F2DEDE;
}
```

##### 由于容器与伪元素在垂直方向发生了外边距折叠，所以我们想象中的撑开父元素高度并没有出现。而应对的方法是

在父元素上触发 BFC：overflow:hidden;

若使用垂直方向上的 padding 撑开父元素，则不需要触发 BFC，如下：

##### 注意 当元素内部添加内容时高度出现溢出，可以将内容放到独立的内容块中，利用绝对定位消除空间占用，如下：

```
.box::after {
content: "";
display: block;
margin-top: 100%;
}
</style>
```

```
<div class="box"></div>
```

```
<style>
.box {
width: 100%;
background: #F2DEDE;
}
.box::after {
content: "";
display: block;
padding-top: 100%;
}
</style>
```

```
<div class="container">
<div class="box">内容</div>
</div>
```

```
<style>
.container {
width: 100%;
background: #F2DEDE;
position: relative;
}
.container::after {
content: "";
display: block;
padding-top: 100%;
}
.container .box{
position: absolute;
width: 100%;
height: 100%;
}
</style>
```

### 9 、CSS 中，有哪些方式可以隐藏⻚面元素？有什么区别?

#### 官方解析

##### 在 CSS 中，有以下几种方式可以隐藏⻚面元素：

1. display: none;：完全隐藏元素，元素不占据任何空间。
2. visibility: hidden;：隐藏元素，但元素在⻚面中仍占据空间。
3. opacity: 0;：将元素的透明度设为 0 ，元素隐藏但仍占据空间。
4. position: absolute; left: -9999px;：将元素移出屏幕范围之外，元素隐藏但仍占据空间。
5. z-index: -1;：将元素的层级设置为负数，元素隐藏但仍占据空间。

这些方式的区别在于是否占据空间和是否可⻅，开发者可以根据实际情况选择不同的方式来隐藏⻚面元素。

#### ⻥友的精彩回答

**Et cetera 的回答**

先举例如下:

```
display:none(元素不可⻅，不占据空间，无法响应点击事件,会触发重排重绘)
visibility:hidden(元素不可⻅，占据⻚面空间，无法响应点击事件，会触发重绘)
opacity:0(元素不可⻅，占据⻚面空间，可以响应点击事件,会触发重绘)
设置height、width模型属性为0,有内容还要设置overflow:hidden;(元素不可⻅，不占据⻚面空间，无法响应
点击事件)
position:absolute(脱标定位到⻚面外,元素不可⻅，不影响⻚面布局)
clip-path(元素不可⻅，占据⻚面空间，无法响应点击事件)
```

##### 你还费解吗的回答

##### 在 CSS 中，可以通过以下几种方式隐藏⻚面元素：

1. display: none：把整个元素从⻚面中移除，从而达到隐藏的效果。由于 display 是非继承属性，所以后代节点
   也会随父节点的消失而消失，即便设置后代节点的 display 也无法显示。另外，此做法可能会影响⻚面的布
   局，导致浏览器发生重排和重绘，造成性能的浪费。元素消失后，自身绑定的事件不会触发。
2. visibility: hidden：将元素设置为不可⻅。与 display: none 不同，不会移除元素，而是实现真正意义上的隐
   藏效果，元素在⻚面上依然占位。此外，通过 visibility 切换元素的隐藏与显示时不会触发重排，只会触发重
   绘。该方法的优势在于：visibility 是继承属性，即使父元素隐藏了，子元素也可以通过指定 visibility 的值显示
   出来；隐藏的内容可以被读屏器读取；能配合 transition 属性实现延时显示效果，提高用户体验。但要注
   意，隐藏后的元素无法触发自身绑定的事件。

3. 盒属性归 0 ：将一个元素的 margin、border、padding、width 和 height 设置为 0 ，如果元素内有子元素或
   内容，还应该设置 overflow:hidden 来隐藏其子元素，代码示例如下。在这种方式下，元素不占据空间，且
   无法响应事件。
4. position: absolute：使元素脱离文档流，相对于最近的定位（除静态定位外）父元素进行定位，通过调整偏
   移值将元素移出可视区域。当需要对网站进行 SEO 优化时，可以将 标签设置的 keywords（关键字）通过此
   方式隐藏在⻚面中，增加关键字的密度。注意，绝对定位会使元素以 display:inline-block 的形式显示。
5. position: relative：类似于绝对定位，也是通过调整各个方向上的偏移值来将元素移出可视区域，不同的是相
   对定位是相对于自己原来的位置，且元素不会脱离文档流，在⻚面中依然占有原位。
6. opacity: 0：只是将元素调整为不透明，所以依然存在于⻚面上，自身的事件可以触发，但其子元素不能通过
   设置 opacity 来达到显示的效果。
7. transform: scale(0,0)：将元素缩放为 0 。元素仍占位，但无法响应绑定的监听事件。
8. clip-path：通过裁剪的方式来实现元素的隐藏。元素仍占位，但无法响应绑定的监听事件。代码示例如下：

##### 对于上述方法，最常用的还是 1 和 2 ，其他的只能算是一种小妙招，不太推荐使用。

### 10 、怎么使用 CSS3 来实现动画？你实现过哪些动画？

#### 官方解析

##### CSS3 提供了丰富的动画效果，通过使用 CSS3 动画可以实现许多视觉效果，比如旋转、平移、缩放、淡入淡出

##### 等。

CSS3 动画的实现需要使用 @keyframes 规则和 animation 属性，具体的实现步骤如下：

定义关键帧 使用 @keyframes 规则定义动画关键帧。例如，定义一个旋转动画：

```
.hiddenBox {
overflow: hidden;
width:0;
height:0;
padding:0;
border:0;
margin:0;
}
```

```
.hide {
clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);
}
```

```
@keyframes spin {
from { transform: rotate(0deg); }
to { transform: rotate(360deg); }
}
```

##### 这个关键帧定义了从 0 度到 360 度的旋转动画。

应用动画 使用 animation 属性将动画应用到元素上。例如，将上面定义的 spin 动画应用到一个元素：

##### 这个样式定义了一个 2 秒线性旋转动画，并且无限循环。

CSS3 动画的优点在于它不需要使用 JavaScript，可以通过 CSS 代码实现各种复杂的动画效果，并且动画效果比使
用 JavaScript 实现的动画效果更加平滑。

在实际开发中，我们可以使用 CSS3 动画来实现各种动态效果，比如⻚面切换、元素滚动、菜单展开等。具体实现
要根据具体的需求来选择使用哪种动画效果，一些常⻅的动画效果包括：

```
淡入淡出
旋转
缩放
平移
拉伸
闪烁 我们可以使用 CSS3 动画来实现这些效果，提高用户体验和交互性。
```

#### ⻥友的精彩回答

**Kristen 的回答**

css3 动画的实现的方案，大概有以下方案：

```
js 的 animation() 方法实现动画
@keyframes + animation：这是一个实现动画的组合，必须一起使用。
i. @keyframes——创建动画
（ 1 ）在 @keyframes 中用 from 和 to 创建动画
（ 2 ）在 @keyframes 中用 “百分比” 创建动画
（ 3 ）将 @keyframes 嵌套进要添加动画的元素的样式里
ii. animation 执行动画
transition：表示过渡。transition 可以单独使用
transform：表示变形。使用 transform 实现动画时有两种选择：
transform + transition：一次性动画。transform 定义行为，transition 驱动，但一次仅能驱动一次。
transform + @keyframes + animation：支持循环动画。在 @keyframes 里使用 transform 定义行为，
animation 驱动，可充分调整动画的实现，包括：指定动画任意的执行次数，指定动画的结束与开始的状态等
等。
```

```
div {
animation: spin 2s linear infinite;
}
```

**transition 和 animation 实现动画的区别** ： transition：需要触发一个事件才执行动画。 animation：自动执行
动画，可循环执行。

### 11 、CSS 有哪些常用单位？这些单位各有什么区别？

#### 官方解析

##### CSS 中常用的单位有以下几种：

1. px（像素）：像素是相对于显示器分辨率而言的，是一个固定的单位。1px 可以被理解为显示器上的一个物
   理像素点，其大小和颜色由显示器自身控制。
2. em（相对⻓度单位）：em 是相对于父元素的字体大小的单位，当父元素没有设置字体大小时，em 相对于浏
   览器的默认字体大小。
3. rem（相对⻓度单位）：rem 同样是相对⻓度单位，但相对于根元素（即 html 元素）的字体大小。
4. %（百分比）：百分比是相对于父元素的宽度、高度、字体大小等的百分比。
5. vw、vh（视口单位）：vw 和 vh 分别代表视口的宽度和高度的百分比。
6. pt（点）：1pt 等于 1/72 英寸，常用于打印⻚面。
7. em 和 rem 的区别：em 和 rem 都是相对⻓度单位，但 em 的大小是相对于其父元素的字体大小，而 rem 的
   大小则是相对于根元素（即 html 元素）的字体大小。因此，rem 更加稳定，能够更好地控制⻚面布局和字体
   大小。

在使用 CSS 单位时，需要根据实际情况选择合适的单位。一般情况下，像素是最常用的单位，因为它在大多数情况
下可以提供良好的显示效果。对于需要在不同设备上适配的情况，可以使用 em、rem 和 vw、vh 等相对单位。

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### 按类型划分，CSS 的单位可分为绝对⻓度单位和相对⻓度单位，常⻅的有：

##### 绝对⻓度单位 ：

**px** ：CSS 像素，是最常用的一个单位，用于指定一个固定大小的元素——不会随设备（电脑、手机、ipad）的切
换、⻚面的缩放而改变。

扩展： **物理像素**

```
.iconfont-loadding {
animation: start_loadding 800ms linear 100ms infinite normal none running;
}
```

```
@keyframes start_loadding {
from { transform: rotate(0deg);}
to { transform: rotate(360deg);}
}
```

1 个 CSS 像素并不一定等于 1 个物理/设备像素 dp，物理像素就是真正构成设备显示屏的一个个像素点。早期， 1
个 px 等于 1 个 dp，但高清 2 倍屏、 3 倍屏的出现，导致手机屏幕的尺寸没有变化，屏幕的分辨率却提高了一倍或
几倍，即同样大小的屏幕上，像素多了一倍。比如，当设置某个元素的属性为 1px 时，我们期望的是该属性在屏幕
上占据 1 个物理像素，这在普通屏幕上当然是满足的，但在 2 倍屏上， 1 个 CSS 像素对应的却是 4 个物理像素
点，这也就导致了移动端中的 1px 边框会偏粗。注意，px 单位的值必须是整数。

扩展：怎么解决移动端的 1 px 问题？

**相对⻓度单位** ：

```
em ：em 在设置自 身字体大小 font-size 的时候是相对于 父元素 的字体大小，而设置 其他属性 （如width、
height）的时候，是相对于 自身 的字体大小，如果没有设置，则继承父级元素，如果父级元素也没有，则相对
于浏览器的默认字体大小。
```

```
注意：任意浏览器的默认字体大小都是16px，也就是说，所有未经调整的浏览器都符合: 1em = 16px。比
如，12px = 0.75em，10px = 0.625em。
```

```
rem：相对于 HTML 根元素 设置的字体大小，与 em 一样，如果没有设置则相对于浏览器的默认字体大小。
这个单位可谓集相对单位和绝对单位的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体
大小，又可以避免字体大小逐层复合的连锁反应。在实际应用中，rem 经常被用于响应式布局，以便元素可
以根据视口大小进行自适应调整。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。
```

扩展：如何通过 rem 实现简单的响应式布局？/ rem 适配方案？

```
%：百分比，当父元素的某些属性发生变化时，通过百分比可让元素也随之发生改变，从而实现响应式的效
果。在某些属性中百分比相对于自身，比如 translate、border-radius 等。
vw 和 vh：vw/vh 是与视图窗口有关的单位，vw 表示相对于视图窗口的宽度，⻓度等于视口宽度的 1/100；
vh 表示相对于视图窗口高度，⻓度等于视口高度的 1/100。
vmin 和 vmax：vmin 取 vw 和 vh 中的较小值；vmax 取 vw 和 vh 中的较大值；
```

扩展：用过 vw 和 vh 吗？应用场景是什么？

还有一些单位，不过极少使用，了解即可：

```
cm：厘米（1cm = 96px/2.54）
mm：毫米（1mm = 1/10th of 1cm）
in：英寸（1in = 2.54cm = 96px）
Q：四分之一毫米（1Q = 1/40th of 1cm）
pt：点（1pt = 1/72 of 1in）
pc：派卡 （1pc = 1/6th of 1in）
ch：相对于数字 “0” 的宽度
ex：相对于字符 “x” 的高度
lh：元素的 line-height
```

### 12 、有哪些 CSS 性能优化的操作或技巧？

#### 官方解析

##### 以下是一些常用的 CSS 性能优化操作和技巧：

##### 1. 使用合适的选择器 ：选择器的复杂度会影响 CSS 渲染性能。尽量使用简单的选择器，避免使用通配符和后代

##### 选择器等复杂的选择器。

2. **避免使用 @import：@import** 可以在 CSS 文件中导入其他 CSS 文件，但它会阻塞⻚面的渲染，影响性能。
   建议使用 link 标签来引入 CSS 文件。
3. **避免使用 !important：!important** 会影响 CSS 属性的优先级，而且会增加解析和渲染时间。建议尽量避免
   使用 !important。
4. **避免使用 inline 样式** ：inline 样式的优先级最高，但它会增加 HTML 文件的大小，降低⻚面的加载速度。建
   议使用外部 CSS 文件和内部样式表。
5. 压缩和合并 CSS 文件：压缩和合并 CSS 文件可以减小文件大小，提高⻚面加载速度。可以使用工具例如
   CSSMin 和 YUI Compressor 等来进行压缩和合并操作。 6.** 使用 CSS Sprites**：CSS Sprites 可以将多个小图片合并成一张大图片，并使用 CSS 来显示不同的部
   分，减少 HTTP 请求次数，提高⻚面加载速度。
6. **避免过度继承** ：过度继承会导致样式的冗余和继承链的深度增加，影响 CSS 的解析和渲染性能。
7. **避免使用高消耗的属性和值** ：某些属性和值的计算成本比较高，例如 box-shadow、border-radius 等，应该
   尽量避免使用。

以上是一些常用的 CSS 性能优化操作和技巧，可以帮助提高⻚面的加载速度和渲染性能。

#### ⻥友的精彩回答

**codexgh 的回答**

分享一些 CSS 性能优化小技巧：

**预加载样式表** ：

该 标记允许您在引用 CSS 之前启动下载，当样式表引用出现在其他资源之后，或者你已经嵌套了@导入指令：

```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Title</title>
```

```
<!-- preload CSS file -->
<link rel="preload" href="styles.css" as="style" />
```

```
<!-- more code -->
```

```
<!-- use preloaded styles -->
<link rel="stylesheet" href="styles.css" />
```

##### 删除未使用的样式和文件 ：

##### 删除所有不使用的样式表。你可能能够识别不再使用的⻚面、小部件或框架代码。如果您将样式表拆分为具有明确

##### 责任级别和适当文档的单独文件，则此任务会更容易。 以下工具可以通过分析 HTML 和 CSS 来识别冗余代码： ●

清除 CSS：https://purgecss.com/ ● 未使用 CSS：https://unused-css.com/ 单独的 HTML 分析通常是不够的，但
是您可以配置白名单样式，比如那些由 JavaScript 激活的样式。

##### 使用 HTML<链接>而不是 CSS@导入

@import at-rule 允许你在 css 中加载样式表：

这允许将样式表拆分为更小，更易于管理样式表，但是每个 @import 都会阻塞渲染，浏览器必须依次下载和解析
每个文件。使用 HTML link 标签效率更高，因为每个样式表都是并行加载的。

##### 简化选择器：

##### 现代浏览器解析⻓选择器没有问题，但是降低复杂性将减小文件大小，提高性能，并使代码更易于维护。 我们还应

该考虑新的：is、：where 和：has 选择器，它们可以像这样转换 CSS 选择器：

```
/* main.css */
@import url("reset.css");
@import url("base.css");
@import url("grid.css");
```

```
<link rel="stylesheet" href="reset.css">
<link rel="stylesheet" href="base.css">
<link rel="stylesheet" href="grid.css">
```

```
article section.primary:not(:first-child) h1,
article section.primary:not(:first-child) h2,
article section.primary:not(:first-child) p,
article section.secondary:not(:first-child) h1,
article section.secondary:not(:first-child) h2,
article section.secondary:not(:first-child) p {
color: red;
}
```

##### /_ 变成一句简洁的话： _/

```
article section:not(:first-child):where(.primary, .secondary) :where(h1, h2, p) {
color: red;
}
```

##### 作者：编程导航知识星球 + 星球⻥友们

## JavaScript

### 1 、JavaScript 中如何中止网络请求？

#### 官方解析

在 JavaScript 中，我们可以通过 AbortController 和 AbortSignal 来中止网络请求。

使用 AbortController 创建一个新的 AbortController 对象，然后使用它的 abort() 方法来中止请求。在创建请求
时，将 AbortController.signal 分配给请求的 signal 属性，以便在调用 abort() 方法时取消请求。

以下是一个使用 AbortController 中止 fetch 请求的示例：

在上面的示例中，我们通过调用 controller.abort() 方法来取消网络请求。

使用 AbortController 和 AbortSignal 是中止网络请求的一种可靠方式，并且在现代浏览器中得到了广泛支持。

#### ⻥友的精彩回答

**Stars 的回答**

JavaScript 中常用的网络请求方式为 ajax(XMLHttpRequest 实现)，fetch、axios

以下为各种请求的终止方式

1. xhrInstance.abort()
   使用 XHR 对象中止请求，可以调用 abort() 方法。例如：

```
const controller = new AbortController();
const signal = controller.signal;
```

```
fetch(url, { signal }).then(response => {
// Handle the response
}).catch(error => {
if (error.name === 'AbortError') {
console.log('Request was cancelled');
} else {
console.log('Request failed:', error);
}
});
```

```
// To abort the request, call the following:
controller.abort();
```

当一个请求被终止，它的 readyState 将被置为 XMLHttpRequest.UNSENT (0)，并且请求的 status 置为 0 。

2. AbortController.abort()

abort() 方法会在 DOM 请求完成之前中止它。它能够中止 fetch 请求、各种响应主体或者流的消耗。

3. CancelToken

```
const xhr = new XMLHttpRequest()
xhr.open(method,url)
xhr.send()
```

```
// 然后在某个时间点调用 abort() 方法
xhr.abort();
```

```
const controller = new AbortController();
const signal = controller.signal;
```

```
fetch('https://example.com/data', { signal })
.then(response => {
})
.catch(error => {
});
```

```
// 然后在某个时间点调用 abort() 方法
controller.abort();
```

```
const source = axios.CancelToken.source();
```

```
axios.get('/api/data', {
cancelToken: source.token
}).then(response => {
// 处理响应
}).catch(error => {
if (axios.isCancel(error)) {
console.log('请求已被取消：', error.message);
} else {
console.log('请求出错：', error.message);
}
});
```

```
source.cancel('请求已被用户取消');
```

##### 九仞补充

js 给的 api 让我们可以随时中断一个 fetch 请求，那么，如果我想造轮子实现这个功能该怎么做呢？

**Promise**

首先能想到的是用一个 Promise，来包装 fetch 返回的 promise，再使用包装的 Promise.reject 方法来实现中断请
求

不过函数返回时我使用了 Promise.race 而不直接返回 abortPromise，原因是因为 fetch 可能返回异常，直接返回
包装的 promise 则可能产生无法捕获的异常

以下是示例代码

```
const controller = new AbortController();
const signal = controller.signal;
```

```
fetch(url, { signal }).then(response => {
// Handle the response
}).catch(error => {
if (error.name === 'AbortError') {
console.log('Request was cancelled');
} else {
console.log('Request failed:', error);
}
});
```

```
// To abort the request, call the following:
controller.abort();
```

```
const fetchAbort = (url: string) => {
let res, abort;
const abortPromise = new Promise<Response>((resolve, reject) => {
res = resolve;
abort = reject.bind(this, `Fetch "${url}" has been aborted`);
});
return {
response: Promise.race([fetch(url).then(ret => res(ret)), abortPromise]),
abort
};
};
const { response, abort } = fetchAbort("./serverConfig.json");
abort();
// abort后，response的promise链将catch到fetch abort消息
// 而不会返回fetch返回的消息
response
.then(ret => ret.text())
.then(txt => console.log(txt))
.catch(err => {
console.log(err);
```

##### 输出：

代码缺陷也显而易⻅，这段代码虽然能拦截 fetch 的返回，但是 fetch 占用的网络资源并不会被释放。

也就是说，如果 api 请求还在 pending 状态，控制台 network 列表仍然能看到 fetch 还在请求状态，占用着 io 资
源。

所以，如果想要 abort 的同时，释放 fetch 占用的资源，单靠 Promise 是不够的。

**XMLHttpRequest.abort()**

可以使用 XML 代替 fetch，反正造轮子就是为了绕开 fetch，封装就完了

##### });

```
Fetch "./serverConfig.json" has been aborted
```

```
const fetchAbort = (url: string) => {
let res, abort, xhr;
const xhrPromise = new Promise((resolve, reject) => {
xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
if (xhr.readyState === 4) {
if (this.status == 200) {
return resolve(this.response);
}
return reject({
xhr: this,
msg: "Error",
status: this.status,
statusText: this.statusText
});
}
};
xhr.open("Get", url);
xhr.send();
});
const abortPromise = new Promise((resolve, reject) => {
res = resolve;
abort = () => {
xhr.abort();
return reject(`Fetch "${url}" has been aborted`);
};
});
return {
response: Promise.race([xhrPromise.then(ret => res(ret)), abortPromise]),
abort
};
};
const { response, abort } = fetchAbort("./serverConfig.json");
```

##### 输出：

和 fetch 的原生 abort 代码对比，可以看到请求大小为 0B，说明请求虽然发出去了，但是浏览器直接断开了连接，
并没有选择接收。于是实现了一个简单的 fetchAbort

##### 不过封装程度还不够，剩下的轮子就不造了，了解原理才是本次造轮子的目的。

### 2 、什么是 BOM 和 DOM？分别列举一些它们的函数

#### 官方解析

BOM 和 DOM 都是 JavaScript 中的概念，但它们具有不同的作用。

BOM（Browser Object Model）是浏览器对象模型，它提供了一些浏览器窗口和框架的对象，并提供了一些操作
这些对象的方法。BOM 不是 W3C 标准，而是由浏览器厂商制定的。

下面是一些常⻅的 BOM 函数：

```
alert()：在浏览器中显示一个警告框。
confirm()：在浏览器中显示一个确认框，要求用户单击“确定”或“取消”按钮。
prompt()：在浏览器中显示一个提示框，要求用户输入文本。
setTimeout()：用于在指定的时间后执行一段代码。
setInterval()：用于以指定的时间间隔重复执行一段代码。
```

DOM（Document Object Model）是文档对象模型，它定义了一种标准的方法来访问和操作 HTML 或 XML 文档
中的元素和内容。DOM 是 W3C 标准。

下面是一些常⻅的 DOM 函数：

```
getElementById()：根据元素 ID 获取元素对象。
getElementsByTagName()：根据标签名获取元素对象数组。
getElementsByClassName()：根据类名获取元素对象数组。
appendChild()：将一个节点添加到指定父节点的子节点列表的末尾。
removeChild()：从指定父节点的子节点列表中删除一个子节点。
```

总体来说，BOM 主要用于操作浏览器窗口和框架，而 DOM 主要用于访问和操作 HTML 或 XML 文档中的元素和内
容。

```
abort();
response
.then(ret => console.log(ret))
.catch(err => {
console.log(err);
});
```

```
Fetch "./serverConfig.json" has been aborted
```

#### ⻥友的精彩回答

**luckythus 的回答**

DOM 简介:文档对象模型(Document Object Model,简称 DOM),是 W3C 组织推荐的可处理标记扩展语言的标准编程
接口 ，W3C 已经定义了一系列的 DOM 接口,通过这些 DOM 接口可以改变网⻚的内容,结构和样式.

DOM：

1. 文档对象模型
2. DOM 把文档看作一个对象来看待
3. DOM 的顶级对象是 document
4. DOM 主要学习的是操作⻚面元素

常用接口函数：

```
getElementById 根据Id名获取文档的元素对象
getElementsByTagName 根据标签名获取元素对象集合，以伪数组的形式存储
getElementsByClassName 根据类名获取元素集合
querySelector ('符号+选择器')返回指定选择器的第一个对象
querySelectorAll ('符号+选择器')返回指定选择器的所有元素对象集合
appendChild 将一个节点添加到指定父节点的子节点列表的末尾。
```

BOM(Browser Object Model)

即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象

BOM:

```
浏览器对象模型
BOM 把浏览器当作对象来看待
BOM 的顶级对象是：window
BOM 学习的是浏览器窗口交互的一些对象
BOM 是浏览器厂商在各自浏览器上定义，兼容性差
```

BOM 常用的接口函数

1. alert()：在浏览器中显示一个警告框
2. onload() 窗口（⻚面）加载事件
3. addEventListener() 监听事件响应然后触发对应操作
4. setTimeout()：用于在指定的时间后执行一段代码。
5. setInterval()：用于以指定的时间间隔重复执行一段代码。

### 3 、深拷⻉和浅拷⻉有什么区别？JS 怎么实现深拷⻉？

#### 官方解析

##### 深拷⻉和浅拷⻉是复制数据结构的两种不同方式。

##### 浅拷⻉是创建一个新的对象，新对象的一些属性引用原始对象中相同的属性。这意味着在原始对象或新对象上的更

##### 改会相互影响。

##### 深拷⻉是创建一个新的对象，并复制原始对象的所有属性，包括嵌套的对象和数组。这意味着在原始对象或新对象

##### 上的更改不会相互影响。

在 JavaScript 中，可以通过以下方式实现深拷⻉：

JSON.parse() 和 JSON.stringify() 方法

这是实现深拷⻉的一种简单方式，但它有一些限制，例如不能复制函数和特殊对象（如 Date）。同时，它不能处
理包含循环引用的对象。

以下是使用 JSON.parse() 和 JSON.stringify() 方法实现深拷⻉的示例代码：

##### 递归拷⻉对象

##### 这种方法涉及递归遍历对象，并创建一个新的对象，复制原始对象的属性，并在需要时递归复制嵌套的对象和数

##### 组。这种方法可以处理循环引用，并复制函数和特殊对象。

##### 以下是使用递归拷⻉对象实现深拷⻉的示例代码：

```
const obj = { name: 'John', age: 30, address: { city: 'New York', state: 'NY' } };
```

```
const obj2 = JSON.parse(JSON.stringify(obj));
```

```
obj2.address.city = 'Chicago';
```

```
console.log(obj.address.city); // Output: New York
console.log(obj2.address.city); // Output: Chicago
```

```
function deepClone(obj) {
if (typeof obj === 'object' && obj !== null) {
let result = Array.isArray(obj)? [] : {};
for (let key in obj) {
if (obj.hasOwnProperty(key)) {
result[key] = deepClone(obj[key]);
}
}
return result;
}
return obj;
}
```

##### 深拷⻉的缺点是它可能会更加耗时，因为需要递归遍历整个对象图，复制所有属性和嵌套的对象和数组。而浅拷⻉

##### 是一种更快的复制方式，因为它只复制了对象的引用。在某些情况下，浅拷⻉可能会更有效。

#### ⻥友的精彩回答

**Tri-X 的回答**

浅拷⻉与深拷⻉的主要区别在与对引用类型的复制，深拷⻉会复制对象中的数据，改变深拷⻉对象中的属性原对象
中的属性不会被影响。浅拷⻉则是引用该对象，改变其中的属性会影响原来对象中的属性。也要理解浅拷⻉与赋值
的区别，赋值对于对象中的基本类型采用引用其地址的方式，但浅拷⻉会复制基本类型的数据。

浅拷⻉可以使用 Object.assgin 这个方法来拷⻉。

深拷⻉可以使用 JSON.parse(JSON.stringfy())来实现，但是这个方式的缺陷是不能对函数进行拷⻉。为了改善这个
方法可以使用递归来拷⻉。

以下是通过递归来实现深拷⻉的代码

```
const obj = { name: 'John', age: 30, address: { city: 'New York', state: 'NY' } };
```

```
const obj2 = deepClone(obj);
```

```
obj2.address.city = 'Chicago';
```

```
console.log(obj.address.city); // Output: New York
console.log(obj2.address.city); // Output: Chicago
```

```
function clone(target, map = new Map()) {
```

```
if (typeof target === 'object') {
```

```
let cloneTarget = Array.isArray(target)? [] : {};
```

```
if (map.get(target)) {
```

```
return map.get(target);
```

##### }

```
map.set(target, cloneTarget);
```

```
for (const key in target) {
```

```
cloneTarget[key] = clone(target[key], map);
```

```
}
```

```
return cloneTarget;
```

### 4 、如何使用 JavaScript 来判断用户设备类型？比如判断是 PC 端还是移

### 动端访问？

#### 官方解析

##### 可以通过以下两种方式来判断用户设备类型：

一、利用 navigator.userAgent 属性来获取用户代理信息，然后通过正则表达式判断是否为移动设备。示例代码如
下：

##### 这里的正则表达式匹配了一些移动设备的关键词，如果用户代理信息中包含这些关键词，则可以认为是移动设备。

二、利用 window.matchMedia 方法来根据屏幕宽度判断是否为移动设备。示例代码如下：

这里的参数 (max-width: 768px) 表示屏幕宽度最大为 768 像素，如果当前屏幕宽度小于等于 768 像素，则可以认
为是移动设备。

```
} else {
```

```
return target;
```

```
}
```

```
};
```

```
function isMobile() {
return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera
Mini/i.test(navigator.userAgent);
}
```

```
// 使用示例
if (isMobile()) {
console.log('This is a mobile device.');
} else {
console.log('This is a desktop device.');
}
```

```
function isMobile() {
return window.matchMedia('(max-width: 768px)').matches;
}
```

```
// 使用示例
if (isMobile()) {
console.log('This is a mobile device.');
} else {
console.log('This is a desktop device.');
}
```

##### ⻥皮评论：这题是相对比较简单的， 上面几种方法大家都可以试试

#### ⻥友的精彩回答

**useGieGie 的回答**

可以使用一些特定的 API 来判断用户设备类型，以下是一些常用的方法：

1. navigator.userAgent：该属性返回用户代理头的字符串，可以使用正则表达式来判断是否包含移动设备的标
   识符，例如 "Mobile"、"Android"、"iPhone" 等。如果包含则说明是移动设备，否则是 PC 端。
2. window.matchMedia()：该 API 可以根据不同的媒体查询条件来判断用户设备类型，例如屏幕宽度、设备方
   向等。可以使用 media query 字符串来创建一个 MediaQueryList 对象，然后调用 matches 属性来判断是否
   匹配。
3. window.innerWidth 和 window.innerHeight：这两个属性返回浏览器窗口的宽度和高度，可以根据窗口大
   小来判断用户设备类型。通常移动设备的屏幕宽度比较小，因此可以将窗口宽度小于某个值作为判断条件。
4. 使用第三方库：有一些第三方库可以更准确地判断用户设备类型，例如 isMobile、mobile-detect、detect.js
   等。这些库通常基于更全面的用户代理头信息和设备特性进行判断，可以提供更精确的结果。使用这些库需要
   先引入对应的库文件，然后调用相应的方法进行判断。
5. 使用特殊标识：在 URL 参数中添加特殊标识或者在 Cookie 中保存设备类型信息，然后通过解析 URL 参数或
   者读取 Cookie 中的信息来判断用户设备类型。这种方法需要在用户访问时设置对应的标识或者信息，然后在
   后续请求中使用。
6. 使用 UA 字符串：每个浏览器都有一个 User-Agent (UA) 字符串，其中包含了浏览器和设备的相关信息。通过
   解析 UA 字符串，可以判断用户设备类型。但需要注意的是，UA 字符串可以被篡改，因此这种方法并不可
   靠。

```
⻥皮评论：第三方库这个补充很好
```

##### 一的回答

用户访问网站的设备不断增多，包括 PC 端、移动端、平板电脑等等，对于 web 开发者而言，如何判断用户访问当
前⻚面的设备，可以帮助我们正确调节⻚面，为不同设备用户提供优质的体验。使用 JavaScript 来判断用户访问网
站的设备类型，尤其是 PC 与移动端设备间的区分，有以下几种方法。

**通过浏览器 userAgent 来区分**

当网⻚加载时，浏览器会将设备的相关信息发送给服务器，在 JavaScript 中，我们可以利用 navigator.userAgent
获取到这些信息，浏览器会将手机的相关信息发送给服务器，通过判断这些信息，可以较准确的判断用户是否使用
的是手机浏览器，也可以进一步区分不同的移动端设备。

**利用 JavaScript 的屏幕大小**

JavaScript 中可以获取到浏览器的屏幕大小，可以通过屏幕的大小，来区分 PC 与移动端设备，一般来说，PC 端的
屏幕比较大，而移动端的屏幕则相对较小。

**检测固定设备**

除了上述两种方法之外，我们还可以通过检测设备固定的参数来进行判断，比如移动端可以检测
window.orientation 参数，使用改参数可以判断设备是否处于横屏或竖屏模式，从而得出用户设备。

以上三种方式是使用 JavaScript 判断用户访问网站的设备类型，特别是 PC 与移动端的区分，在实际应用中，我们
可以将多种判断方式结合使用，让判断更加准确，可以根据设备类型应用不同的 css 样式，也可以加载不同大小的
图片等。

### 5 、JS 中数组是如何在内存中存储的？

#### 官方解析

在 JavaScript 中，数组是一种特殊的对象，可以用于存储一组有序的数据。数组在内存中的存储方式与其他对象类
似，都是存储在堆中。

JavaScript 中的数组是一种动态数组，可以自动扩展和收缩。当一个数组需要扩展时，JavaScript 引擎会为其分配
更多的内存空间，同时将原有数据拷⻉到新的内存空间中。当一个数组需要收缩时，JavaScript 引擎会将其内存空
间释放掉。

在 JavaScript 中，数组的每个元素是通过其索引来访问的。索引是一个整数，用于指定数组中的一个元素。
JavaScript 中的数组索引是以 0 开始的，也就是说，第一个元素的索引为 0 ，第二个元素的索引为 1 ，以此类推。

由于 JavaScript 中的数组是动态数组，所以它的索引可以随时改变。因此，当你访问一个数组时，需要确保你正在
访问的索引是有效的，否则会导致数组越界的错误。

```
⻥皮评论：这题比较基础，了解一下即可
```

#### ⻥友的精彩回答

##### 星光的回答

##### 1 、在哪里存储？

##### JS 中的数组是在堆内存中进行存储的，并且在栈内存中有指针来指向数组在堆内存的起始地址。

##### 2 、以什么形式进行存储？

##### JS 中的数组继承于对象，因此可以存储不同数据类型的元素，可以是字符串、对象、数字、布尔值等，各个元素占

##### 的内存大小不一，JS 引擎很难直接分配一块连续内存来进行存储，容易造成空间浪费。为了解决这种问题，JS 引擎

##### 设有快数组和慢数组。

##### 快数组采用线性存储的方式，占用一块连续内存来进行存储。新创建的数组默认都是快数组。

快数组⻓度可变，可动态扩展和收缩。当 push 元素，需要扩容时，会申请一块原来的 1.5 倍+16 的内存空间，并将
原来的数据拷⻉过去，返回++length；当 pop 元素后，会判断当前容量是否大于等于 length\*2+16，决定是否收缩
容量，并根据 length+1 == old_length 来决定收缩一半容量还是回收全部容量。

慢数组采用字典存储结构（key，value，description）来记录映射关系，内存不连续。

快数组=》慢数组：快数组扩容时，如果出现大量“孔”，如原数组为[1,2], 突然 a[1999] = 123，全填充数组变得特别
稀疏，容量变成原来的 9 倍以上，或者新增的索引值比原来最大索引值 大于 1024 ，则快数组变成慢数组。
慢数组=》快数组：慢数组收缩时，如果元素实际所占内存小于数组所占内存容量的一半，则可转化为快数组。如
上述例子，delete a[1999]，慢数组则有机会转为快数组。

3 、数组元素占据多大内存？

首先，在 V8 引擎当中，数字区分为 Smi 和 HeapNumber 两种，前者代表小整数（可以用 32 位表示的数字），后者
代表浮点数和无法用 32 位表示的数，比如 NaN，Infinity，-0，1.1 等。 （JS 数字默认为 64 位表示，为加快数字运算
速率，将小整数优化为 32 位进行运算）

其次，根据不同元素类型，数组可分大致分为 6 种类型：

1 、PACKED_SMI_ELEMENTS：元素全为 Smi 类型的全填充数组

2 、HOLEY_SMI_ELEMENTS:元素全为 Smi 类型的带孔数组

3 、PACKED_DOUBLE_ELEMENTS：元素全为 HeapNumber 类型的全填充数组

4 、HOLEY_DOUBLE_ELEMENTS:元素全为 HeapNumber 类型的带孔数组

5 、PACKED_ELEMENTS：存在元素无法用 HeapNumberr（Double）或 Smi 类型表示的全填充数组

6 、HOLEY_ELEMENTS:存在元素无法用 HeapNumberr（Double）或 Smi 类型表示的带孔数组

Smi 类型的数组各个元素只占 4 字节，HeapNumber（Double）类型元素的各个元素占 8 字节，而对于
PACKED_ELEMENTS 和 HOLEY_ELEMENTS 这类数组，取决于数组中是否有 Double 类型元素，有则全为 8 字节，无
则 4 字节。

另外，数组类型的转化只有从上到下，如 PACKED_SMI_ELEMENTS => PACKED_DOUBLE_ELEMENTS =>
PACKED_ELEMENT，如 【 1 】 =》 【 1 ，0.1】 =》 【 1 ，｛｝】
【 1 ，｛｝】 =》 【 1 ，0.1】依旧为 PACKED_ELEMENT 类型数组

注意，元素内存大小 只有数组类型变化时，才会改变。如【 1 ，0.1】此时元素占 8 字节，变成【 1 ，｛｝】数组类
型变化，并且数组中没有 Double 类型元素，则此时元素占 4 字节，如果此时还有 Double 类型元素，则依旧占 8 字
节。

### 6 、JS 中 Map 和 WeakMap 有什么区别？

#### 官方解析

在 JavaScript 中，Map 和 WeakMap 都是键值对的集合，但它们有几个重要的区别：

1. 键类型：Map 对象的键可以是任何类型，包括基本数据类型和对象类型，而 WeakMap 对象的键必须是对象
   类型。
2. 垃圾回收：Map 对象中的键和值都会被常规垃圾回收机制回收，而 WeakMap 中的键是弱引用，即在对象被
   垃圾回收时，WeakMap 中对应的键值对也会被自动删除。这使得 WeakMap 通常用于缓存或元数据，当对
   象不再被使用时，WeakMap 可以自动清除对应的数据，避免内存泄漏。
3. 迭代器：Map 对象有内置的迭代器，可以通过 for...of 循环来遍历键值对，而 WeakMap 没有内置的迭代
   器，因此不能直接遍历键值对。

综上所述，Map 和 WeakMap 在功能上有所重叠，但应用场景不同。Map 可以存储任何类型的键值对，适用于大
部分情况；WeakMap 适用于需要自动清除的缓存和元数据场景。

#### ⻥友的精彩回答

**Kristen 的回答**

1.弱引用
与强引用不同，弱引用并不阻止被引用的对象被垃圾收集器回收或收集，即使它是内存中对对象的唯一引用。

##### 以上代码的输出如下：

当我们将 man 变量重新赋值为 null 时，内存中对原始对象的唯一引用是弱引用，它来自我们前面创建的
WeakMap。当 JavaScript 引擎运行垃圾收集过程时，man 对象将从内存和我们分配给它的 WeakMap 中删除。这
是因为它是一个弱引用，并且它不阻止垃圾收集。

2.强引用
JavaScript 中的强引用是防止对象被垃圾回收的引用。它将对象保存在内存中。

下面的代码片段说明了强引用的概念：

由于 human 数组和对象之间存在强引用。对象被保留在内存中，可以通过以下代码访问：
console.log(human[0]) 这里要注意的重要一点是，弱引用不会阻止对象被垃圾回收，而强引用却会阻止对象被垃
圾回收。

与 map 不同，WeakMap 保存弱引用。因此，如果这些值在其他地方没有被强引用，它不会阻止垃圾回收删除它
引用的值。除此之外，WeakMap 与 map 是相同的。由于弱引用，WeakMap 不可枚举。

区别总结

Map 和 WeakMap 都是键值对的集合 Map 对象的键可以是任何类型，包括基本数据类型和对象类型，而
WeakMap 对象的键必须是对象类型。 垃圾回收：Map 对象中的键和值都会被常规垃圾回收机制回收，而
WeakMap 中的键是弱引用，即在对象被垃圾回收时，WeakMap 中对应的键值对也会被自动删除。当对象不再被
使用时，WeakMap 可以自动清除对应的数据，避免内存泄漏。 Map 对象有内置的迭代器，而 WeakMap 没有内
置的迭代器，因此不能直接遍历键值对。

```
// 创建 WeakMap 对象的实例
let human = new WeakMap();
// 创建一个对象，并将其赋值给名为 man 的变量
let man = { name: "xiaan" };
// 调用 human 的 set 方法，并传递两个参数(键和值)给它
human.set(man, "done")
console.log(human)
```

```
WeakMap {{...} => 'done'}
man = null;
console.log(human)
```

```
let human = [man];
man = null;
console.log(human);
```

##### 你还费解吗的回答

Map 和 WeakMap 都是 ES6 新增的用于存储键/值对的集合（Hash 结构），类似于对象。它们之间的区别如下：

```
键的类型：Map 的键可以是任意数据类型，如字符串、数组、DOM 节点对象等。而 WeakMap 只能接受引
用类型作为键，如果将其它类型作为键，则会报错。
引用强度：Map 的键是强引用的，强引用就是默认的引用关系，比如创建一个普通的对象 let obj = {}，这个
对象就是强引用的。 JavaScript 规定，只要一个对象被强引用，也就是可以被访问，垃圾回收机制就不会回
收对象所占用的内存。所以，只有手动消除 obj 对对象的强引用关系（obj = null），才能使对象占用的内存
被回收。同理，如果使用 Map，那么对象间是存在强引用关系的：
```

尽管最后消除了 obj 对对象的强引用关系，但由于 map 依然强引用着对象，所以这部分内存无法被释放。
WeakMap 与 Map 相对，它的键是弱引用的，如果一个对象只被弱引用所引用，则被认为是不可访问（或弱可访
问）的，垃圾回收机制会在适当的时机回收该对象所占用的内存。将上面的代码改成 WeakMap：

当执行 obj = null 后，就只剩下 wm 弱引用着对象，因此当下一次垃圾回收机制执行时，这块内存就会被释放掉。
上述代码只涉及到了一个简单的对象，因此两者使用起来对内存的影响差别不大，但如果对象非常大，使用 Map
就会对内存造成非常大的额外消耗，甚至可能引发内存泄漏，需要手动清除 Map 的属性才能释放这块内存，而
WeakMap 能有效解决该问题。

API：Map 提供了四个与遍历操作相关的方法 keys()、values()、entries()、forEach()，其实例具有一个属性 size
和五个操作方法 set()、get()、has()、delete()、clear() 。而对于 WeakMap，由于它的键是弱引用的，引用的对象
随时都可能被垃圾回收机制回收，即某个键是否存在完全不可确定，所以没有遍历方法，也不能确定大小（实例无
size 属性），其实例只有四个方法 set()、get()、has()、delete()。

应用场景：与对象一样，Map 用于存储键/值对：需要使用除数值、字符串、Symbol 以外的数据类型作为键；需
要存储非常多的键/值对；代码涉及大量插入、删除操作。

如果要对少量的键/值对进行查找操作，那么使用对象有时速度会更快。 当需要为某个 DOM 节点对象（或其它对
象）添加一些数据，并确保对象被删除后数据也随之消失，就可以使用 WeakMap，比如：

```
let obj = { name : 'x' }; // obj 强引用着对象 { name : 'x' }
const map = new Map();
map.set(obj, 'y'); // map 强引用着对象 { name : 'x' }
obj = null;
```

```
let obj = { name : 'x' }; // obj 强引用着对象 { name : 'x' }
const wm = new WeakMap();
wm.set(obj, 'y'); // wm 弱引用着对象 { name : 'x' }
obj = null;
```

```
const wm = new WeakMap();
const ele = document.getElementById('example'); // ele强引用着DOM节点
wm.set(ele, 'some information'); // wm 弱引用着DOM节点
wm.get(ele) // "some information"
... // 包含 ele 在内的其它对DOM节点的引用被消除后
wm.get(ele) // "undefined"
```

上述代码中，wm 保存着对 DOM 节点对象的弱引用，也就是说，其它位置对该对象的引用一旦消除，该对象占用
的内存就会自动被垃圾回收机制释放。WeakMap 保存的这个键/值对，也会自动消失，无需手动清除。

### 7 、用 CSS 和 JS 来实现动画分别有哪些优缺点？

#### 官方解析

##### 用 CSS 和 JS 来实现动画各有其优缺点，具体如下：

##### 使用 CSS 实现动画的优缺点：

##### 优点：

##### 硬件加速 ：CSS 动画会使用浏览器的 GPU 来进行硬件加速，能够更加流畅和高效地运行。

```
简单易用 ：CSS 动画通常只需要几行代码就能实现基本的动画效果，不需要使用 JavaScript 来控制动画。
低资源占用 ：CSS 动画通常比 JavaScript 动画使用更少的 CPU 和内存资源，因此更适合用于简单的动画效
果。
```

缺点：

```
限制较大 ：CSS 动画在实现复杂的动画效果时，受到限制较大，不能像 JavaScript 动画那样自由控制动画的
速度、方向等。
兼容性问题 ：由于不同浏览器对 CSS 动画支持程度不同，因此在实现时需要考虑浏览器兼容性问题。
可维护性差 ：当动画效果较为复杂时，使用 CSS 实现的代码会变得冗⻓和难以维护，因此需要进行代码优化
和结构设计。
```

使用 JavaScript 实现动画的优缺点：

优点：

```
自由控制 ：JavaScript 动画能够更加自由地控制动画的速度、方向等，可以实现更加复杂的动画效果。
兼容性好 ：由于 JavaScript 是浏览器通用的语言，因此在实现动画效果时，能够更好地兼容不同的浏览器。
可维护性强 ：使用 JavaScript 实现动画时，代码结构更加灵活，能够更好地维护和扩展。
```

缺点：

```
资源占用高 ：JavaScript 动画通常需要更多的 CPU 和内存资源，因此在实现动画效果时需要考虑系统资源的
消耗问题。
性能问题 ：JavaScript 动画性能受 JavaScript 引擎的影响，而不是浏览器引擎，因此需要对代码进行优化以提
高动画性能。
复杂度高 ：JavaScript 动画的实现复杂度通常比 CSS 动画高，因此需要对动画效果进行设计和规划。
```

### 8 、JS 中怎么阻止事件冒泡和事件默认行为？

#### 官方解析

在 JavaScript 中，可以通过以下方式阻止事件的冒泡和默认行为：

**阻止事件冒泡** ： 事件冒泡是指当一个子元素触发了某个事件后，事件会一直冒泡到它的父元素，直到到达文档根节
点。为了阻止事件冒泡，可以使用事件对象的 stopPropagation() 方法。例如：

##### 上面的代码中，当子元素被点击时，事件不会继续冒泡到父元素。

##### 阻止事件默认行为：

##### 事件的默认行为是指事件发生时，浏览器会默认执行的一些操作，例如提交表单、打开链接等。为了阻止事件的默

认行为，可以使用事件对象的 preventDefault() 方法。例如：

##### 上面的代码中，当链接被点击时，链接不会跳转到指定的地址。

##### 需要注意的是，阻止事件的冒泡和默认行为可能会影响用户体验，因此需要谨慎使用。在一些场景下，可以使用阻

##### 止事件传播的方式来实现事件委托、事件代理等功能。

#### ⻥友的精彩回答

**mos 的回答**

**阻止事件冒泡** ： 事件冒泡是指当一个子元素触发了某个事件后，事件会一直冒泡到它的父元素，直到到达文档根节
点。为了阻止事件冒泡，可以使用事件对象的 stopPropagation() 方法。

##### 阻止事件默认行为 ：

##### 事件的默认行为是指事件发生时，浏览器会默认执行的一些操作，例如提交表单、打开链接等。为了阻止事件的默

认行为，可以使用事件对象的 preventDefault() 方法。

```
document.getElementById("child").addEventListener("click", function(event) {
// 阻止事件冒泡
event.stopPropagation();
});
```

```
document.getElementById("link").addEventListener("click", function(event) {
// 阻止链接的默认跳转行为
event.preventDefault();
});
```

```
document.getElementById("child").addEventListener("click", function(event) {
// 阻止事件冒泡
event.stopPropagation();
//IE浏览器(IE11以下)
event.cancelBubble = true;
});
```

##### 但是请注意：

return false 不能适用于直接用 onclick 绑定的事件，所以当我们使用这种绑定事件方式时，我们还是需要采用
e.preventDefault()这个函数。

**注：在 jQuery 中使用 return false 时，相当于同时使用 event.preventDefault 和 event.stopPropagation，它
会阻止冒泡也会阻止默认行为。 但是使用原生 js 写时，return false 只会阻止默认行为。**

```
document.getElementById("link").addEventListener("click", function(event) {
// 阻止链接的默认跳转行为
event.preventDefault();
//IE8及以下
window.event.returnValue = false;
//无兼容问题（但不能用于节点直接onclick绑定函数）
return false;
});
```

```
<script>
var aDom = document.getElementById('test');
aDom.onclick = function ( e ){
if(e && e.preventDefault) {
//非IE浏览器
e.preventDefault();
} else {
//IE浏览器(IE11以下)
window.event.returnValue = false;
}
//return false; //或者不写上面的判断直接写这句
};
</script>
```

```
<body>
<div id="info">
<a href="www.baidu.com" onclick="defaultEvent()">阻止默认事件</a>
</div>
<script>
function defaultEvent(){
return false;
}
</script>
</body>
```

### 9 、什么是防抖和节流？如何用 JS 编码实现？

#### 官方解析

##### 防抖和节流都是一种优化技术，用来降低函数调用的频率，提高性能。

防抖（Debounce）：在连续触发某个事件时，只有当一定时间内没有再次触发事件，才会执行事件处理函数。比
如说，我们需要监听用户输入框中的文字，只有用户停止输入一段时间，才去发送请求获取数据。

节流（Throttle）：在一段时间内只执行一次函数，无论事件被触发多少次。比如说，当我们需要监听用户滚动⻚
面时，我们可以在用户滚动时，每隔一定时间就执行一次滚动事件。

下面是防抖和节流的实现代码：

防抖实现：

##### 节流实现：

其中 func 是需要进行防抖或节流处理的函数，delay 是事件执行的最小时间间隔。在防抖中，只有当事件触发后
delay 时间内没有再次触发事件，才会执行一次 func 函数；在节流中，每隔 delay 时间执行一次 func 函数。

需要注意的是，在实际使用时，防抖和节流的处理函数应该在需要进行防抖或节流的事件上进行绑定，而不是在函
数内部进行处理。

```
⻥皮的补充：这题可以补充一些防抖或节流在⻚面中的应用场景，会加分
```

```
function debounce(func, delay) {
let timer;
return function(...args) {
clearTimeout(timer);
timer = setTimeout(() => {
func.apply(this, args);
}, delay);
};
}
```

```
function throttle(func, delay) {
let timer;
return function(...args) {
if (!timer) {
timer = setTimeout(() => {
func.apply(this, args);
timer = null;
}, delay);
}
};
}
```

#### ⻥友的精彩回答

**mos 的回答**

防抖和节流都是一种优化技术，用来降低函数调用的频率，提高性能。

浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极
大地浪费资源，降低前端性能

防抖（Debounce）：在连续触发某个事件时，只有当一定时间内没有再次触发事件，才会执行事件处理函数。比
如说，我们需要监听用户输入框中的文字，只有用户停止输入一段时间，才去发送请求获取数据。

节流（Throttle）：在一段时间内只执行一次函数，无论事件被触发多少次。比如说，当我们需要监听用户滚动⻚
面时，我们可以在用户滚动时，每隔一定时间就执行一次滚动事件。

防抖 简单版本的实现

##### 防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：

```
function debounce(func, wait) {
let timeout;
```

```
return function () {
let context = this; // 保存this指向
let args = arguments; // 拿到event对象
```

```
clearTimeout(timeout) //进行清除，重新计时
timeout = setTimeout(function(){
func.apply(context, args)
}, wait);
}
}
```

```
function debounce(func, wait, immediate) {
```

```
let timeout;
```

```
return function () {
let context = this;
let args = arguments;
```

```
if (timeout) clearTimeout(timeout); // timeout 不为null
if (immediate) {
let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
timeout = setTimeout(function () {
timeout = null;
}, wait)// 一段时间后timeout设为null，又可以立即执行了
if (callNow) {
func.apply(context, args)
}
```

##### 节流：

##### 时间戳 在时间段内开始的时候立刻执行

##### 定时器

##### 第一次调用节流函数，还没有定时器，创建一个定时器，并在时间间隔结束时触发功能函数

##### 在时间间隔内再次调用节流函数，由于定时器已经存在，不响应

当时间间隔结束后将本定时器标识符 timeout 清除，再创建一个定时器。

由于定时器标识符 timeout 被设置为 null,再次调用节流函数便可再次触发。

##### }

```
else {
timeout = setTimeout(function () {
func.apply(context, args)
}, wait);
}
}
}
```

```
function throttle(func, wait) {
var previous = 0;
return function() {
let now = Date.now();
let context = this;
let args = arguments;
if (now - previous > wait) {
func.apply(context, args);
previous = now;
}
}
}
content.onmousemove = throttle(count,1000);
```

```
function throttle(func, wait) {
let timeout;
return function() {
let context = this;
let args = arguments;
if (!timeout) {
timeout = setTimeout(() => {
timeout = null;
func.apply(context, args)
}, wait)
}
}
}
```

**Kristen 的回答**

在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 、
mousewheel 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。

**防抖 (debounce)**

```
所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数
执行时间。 为什么要防抖 有的操作是高频触发的，但是其实触发一次就好了，比如我们短时间内多次缩放⻚
面，那么我们不应该每次缩放都去执行操作，应该只做一次就好。再比如说监听输入框的输入，不应该每次
都去触发监听，应该是用户完成一段输入后在进行触发。
```

总结：等用户高频事件完了，再进行事件操作。

**防抖怎么做**

设计思路：事件触发后开启一个定时器，如果事件在这个定时器限定的时间内再次触发，则清除定时器，在写一个
定时器，定时时间到则触发

**策略** ：当事件被触发时，设定一个周期延时执行动作，若周期又被触发，则重新设定周期，直到周期结束，执行动
作。 在后期有拓展了前缘防抖函数，即执行动作在前，设定延迟周期在后，周期内有事件被触发，不执行动作，且
周期重新设定。

节流 (throttling)
所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

在很多时候 我们不希望这些持续性触发事件触发频率太高

通过设定在一定时间周期内只能触发一次的方式进行节流

对于节流，有多种方式可以实现 时间戳 定时器 束流等。

策略： 固定周期内，只执行一次动作，若没有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。
特点： 连续高频触发事件时，动作会被定期执行，响应平滑

计时器版

```
var oInput = $('.input-box');
var oShow = $('.show-box');
var timeOut;
oInput.addEventListener('input', function () {
timeOut && clearTimeout(timeOut);
timeOut = setTimeout(function () {
oShow.innerText = translate(oInput.innerText);
}, 500);
}, false);
```

```
function translate(str) {
return str.split("").reverse().join("");
}
```

##### 时间戳版

##### 束流器版

```
var oCon = $('.container');
var num = 0;
var valid = true;
oCon.addEventListener('mousemove', function () {
if (!valid) {
return false;
}
valid = false;
setTimeout(function () {
count();
valid = true;
}, 500);
}, false);
```

```
function count() {
oCon.innerText = num++;
}
```

```
var oCon = $('.container');
var num = 0;
var time = Date.now();
oCon.addEventListener('mousemove', function () {
if (Date.now() - time < 600) {
return false;
}
time = Date.now();
count();
}, false);
```

```
function count() {
oCon.innerText = num++;
}
```

```
var oCon = $('.container');
var num = 0;
var time = 0;
oCon.addEventListener('mousemove', function () {
time++;
if (time % 30 !== 0) {
return false;
}
console.log(time)
count();
}, false);
```

##### 防抖和节流的区别

##### 防抖和节流相同点：

##### 防抖和节流都是为了阻止操作高频触发，从而浪费性能。降低回调执行频率,节省计算资源。

##### 防抖和节流区别：

##### 防抖是让你多次触发，只生效最后一次。适用于只需要一次触发生效的场景。

##### 节流是让你的操作，每隔一段时间触发一次。适用于多次触发要多次生效的场景。

##### 防抖是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段事件执行，函数防抖一定连续触发的事件，

##### 只在最后执行一次，而函数节流会每隔一定时间调用一次函数。

### 10 、前端有哪些实现跨⻚面通信的方法？

#### 官方解析

##### 前端有以下几种实现跨⻚面通信的方法：

1. Cookie：通过在⻚面间共享 Cookie 实现简单的跨⻚面通信，但是 Cookie 大小有限制，不能存储过多的数
   据。
2. localStorage 和 sessionStorage：HTML5 提供了本地存储的能力，可以通过 localStorage 或
   sessionStorage 实现⻚面间数据共享，相比 Cookie 更加方便，但是也有大小限制。
3. BroadcastChannel API：这是一个 HTML5 新增的 API，允许多个⻚面间通信，可以广播消息或向特定⻚面发
   送消息。
4. SharedWorker：SharedWorker 是一种特殊类型的 Web Worker，可以在多个⻚面间共享数据，可以通过
   postMessage API 实现消息传递。
5. postMessage API：这是 HTML5 提供的一种消息传递机制，可以在不同窗口或 iframe 间传递消息，可以用
   来实现跨域通信。
6. WebSocket：WebSocket 是一种持久化的协议，可以在浏览器和服务器之间实现双向通信，也可以在不同⻚
   面之间实现通信。

以上这些方法都有其适用的场景和限制条件，需要根据具体情况进行选择和使用。

#### ⻥友的精彩回答

```
function count() {
oCon.innerText = num++;
}
```

**codexgh 的回答**

当我们在浏览器中打开很多⻚面的时，如果我们对一个⻚面上的数据进行了修改操作，而跟这个数据相关的其它⻚
面也能够实时的修改⻚面上的数据，这个就是跨⻚面通信。跨⻚面通信可分为同源和非同源：

**同源⻚面之间通信** ：

BroadCast Channel: BroadCast Channel 官方定义为该 API 适用于同源不同⻚面之间完成通信的功能。BroadCast
Channel 可以帮助我们创建一个用于广播的通信频道，当所有⻚面都监听同一频道时，其中某一个⻚面通过他发送
消息就会被其它⻚面接收到：

ServiceWorker： ServiceWorker 是一个可以⻓期运行在后台的 worker，能够实现与⻚面之间的双向通信。多⻚面
的 serviceWorker 可以共享，将 serviceWorker 作为消息处理中心，即可实现广播效果；service worker 跟
BoardCast Channel 相似之处在于两者都是使用了广播的方式完成跨⻚面通信；而 service worker 不同的点在于，
它本身不具备广播通信的功能，我们需要再配置 service worker ，将其改造成消息中转站；

localStorage: 当 localStorage 发生变化时，会触发 storage 事件，利用这个特性，我们在发送消息的时候，把信息
写入 localStorage 中，然后在各个⻚面中，我们监听 storage 事件即可完成跨⻚面通信；当某个⻚面需要发送消息的
时候，只需要使用 setItem 方法即可。

window.open+window.opener: 当我们使用 window.open 打开一个⻚面时，我们会建立起一个树形结构，当我们
需要发送消息时，作为消息的发起方，一个⻚面需要同时通知它打开的⻚面和打开它的⻚面；被打开的⻚面，可以
通过 window.opener 来获取打开他的⻚面的引用；这样每一个⻚面节点都肩负起来了传递消息额的责任；但是这种
方式存在一个问题：如果⻚面不是通过另一个⻚面的 window.open 打开的，例如直接在地址栏输入，或从其他网站
链接过来，这个树状结构就不可行了；

**非同源⻚面之间通信** ：

iframe+postMessage()： 要实现非同源跨⻚面通信，我们可以使用一个用户不可⻅的 iframe 作为“桥”，由于
iframe 与父⻚面间可以通过 postMessage()忽略同源限制，因此可以在每个⻚面嵌入一个 iframe，而这些 iframe 由
于是使用的同一个 url，因此是属于同源⻚面，就可以使用同源⻚面通信的方法了。

##### // 创建

```
const a = new BroadcastChannel(temp);
```

```
// 发送消息
a.postMessage("hello")
```

```
// 关闭
a.close()
```

```
// 监听
a.onmessage = function(e){
console.log("监听到了：", e)
}
```

##### // 错误监听

```
a.onmessageerror = function(err){
console.log("error", err)
}
```

**mos 的回答**

1. Cookie：通过在⻚面间共享 Cookie 实现简单的跨⻚面通信，但是，Cookie 有一个缺点就是它的存储容量有
   限，一般只能存储 4KB 左右的数据。
2. localStorage 和 sessionStorage：HTML5 提供了本地存储的能力，可以通过 localStorage 或
   sessionStorage 实现⻚面间数据共享，相比 Cookie 更加方便，但是也有大小限制。
3. BroadcastChannel API：这是一个 HTML5 新增的 API，允许多个⻚面间通信，可以广播消息或向特定⻚面发
   送消息。
4. SharedWorker：SharedWorker 是一种特殊类型的 Web Worker，可以在多个⻚面间共享数据，可以通过
   postMessage API 实现消息传递。是一种浏览器多线程的实现方式。在多个⻚面之间共享一个共同的 Worker
   线程，从而实现跨⻚面通信。但是 Shared Worker 的兼容性较差，只有一些现代浏览器支持。
5. postMessage API：这是 HTML5 提供的一种消息传递机制，可以在不同窗口或 iframe 间传递消息，可以用
   来实现跨域通信。

##### 要在接收端接收消息，可以将以下代码添加到接收窗口的脚本中：

我们通过添加一个事件侦听器来监听接收消息。event 对象包含 event.data 属性，它包含发送方发送的实际消息内
容。接收方可以通过验证 event.origin 属性，以确保消息来自预期的源，从而确保安全性。 6. WebSocket：
WebSocket 是一种持久化的协议，可以在浏览器和服务器之间实现双向通信，也可以在不同⻚面之间实现通信。
并且数据传输速度较快.

### 11 、什么是虚拟 DOM？使用虚拟 DOM 一定更快吗？

#### 官方解析

虚拟 DOM（Virtual DOM）是一种将浏览器 DOM 抽象为 JavaScript 对象的技术，用于提高 DOM 操作的效率和性
能。虚拟 DOM 可以在渲染前对组件的变化进行计算，减少 DOM 操作的次数，从而提高渲染性能。

使用虚拟 DOM 可以提高性能，但并不是一定更快。虚拟 DOM 需要进行额外的计算和比较操作，而这些操作也会
消耗一定的时间和性能。因此，虚拟 DOM 适用于大规模、高度动态的⻚面，而在简单的静态⻚面中使用虚拟
DOM 并不能提高性能。此外，虚拟 DOM 还可以提高开发效率，使代码更易于维护和调试。

```
const targetWindow = window.open('http://example.com/');
targetWindow.postMessage('Hello, target window!', 'http://example.com/');
```

```
window.addEventListener('message', function(event) {
if (event.origin !== 'http://example.com/') { return; }
console.log(event.data);
});
```

#### ⻥友的精彩回答

**codexgh 的回答**

虚拟 DOM 是一个 js 对象，一个什么样的对象呢？一个用来表示真是 DOM 的对象，要记住这句话，举个例子，请看
一下真实 DOM：

##### 对应的虚拟 DOM 为：

这个时候，修改一个 li 标签的文本：

##### 这个时候生成的新虚拟 DOM 为：

```
<ul id="list">
<li class="item">哈哈</li>
<li class="item">嘿嘿</li>
<li class="item">呵呵</li>
</ul>
```

```
let oldVDOM = { // 旧虚拟DOM
tagName: 'ul', // 标签名
props: { // 标签属性
id: 'list'
},
children: [ // 标签子节点
{
tagName: 'li', props: { class: 'item' }, children: [ '哈哈' ]
},
{
tagName: 'li', props: { class: 'item' }, children: [ '嘿嘿' ]
},
{
tagName: 'li', props: { class: 'item' }, children: [ '呵呵' ]
},
]
}
```

```
<ul id="list">
<li class="item">哈哈</li>
<li class="item">嘿嘿</li>
<li class="item">快来学习Diff算法了，呵呵</li>
</ul>
```

```
let newVDOM = { // 新虚拟DOM
tagName: 'ul', // 标签名
props: { // 标签属性
id: 'list'
},
```

##### 这就是我们平常说的新旧两个虚拟 DOM，这个时候的新虚拟 DOM 是数据的最新状态，那么我们直接拿新虚拟 DOM

##### 去渲染成真实 DOM 的话，效率真的要比直接操作真实 DOM 高吗？那肯定是不会的，如图所示：

##### 从图中一看便知，肯定是第 2 种方式比较快，因为第 1 种方式中间还夹着一个虚拟 DOM 的步骤，所以虚拟 DOM 比真

##### 实 DOM 快 这句话是错的，或者说不严谨。正确的说法应该是：虚拟 DOM 算法操作真实 DOM，性能高于直接操作

DOM，虚拟 DOM 和虚拟 DOM 算法是两种概念。虚拟 DOM 算法 = 虚拟 DOM + Diff 算法

**Kristen 的回答**

因为操作 DOM 会引起⻚面的回流或者重绘，而这两个东⻄是非常耗费性能的。因此我们越少操作真实 dom 就越
好。相比起来，通过多一些预先计算来减少 DOM 的操作要划算的多。

虚拟 DOM 是通过 JS 对象模拟出来的 DOM 节点,domDiff 是通过特定算法计算出来一次操作所带来的 DOM 变化。减少
DOM 操作的次数，从而提高渲染性能。可以提高开发效率

但是，“使用虚拟 DOM 会更快”这句话并不一定适用于所有场景。例如：一个⻚面就有一个按钮，点击一下，数字加
一，那肯定是直接操作 DOM 更快。虚拟 DOM 需要进行额外的计算和比较操作，而这些操作也会消耗一定的时间
和性能。即使是复杂情况，浏览器也会对我们的 DOM 操作进行优化，大部分浏览器会根据我们操作的时间和次数
进行批量处理，所以直接操作 DOM 也未必很慢。

```
children: [ // 标签子节点
{
tagName: 'li', props: { class: 'item' }, children: [ '哈哈' ]
},
{
tagName: 'li', props: { class: 'item' }, children: [ '嘿嘿' ]
},
{
tagName: 'li', props: { class: 'item' }, children: [ '快来学习Diff算法了，呵呵' ]
},
]
}
```

**mos 的回答**

**一、什么是虚拟 DOM**

实际上它只是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节
点，最终可以通过一系列操作使这棵树映射到真实环境上

在 Javascript 对象中，虚拟 DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象
(children) 三个属性，不同框架对这三个属性的名命可能会有差别

创建虚拟 DOM 就是为了更好将虚拟的节点渲染到⻚面视图中，所以虚拟 DOM 对象的节点与真实 DOM 的属性一一照
应

vue 中虚拟 DOM 技术
定义真实 DOM

实例化 vue

观察 render，得到虚拟 DOM

通过 VNode，vue 可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过 diff 算法得出一些需要修改
的最小单位,再更新视图，减少了 dom 操作，提高了性能

**二、使用虚拟 DOM 的原因**

DOM 是很慢的，其元素非常庞大，⻚面的性能问题，大部分都是由 DOM 操作引起的

真实的 DOM 节点，哪怕一个最简单的 div 也包含着很多属性，可以打印出来直观感受一下：

```
<div id="app">
<p class="p">节点内容</p>
<h3>{{ foo }}</h3>
</div>
```

```
const app = new Vue({
el:"#app",
data:{
foo:"foo"
}
})
```

```
(function anonymous(
) {
with(this){return _c('div',{attrs:{"id":"app"}},[_c('p',{staticClass:"p"},
[_v("节点内容")]),_v(" "),_c('h3',[_v(_s(foo))])])}})
```

##### 由此可⻅，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现⻚面卡顿，影响用户的体验

##### 举个例子：

你用传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程

当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还
有 9 次更新操作，因此会⻢上执行流程，最终执行 10 次流程

而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地
的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算

很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚
拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能
力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种
GUI

三、如何实现虚拟 DOM 首先可以看看 vue 中 VNode 的结构

源码位置：src/core/vdom/vnode.js

```
export default class VNode {
tag: string | void;
data: VNodeData | void;
children: ?Array<VNode>;
text: string | void;
elm: Node | void;
ns: string | void;
context: Component | void; // rendered in this component's scope
functionalContext: Component | void; // only for functional component root nodes
key: string | number | void;
componentOptions: VNodeComponentOptions | void;
componentInstance: Component | void; // component instance
parent: VNode | void; // component placeholder node
raw: boolean; // contains raw HTML? (server only)
isStatic: boolean; // hoisted static node
isRootInsert: boolean; // necessary for enter transition check
isComment: boolean; // empty comment placeholder?
isCloned: boolean; // is a cloned node?
isOnce: boolean; // is a v-once node?
```

```
constructor (
```

tag?: string,
data?: VNodeData,
children?: ?Array<VNode>,
text?: string,
elm?: Node,
context?: Component,
componentOptions?: VNodeComponentOptions
) {
/_当前节点的标签名_/
this.tag = tag
/_当前节点对应的对象，包含了具体的一些数据信息，是一个 VNodeData 类型，可以参考 VNodeData 类型中的数
据信息_/
this.data = data
/_当前节点的子节点，是一个数组_/
this.children = children
/_当前节点的文本_/
this.text = text
/_当前虚拟节点对应的真实 dom 节点_/
this.elm = elm
/_当前节点的名字空间_/
this.ns = undefined
/_编译作用域_/
this.context = context
/_函数化组件作用域_/
this.functionalContext = undefined
/_节点的 key 属性，被当作节点的标志，用以优化_/
this.key = data && data.key
/_组件的 option 选项_/
this.componentOptions = componentOptions
/_当前节点对应的组件的实例_/
this.componentInstance = undefined
/_当前节点的父节点_/
this.parent = undefined
/_简而言之就是是否为原生 HTML 或只是普通文本，innerHTML 的时候为 true，textContent 的时候为 false_/
this.raw = false
/_静态节点标志_/
this.isStatic = false
/_是否作为跟节点插入_/
this.isRootInsert = true
/_是否为注释节点_/
this.isComment = false
/_是否为克隆节点_/
this.isCloned = false
/_是否有 v-once 指令_/
this.isOnce = false
}

// DEPRECATED: alias for componentInstance for backwards compat.
/_ istanbul ignore next https://github.com/answershuto/learnVue_/

这里对 VNode 进行稍微的说明：

所有对象的 context 选项都指向了 Vue 实例 elm 属性则指向了其相对应的真实 DOM 节点 vue 是通过
createElement 生成 VNode

**小结**

createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成
了一个虚拟树结构，用于描述真实的 DOM 树结构.

```
使用虚拟 DOM 可以提高性能，但并不是一定更快。虚拟 DOM 需要进行额外的计算和比较操作，而这些操
作也会消耗一定的时间和性能。因此，虚拟 DOM 适用于大规模、高度动态的⻚面，而在简单的静态⻚面中
使用虚拟 DOM 并不能提高性能。此外，虚拟 DOM 还可以提高开发效率，使代码更易于维护和调试。
```

### 12 、JS 脚本延迟加载的方式有哪些？

#### 官方解析

##### JS 脚本的延迟加载主要有以下几种方式：

1. defer 属性：在 HTML 中通过设置 script 标签的 defer 属性来实现脚本的延迟加载，即脚本的下载与 HTML
   的解析不会阻塞彼此，脚本会在 HTML 解析完成后才执行。
2. async 属性：在 HTML 中通过设置 script 标签的 async 属性来实现脚本的异步加载，即脚本的下载与 HTML
   的解析不会阻塞彼此，脚本下载完成后会立即执行，但脚本执行时可能会阻塞 HTML 解析。
3. 动态加载脚本：通过 JavaScript 动态创建 script 标签，并设置其 src 属性来实现脚本的异步加载，这种方式
   需要在脚本加载完成后手动执行脚本。
4. 懒加载模式：在需要时再加载脚本，可以使用 jQuery 等库实现，或者通过自己编写的函数来实现。

这些方式都可以在一定程度上优化⻚面加载性能，具体选择哪种方式要根据实际场景进行选择。

```
⻥皮评论：这题可以再补充回答：什么时候适合使用延迟加载？
```

#### ⻥友的精彩回答

**玄德 ь 的回答**

JS 脚本的延迟加载主要有以下几种方式：

async 属性：该属性可以使脚本异步加载，即在⻚面加载过程中不会阻塞⻚面的渲染和其他资源的加载。但是，异
步执行的脚本不能保证执行顺序。

```
get child (): Component | void {
return this.componentInstance
}
}
```

```
<script src="test.js" async></script>
```

defer 属性：该属性也可以使脚本异步加载，但是会在 DOMContentLoaded 事件之前执行，也就是在⻚面加载完
成之后执行，可以保证脚本之间的执行顺序。

动态添加 script 标签：可以在⻚面加载完成后，通过 JavaScript 动态添加 script 标签，实现延迟加载。

使用 Intersectionobserver API：可以在元素进入视窗时再加载脚本，实现延迟加载。

setTimeout 也可以实现延迟加载，但它并不是一种专⻔用来实现脚本延迟加载的方式，它更适用于实现定时任务，
原理和 Intersectionobserver API 相似，并不推荐定时器实现延迟加载。

setTimeout 的时间不能准确控制，如果时间设置过⻓，会延迟⻚面的加载速度；如果时间设置过短，可能会在⻚
面还没有完全加载完成时执行脚本，导致错误。

无法保证脚本的执行顺序，如果多个脚本使用 setTimeout 加载，可能会导致执行顺序混乱。

注意：async 和 defer 属性只适用于外部脚本，不适用于内联脚本。

##### 你还费解吗的回答

##### 所谓延迟加载，就是等⻚面加载完毕后再加载 JS 脚本文件，这样做能提高⻚面的加载速度，使内容更快地呈现在

##### 屏幕上。实现延迟加载的方式主要有以下几种：

```
<script src="test.js" defer></script>
```

```
var script = document.createElement('script');
script.src = 'test.js';
document.body.appendChild(script);
```

```
var observer = new IntersectionObserver(function (entries) {
if (entries[0].isIntersecting) {
var script = document.createElement('script');
script.src = 'test.js';
document.body.appendChild(script);
}
}, { threshold: 0.5 });
var target = document.querySelector('#target');
observer.observe(target);
```

```
setTimeout(function() {
var script = document.createElement('script');
script.src = 'example.js';
document.body.appendChild(script);
}, 2000);
```

defer 属性：defer 是 <script> 的一个属性，能将脚本延迟到整个⻚面都解析完毕后再运行，具体来说，当浏览器
遇到带有 defer 属性的 <script> 时，不会像遇到普通的 <script> 那样暂停解析下面的 HTML，而是异步发送网络
请求下载脚本文件（如果是外部的），等脚本下载完毕后，如果 HTML 已经解析完毕，则立即执行，否则等到
HTML 解析完毕后再执行 JS 代码，所以在整个过程中对 HTML 的解析完全不会被阻断。

另外，HTML5 规范规定，如果存在多个推迟执行的脚本，则它们会按照定义的顺序依次执行，且两者都会在
DOMContentLoaded 事件前执行。如下代码所示，脚本 1 会在脚本 2 前执行：

##### 然而，并不是所有浏览器都严格遵守规范，所以推迟执行的脚本不一定总会按顺序执行或者在

DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。

```
注意：在 IE7 及更早的版本中，对行内脚本也可以指定该属性。而在 IE8 及更高版本中，defer 只对外部脚本
有效。
```

async 属性：async 也是 <script> 的一个属性，表示异步，具体来说，当浏览器遇到带有 async 属性的 <script>
时，与 defer 一样，也会异步发送网络请求下载脚本文件，但在脚本下载完成后，如果 HTML 还未被解析完，浏览
器就会暂停解析，转而去执行 JS 代码，执行完毕后再恢复解析，否则立即执行 JS 代码。所以，异步加载的脚本可
能会阻断 HTML 的解析。

当存在多个异步执行的脚本时，由于各个脚本会受到文件大小、网速、执行时间的影响，所以它们的执行顺序是不
可确定的。如上述代码所示，脚本 3 可能会在脚本 4 前执行，也有可能反过来。尽管不能确保执行顺序，但异步脚
本一定会在⻚面的 load 事件前执行，可能会在 DOMContenterLoaded 事件之前或之后执行。

```
注意：async 只对外部脚本有效。另外，如果同时对一个<script>设置了 async 和 defer，则只有 async 生
效。
```

作为 <script> 的属性，async 和 defer 的应用场景区分如下：

```
如果脚本无需等待⻚面解析，且无依赖于其它脚本文件，可以独立运行，那么应使用 async。也就是每一个
async 属性的脚本都在它下载结束之后立即执行，同时会在window的 load 事件之前执行。
如果脚本需要等待⻚面解析（可能涉及到操作 DOM），且多个脚本之间互相依赖，那么这些脚本应使用
defer，将关联的脚本按所需顺序置于 HTML 中。
```

```
<!DOCTYPE html>
<html lang="en">
<head>
<title>Example</title>
<script defer src="script1.js"></script> <!-- 脚本1 -->
<script defer src="script2.js"></script> <!-- 脚本2 -->
```

```
<script async src="script3.js"></script> <!-- 脚本3 -->
<script async src="script4.js"></script> <!-- 脚本4 -->
</head>
<body>
<!--这里是⻚面内容-->
</body>
</html>
```

让 JS 最后加载：将 <script> 放在⻚面内容的底部（即</body>前），也就是让浏览器从上到下解析完 HTML 后再
加载 JS 脚本文件，从而起到延迟加载的作用。该方法类似于 defer，不同的是 defer 会提前把脚本文件下载好，等
到 HTML 解析完就可以立即执行了，而此方法不能提前加载文件，只能等到 HTML 解析完后才能开始加载和执
行。如果需要考虑浏览器的兼容性，还是把要推迟执行的脚本放在⻚面底部比较好。

动态创建 DOM：

对⻚面的加载事件进行监听，在⻚面加载完之后再通过操作 DOM API 动态创建一个 script 元素，并将它的 src 属
性设置为要加载的外部脚本，最后再将 script 元素添加到 DOM 即可。

对于上述代码，在执行 downloadJSAtOnload ，将元素添加到 DOM 之前都不会加载外部脚本文件。

setTimeout ：设置一个定时器来延迟加载 JS 脚本文件。

### 13 、什么是点击穿透，怎么解决？

#### 官方解析

##### 点击穿透是指在某些场景下，用户在快速点击⻚面元素时，由于某些原因（例如网络延迟），在前一个元素上的点

##### 击事件还没有完成时，下一个元素的点击事件就已经触发了，导致用户感觉到⻚面点击无效或者出现异常。

##### 解决点击穿透的方法有以下几种：

1. 使用 debounce 或 throttle 函数。这两种函数可以控制函数的执行频率，减少短时间内函数的执行次数，从
   而减少点击穿透的可能性。
2. 使用 CSS pointer-events 属性。将当前元素的 pointer-events 属性设为 none，可以禁用当前元素的鼠标事
   件，从而避免在事件处理函数执行过程中发生点击穿透。
3. 使用 touch 事件代替 click 事件。在移动设备上，click 事件有 300ms 的延迟，可能会导致点击穿透。使用
   touchstart、touchend 等 touch 事件可以避免这个问题。
4. 在 click 事件中使用 preventDefault 函数。在 click 事件的处理函数中调用 preventDefault 函数，可以阻止
   默认的事件行为，从而避免点击穿透。但是这种方法有可能会影响到一些用户习惯，因此需要慎用。

```
<!-- 这段代码应放置在 </body> 标签前 -->
<script type="text/javascript">
function downloadJSAtOnload() {
var script = document.createElement("script"); // 创建一个 script 元素
script.src = "defer.js"; // 设置要延迟加载的脚本
document.body.appendChild(script); // 将元素添加到 body，而不是 head，添加到 head 就不能
起到延迟加载的作用了
}
// 兼容性处理
if (window.addEventListener) // 添加监听事件
window.addEventListener("load", downloadJSAtOnload, false); // 事件在冒泡阶段执行
else if (window.attachEvent)
window.attachEvent("onload",downloadJSAtOnload);
else
window.onload = downloadJSAtOnload;
</script>
```

#### ⻥友的精彩回答

**Kristen 的回答**

点击穿透:设置 B 盒子在 A 盒子的前面,给 B 盒子绑定 touchstart 事件,给 A 盒子设置 click 事件.点击 B 盒子触发 touchstart
事件(使 B 盒子,overflow:hidden),同时也会触发 A 盒子的 click 事件,导致用户感觉到⻚面点击无效或者出现异常。这个
就是点击穿透.(主要是 click 事件不是立⻢ 执行，而是有 300ms 的延迟)

2.点击穿透的解决办法 第一种解决办法:使用 touch 事件代替 click 事件。

##### 目前我只找到了这一种方法有用

### 14 、什么是 JS 对象的可枚举性（enumerable）？

#### 官方解析

JS 对象的可枚举性指的是对象的某些属性是否可以被 for...in 循环枚举到。每个对象属性都有一个可枚举性标识，
这个标识决定了这个属性是否可以被枚举。在对象属性创建时，可以通过 Object.defineProperty() 方法的
enumerable 属性来设置这个属性是否可枚举，默认为 true。

有些内置对象的属性是不可枚举的，例如 Object.prototype 上的属性，这些属性可以通过
Object.getOwnPropertyNames() 方法获取。

```
<body>
<div id="b">B</div>
<div id="a">A</div>
<script>
var b = document.getElementById("b")
var a = document.getElementById("a")
b.ontouchstart = function() {
this.style.display = 'none'
console.log("点击了B")
}
a.onclick = function() {
console.log("点击了A")
}
</script>
</body>
```

```
//给下面的A盒子同样设置一个touchstart事件
a.ontouchstart = function() {
console.log("点击了A")
}
```

在 ES6 中，引入了 Object.keys()、Object.values() 和 Object.entries() 方法来获取对象可枚举属性的键、值和键值
对。同时，也提供了 Reflect.enumerate() 方法来获取对象的所有属性（包括不可枚举属性），但该方法已经被废
弃。

```
⻥皮补充：这里题解表达的不清晰，如果你用了 defineProperty，没传参数就相当于设置为 false。这些属
性默认为 true
```

#### ⻥友的精彩回答

**luckythus 的回答**

什么是 JS 对象的可枚举性
对象的可枚举型是指：

对象中某些属性是否可以被 for...in 循环或者 Object.keys()函数枚举到，如果一个属性是可枚举的，则会出现在枚
举过程中，反之则不会。

每个属性都有一个名字和一个属性描述符，属性描述符里面包括了该属性的许多特性，如可枚举性、可写性、可配
置性和值等。

默认情况下，使用字面量或 Object()构造函数创建的对象的所有属性都是可枚举的，可以使用
Object.defineProperty 或 Object.defineProperties()来设置 enumerable 特性为 false，设置其不可枚举

tip：

Object.keys()作用：用于返回一个 给定对象其自身可枚举的属性 的数组，该方法接收一个对象作为参数 **，返回该
对象中所有可枚举属性的名称组成的一个数组** ，该数组中的的属性名称按照对象属性定义顺序一致，如果该对象里
面的属性没有一个是可枚举性的，则返回空数组。

Object.defineProperty()作用：用来定义一个新的属性或者修改原有的属性

Object.defineProperties()作用：用来定义或修改多个属性

这两种都是可以自定义属性的行为，例如定义或修改属性是否可写、可枚举、可配置等；

它们接收三个参数： 1 、obj 对象； 2 、prop：要定义或修改的属性名称； 3 、descriptor：要定义或修改的属性描述
符

descriptor 的属性描述符包括的特性有：

1. value：属性的值，默认为 undefined
2. writable：属性是否可写，默认为 false
3. enumerable：属性是否可枚举，默认为 false
4. configurable：属性是否可配置，默认为 false
5. get：获取属性值的方法
6. set：设置属性值的方法

**Kristen 的回答**

可枚举性（enumerable）用来控制所描述的属性，是否将被包括在 for...in 循环之中。每个对象属性都有一个可枚
举性标识，这个标识决定了这个属性是否可以被枚举。具体来说，如果一个属性的 enumerable 为 false，下面三
个操作不会取到该属性。

1. for...in 循环
2. Object.keys 方法
3. JSON.stringify 方法

可枚举属性是指那些内部 “可枚举” 标志设置为 true 的属性。对于通过直接的赋值和属性初始化的属性，该标识值
默认为 true。但是对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。

上面代码中，d 属性的 enumerable 为 false，所以一般的遍历操作都无法获取该属性，但还是可以直接获取它的
值。

至于 for...in 循环和 Object.keys 方法的区别，在于前者包括对象继承自原型对象的属性，而后者只包括对象本身
的属性。如果需要获取对象自身的所有属性，不管 enumerable 的值，可以使用 Object.getOwnPropertyNames
方法。

### 15 、JS 如何顺序执行 10 个异步任务？

#### 官方解析

JS 中可以使用 Promise 和 async/await 来顺序执行异步任务。

使用 Promise 可以通过 then() 方法的链式调用来实现顺序执行异步任务，例如：

```
var o = { a: 1, b: 2 }
```

```
o.c = 3
Object.defineProperty(o, 'd', {
value: 4,
enumerable: false,
})
```

```
o.d //4
```

```
for (var key in o) console.log(o[key])
// 1 2 3
```

```
Object.keys(o) //['a','b','c']
```

```
JSON.stringify(o) //"{a:1,b:2,c:3}"
```

```
function asyncTask1() {
return new Promise(resolve => {
setTimeout(() => {
```

使用 async/await 可以将异步任务看作同步代码来执行，例如：

在这里，runAsyncTasks() 函数会先执行异步任务 1 ，等待异步任务 1 完成后再执行异步任务 2 。

#### ⻥友的精彩回答

**mos 的回答**

**Promise 的方式**

```
console.log('Async task 1');
resolve();
}, 1000);
});
}
```

```
function asyncTask2() {
return new Promise(resolve => {
setTimeout(() => {
console.log('Async task 2');
resolve();
}, 2000);
});
}
```

```
// 顺序执行异步任务
asyncTask1().then(() => {
return asyncTask2();
}).then(() => {
// 执行完异步任务 1 和异步任务 2 后的逻辑
});
```

```
async function runAsyncTasks() {
await asyncTask1();
await asyncTask2();
// 执行完异步任务 1 和异步任务 2 后的逻辑
}
```

```
runAsyncTasks();
```

```
ction fn1() {
return new Promise((resolve, reject) => {
console.log('fn1执行')
setTimeout(() => {
console.log('fn1结束')
resolve('fn1传递过去的参数')
}, 1000)
})
```

##### 执行结果如下：

##### 生成器的方式

##### 生成器就是能返回一个迭代器的函数，它也是一个函数，对比普通的函数，多了一个\*，在它的函数体内可以使用

yield 关键字,函数会在每个 yield 后暂停，等待，直到这个生成的对象，调用下一个 next(),每调用一次 next 会往下执
行一次 yieId，然后暂停。

##### }

```
function fn2(data) {
return new Promise((resolve, reject) => {
console.log('fn2执行，接收的参数', data)
setTimeout(() => {
resolve('fn2传递过去的参数')
}, 1000)
})
}
```

```
function fn3(data) {
return new Promise((resolve, reject) => {
console.log('fn3执行，接收的参数', data)
setTimeout(() => {
resolve('fn3传递过去的参数')
}, 1000)
})
}
```

```
fn1().then(fn2).then(fn3).then(res => {
console.log('最后一个', res)
})
```

##### 执行结果如下：

```
function* main() {
const res1 = yield fn1('开始')
const res2 = yield fn2(res1)
const res3 = yield fn3(res2)
console.log(res3, '全部执行完毕')
}
```

```
const task = main()
task.next()
```

```
function fn1(data) {
setTimeout(() => {
console.log('fn1执行', data)
task.next('fn1执行完毕')
}, 1000)
}
```

```
function fn2(data) {
setTimeout(() => {
console.log('fn2执行', data)
task.next('fn2执行完毕')
}, 1000)
}
```

```
function fn3(data) {
setTimeout(() => {
console.log('fn3执行', data)
task.next('fn3执行完毕')
}, 1000)
}
```

```
console.log('我是最开始同步执行的')
```

async/await

使用 async/await 可以将异步任务看作同步代码来执行，例如：

在这里，runAsyncTasks() 函数会先执行异步任务 1 ，等待异步任务 1 完成后再执行异步任务 2 。

### 16 、介绍一下 JS 中 setTimeout 的运行机制？

#### 官方解析

在 JavaScript 中，setTimeout() 方法被用于在指定的时间间隔后执行一个指定的代码块。它接受两个参数：第一个
参数是需要执行的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。setTimeout() 方法执行完毕后，代
码块将被推入 JavaScript 的执行队列中，等待 JavaScript 引擎在一段时间后执行。

setTimeout() 方法具有异步的特性，因此即使 setTimeout() 方法指定了一个很短的时间，它也不会在调用代码之
后立即执行。相反，它会将代码块放在事件队列的末尾，直到事件队列中没有任何待处理的任务，才会执行。因
此，当代码块执行时，当前执行的上下文（也称为堆栈）已经被清空。

如果 setTimeout() 方法在代码块执行之前被清除或者代码块执行时间过⻓，那么代码块将会在 JavaScript 引擎空
闲时尽快被执行。因此，setTimeout() 方法不是一个精确的时间控制器，而是一个粗略的时间控制器。如果需要更
精确的时间控制器，可以考虑使用 requestAnimationFrame() 或 Web Workers。

```
async function runAsyncTasks() {
await asyncTask1();
await asyncTask2();
// 执行完异步任务 1 和异步任务 2 后的逻辑
}
```

```
runAsyncTasks();
```

#### ⻥友的精彩回答

**Kristen 的回答**

setTimeout()函数：用来指定某个函数或某段代码在多少毫秒之后执行。它接受两个参数：第一个参数是需要执行
的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。它返回一个整数，表示定时器 timer 的编号，可以
用来取消该定时器。是一个异步函数。

最后的打印顺序是：1 3 2 无论 setTimeout 的执行时间是 0 还是 1000 ，结果都是先输出 3 后输出 2 。

**任务队列**

一个先进先出的队列，它里面存放着各种事件和任务。 所有任务可以分成两种，一种是同步任务，另一种是异步任
务。

**同步任务**

在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

1. 输出 如：console.log()
2. 变量的声明
3. 同步函数：如果在函数返回的时候，调用者就能够拿到预期的返回值或者看到预期的效果，那么这个函数就是
   同步的。

**异步任务**

1. setTimeout 和 setInterval
2. DOM 事件
3. Promise
4. process.nextTick
5. fs.readFile
6. http.get
7. 异步函数：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那
   么这个函数就是异步的。

**优先关系**

异步任务要挂起，先执行同步任务，同步任务执行完毕才会响应异步任务。

**JS 执行机制**

由于 JS 是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能
开始执行。 为了避免因为某些⻓时间任务造成的无意义等待，JS 引入了异步的概念，用另一个线程来管理异步任
务。

```
console.log(1);
setTimeout(function () {
console.log(2);
}, 0);
console.log(3);
```

##### 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程; 等到主线程队列空

##### 了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等

一些条件才能执行，如 ajax 请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环;

定时器也是一种异步任务，通常浏览器都有一个独立的定时器模块，定时器的延迟时间就由定时器模块来管理，当
某个定时器到了可执行状态，就会被加入主线程队列。

setTimeout 注册的函数 fn 会交给浏览器的定时器模块来管理，延迟时间到了就将 fn 加入主进程执行队列，如果
队列前面还有没有执行完的代码，则又需要花一点时间等待才能执行到 fn，所以实际的延迟时间会比设置的⻓; 如
在 fn 之前正好有一个超级大循环，那延迟时间就不是一丁点了。

setInterval 的实现机制跟 setTimeout 类似，只不过 setInterval 是重复执行的。 对于 setInterval(fn, 100) 容易产
生一个误区： 并不是上一次 fn 执行完了之后再过 100ms 才开始执行下一次 fn。 事实上，setInterval 并不管上一
次 fn 的执行结果，而是每隔 100ms 就将 fn 放入主线程队列; 而两次 fn 之间具体间隔多久就不一定了，跟
setTimeout 实际延迟时间类似，和 JS 执行情况有关。

```
⻥皮评论：很棒的回答 "
OYAMA：从函数到同步异步到执行机制，很全面啊
```

### 17 、怎么用 JS 实现大型文件上传？要考虑哪些问题？

#### 官方解析

##### 在前端实现大型文件上传，需要考虑以下几个问题：

##### 分片上传：将大文件切割成多个小块进行上传，可以避免一次性上传大文件导致的上传时间过⻓，网络中断等问

##### 题。通常情况下，每个块大小为 1MB 左右。

##### 断点续传：由于网络等因素，上传过程中可能出现中断，此时需要能够从中断的地方恢复上传。

##### 并发上传：多个文件同时上传，需要对上传队列进行管理，保证上传速度和顺序。

##### 上传进度显示：及时显示上传进度，让用户知道上传进度和状态。

可以通过使用第三方库来实现大型文件上传，比如 Plupload、Resumable.js 等。

以下是一个使用 Plupload 实现大型文件上传的示例：

```
<!-- 引入 Plupload 的 JavaScript 和 CSS 文件 -->
<script type="text/javascript" src="plupload.full.min.js"></script>
<link rel="stylesheet" href="plupload.css">
```

```
<!-- 上传控件的容器 -->
<div id="uploader">
<p>Your browser doesn't have Flash, Silverlight or HTML5 support.</p>
</div>
```

```
<!-- 初始化上传控件 -->
<script type="text/javascript">
var uploader = new plupload.Uploader({
browse_button: 'uploader', // 上传控件的容器
```

##### 在后端，需要根据上传控件发送的请求，来实现文件的接收和存储。具体实现方式视具体情况而定，可以使用

SpringMVC、Express.js 等框架来实现。同时，也需要考虑上传文件大小限制、上传速度控制等问题。

```
⻥皮补充：建议大家可以尝试手写下大文件上传，这里涉及很多知识和可优化点，写好了就是一个独立的项
目
```

```
url: '/upload', // 上传文件的 URL
multi_selection: false, // 是否允许同时上传多个文件
filters: {
max_file_size: '100mb', // 最大上传文件大小
mime_types: [
{ title: 'Image files', extensions: 'jpg,jpeg,gif,png' },
{ title: 'Zip files', extensions: 'zip,rar' }
]
},
init: {
// 添加文件到上传队列之前触发的事件
BeforeUpload: function (up, file) {
console.log('BeforeUpload:', file.name);
},
// 开始上传文件时触发的事件
UploadFile: function (up, file) {
console.log('UploadFile:', file.name);
},
// 上传进度改变时触发的事件
UploadProgress: function (up, file) {
console.log('UploadProgress:', file.percent);
},
// 上传成功时触发的事件
FileUploaded: function (up, file, info) {
console.log('FileUploaded:', file.name, info.response);
},
// 上传出错时触发的事件
Error: function (up, err) {
console.log('Error:', err.message);
}
}
});
```

```
// 初始化上传控件
uploader.init();
</script>
```

### 18 、什么是箭头函数？能使用 new 来创建箭头函数么？

#### 官方解析

##### 箭头函数是 ES6 中新增的一种函数定义方式，可以用来简化函数的定义和书写。箭头函数的特点是：简洁的语法、

绑定 this 关键字、不能用作构造函数。

箭头函数使用箭头（=>）来定义，基本语法如下：

其中，parameters 是函数的参数列表，可以是一个或多个参数，多个参数之间用逗号分隔；statements 是函数的
执行语句，可以是一个或多个语句，多个语句之间用花括号包裹起来。

在箭头函数中，this 关键字指向的是函数定义时所在的对象，而不是执行时所在的对象。这个特性有助于避免 this
的指向问题，使得代码更加简洁易读。

需要注意的是，箭头函数不能用作构造函数，也就是不能通过 new 关键字来创建实例。因为箭头函数没有自己的
this，而是继承了外层作用域的 this。如果用 new 来创建实例，就会出现意料之外的结果。

⻥皮补充：”在箭头函数中，this 关键字指向的是函数定义时所在的对象，而不是执行时所在的对象。这个特性有助
于避免 this 的指向问题，使得代码更加简洁易读” —— 这句话很关键

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### 箭头函数的介绍

##### 箭头函数是 ES6 新增的一种使用“箭头“（=>）定义函数的方法，可以简化函数表达式的结构，写出更加简洁的代

##### 码。箭头函数的基本使用方法如下：

##### 如果函数没有参数或有多个参数，则直接使用一个小括号"()"代表参数部分；如果只有一个参数，可以省略小括

##### 号：

##### 如果函数体只有一行代码，比如一个赋值操作、一条表达式、调用另一个函数、一条输出语句等，则可以省略函数

##### 体的大括号“{}”，调用函数会隐式返回这行代码的值；如果只是想执行一行代码，不需要返回值，则可以在代码前

加上 void 关键字：

```
(parameters) => { statements }
```

```
let f = () => { return 1 + 2; }; // 没有参数
let f = (a, b) => { return a + b; }; // 有多个参数
```

```
let f = x = > { return x * 2; }; // 只有一个参数，括号可有可无
```

##### // 赋值操作

```
let f = x => x = 1;
let res = f(); // 无论是否传参，调用f时都会先执行赋值操作（x = 1），再把x的值作为函数的返回值返回
console.log(res); // 1
```

##### 注意，由于大括号会被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外加上一个小括号，否则

##### 会报错：

对于上述的特殊情况，原意是返回一个对象 { a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句 a:
1 。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。

与变量的解构赋值结合使用：

##### 简化回调函数：

##### 箭头函数的缺陷

##### 尽管箭头函数为函数的定义带来了便利，但相比于普通函数，它存在几个缺陷：

没有 this：

##### // 表达式

```
let f = x => x * 2;
console.log(f(2)); // 4
```

```
// 调用另一个函数
let fn = function () {};
let f = () => fn();
console.log(f()); // "undefined"
```

```
// 只执行一行代码，无需返回值
let f = () => void (1 + 2);
console.log(f()); // ”undefined“
```

```
let getTempItem = id => { id: id, name: "Temp" }; // 报错
let getTempItem = id => ({ id: id, name: "Temp" }); // 不报错
```

```
// 特殊情况
let foo = () => { a: 1 };
foo() // undefined
```

```
function full(person) {
return person.first + ' ' + person.last;
}
// 可简化为：
const full = ({ first, last }) => first + ' ' + last;
```

```
[1,2,3].map(function (x) {
return x * x;
});
// 可简化为：
[1,2,3].map(x => x * x);
```

对于普通函数来说，内部的 this 指向函数运行时所在的对象，而对于箭头函数来说，它没有自己的 this 对象，当
在其内部访问 this 时，会沿着作用域链查找 this 的值。这就意味着，如果箭头函数被一层或多层非箭头函数包
含，则 this 会指向最近一层非箭头函数的 this。也就是说，箭头函数的 this 在编写代码的时候就已经确定了，不
会随代码的运行而发生改变。另外，由于箭头函数没有自己的 this，所以也就不能用 call()、apply()、bind() 这些方
法去改变 this 的指向。

没有原型、super、new.target：之所以设计箭头函数，仅仅是为了实现一种简洁的函数定义语法，无需考虑与函
数（对象）相关的东⻄，所以箭头函数没有原型，即没有 prototype 属性，也没有相关的 super、new.target
等。

没有 arguments：箭头函数没有自己的 arguments 对象，所以无法通过它获取参数。如果要获取，可以用 rest 参
数代替：let arguments = (...args) => args;。注意，与 this、 super、new.target 一样，arguments 的值由最近
一层非箭头函数决定，比如：

不能通过 new 关键字调用：JS 的函数有两个内部方法：[[Call]] 和 [[Construct]]。当通过 new 调用普通函数时，
执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。当直接调用的时候，执
行 [[Call]] 方法，直接执行函数体。而由于箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过
new 的方式调用，会报错：

**mos 的回答**

**1. 相比普通函数，箭头函数有更加简洁的语法。**

普通函数

##### 箭头函数

##### 箭头函数是 ES6 中新增的一种函数定义方式，可以用来简化函数的定义和书写。箭头函数的特点是：简洁的语法、

绑定 this 关键字、不能用作构造函数。

箭头函数使用箭头（=>）来定义，基本语法如下：

```
function f() {
setTimeout(() => {
console.log('args:', arguments);
}, 100);
}
f(1, 2, 3) // args: [1, 2, 3]
```

```
let F = () => {};
new F(); // Uncaught TypeError: f is not a constructor
```

```
function add(num) {
return num + 10
}
```

```
const add = num => num + 10;
```

其中，parameters 是函数的参数列表，可以是一个或多个参数，多个参数之间用逗号分隔；statements 是函数的
执行语句，可以是一个或多个语句，多个语句之间用花括号包裹起来。

**2. 箭头函数不绑定 this，会捕获其所在上下文的 this，作为自己的 this。**

箭头函数的外层如果有普通函数，那么箭头函数的 this 就是这个外层的普通函数的 this，箭头函数的外层如果没有
普通函数，那么箭头函数的 this 就是全局变量. 下面这个例子是箭头函数的外层有普通函数。

##### 下面这个例子是箭头函数的外层没有普通函数。

箭头函数是匿名函数，不能作为构造函数，不可以使用 new 命令，否则后抛出错误。 需要注意的是，箭头函数不能
用作构造函数，也就是不能通过 new 关键字来创建实例。因为箭头函数没有自己的 this，而是继承了外层作用域
的 this。如果用 new 来创建实例，就会出现意料之外的结果。

**3. 箭头函数不绑定 arguments，取而代之用 rest 参数解决，同时没有 super 和 new.target。**

箭头函数没有 arguments、super、new.target 的绑定，这些值由外围最近一层非箭头函数决定。

下面的这个函数会报错，在浏览器环境下。

下面的箭头函数不会报错，因为 arguments 是外围函数的。

```
(parameters) => { statements }
```

```
let obj = {
fn:function(){
console.log('我是普通函数',this === obj) // true
return ()=>{
console.log('我是箭头函数',this === obj) // true
}
}
}
console.log(obj.fn()())
```

```
let obj = {
fn:()=>{
console.log(this === window);
}
}
console.log(obj.fn())// true
```

```
let f = ()=>console.log(arguments);
```

```
//报错
f(); // arguments is not defined
```

##### 箭头函数可以通过拓展运算符获取传入的参数。

**4. 使用 call,apply,bind 并不会改变箭头函数中的 this 指向。**

当对箭头函数使用 call 或 apply 方法时，只会传入参数并调用函数，并不会改变箭头函数中 this 的指向。 当对箭头函
数使用 bind 方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的 this 指向。

请看下面的代码

5. **箭头函数没有原型对象 prototype 这个属性**

由于不可以通过 new 关键字调用，所以没有构建原型的需求，所以箭头函数没有 prototype 这个属性。

##### 作者：编程导航知识星球 + 星球⻥友们

```
function fn(){
let f = ()=> {
console.log(arguments)
}
f();
}
fn(1,2,3) // [1,2,3]
```

```
const testFunc = (...args) => {
console.log(args);
}
testFunc([1,2,3])//[ [ 1, 2, 3 ] ]
```

```
window.name = "window_name";
```

```
let f1 = function () {
return this.name;
};
let f2 = () => this.name;
```

```
let obj = { name: "obj_name" };
```

```
console.log(f1.call(obj)); // obj_name
console.log(f2.call(obj)); // window_name
console.log(f1.apply(obj)); // obj_name
console.log(f2.apply(obj)); // window_name
console.log(f1.bind(obj)()); // obj_name
console.log(f2.bind(obj)()); // window_name
```

```
let F = ()=>{};
console.log(F.prototype) // undefined
```

### 19 、什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺

### 点？

#### 官方解析

##### 前端路由是指在前端⻚面内部实现⻚面之间的跳转，而不是像传统的网⻚跳转那样在后端进行⻚面跳转。前端路由

使用浏览器的 history 接口，通过改变浏览器的 URL，来更新⻚面的视图。

前端路由适合用于单⻚面应用（SPA）的开发。当一个应用中需要经常切换⻚面时，使用前端路由可以避免频繁向
服务器发起请求，提高⻚面切换的速度和用户体验。

前端路由的优点：

```
单⻚面应用的⻚面跳转速度快，用户体验好
可以根据不同的 URL 显示不同的⻚面内容，可以更好地实现前端的⻚面控制
可以更好地实现前端路由权限控制
```

前端路由的缺点：

```
不支持搜索引擎爬虫，对于 SEO 不利
对于复杂的⻚面控制逻辑和状态管理，需要额外的工作
需要注意浏览器的前进后退等操作对⻚面的影响
```

总的来说，前端路由适用于对⻚面跳转速度和用户体验有要求的单⻚面应用，但在一些场景下，需要权衡其带来的
一些缺点。

#### ⻥友的精彩回答

**luckythus 的回答**

**什么是前端路由** ？

前端路由是指：在前端中使用 JavaScript 实现的⻚面切换路由系统，它可以根据 URL 的变化，通过修改 DOM 来实现
单⻚面应用 SPA 的⻚面切换效果，无需每次请求⻚面时都要从服务器获取完整的 HTML ⻚面

在传统的 Web 应用中，每次点击⻚面链接或刷新⻚面时，浏览器都会向服务器发送请求，接收服务器返回的 HTML
⻚面，而在使用前端路由的 SPA 单⻚面应用中，⻚面的切换是通过 JavaScript 动态修改 DOM 内容来实现的，这样可
以避免每次都要向服务器请求⻚面时的开销，从而提高⻚面的响应速度和用户体验

我是这样理解的(不知道对不对) ：传统的 Web 应用，将所有的 HTML、CSS 和 JavaScript 文件都存放在服务器上，
然后网⻚切换⻚面时，每次都要发送请求来接收服务器响应回来的 HTML ⻚面。而使用前端路由的 SPA 单⻚面应
用，是第一次加载网⻚时，发送 http 请求，请求服务器返回 HTML、CSS、JavaScript 文件等静态资源，这些文件被
下载到浏览器中，并存储在浏览器的缓存中，当用户在 SPA 单⻚面应用进行⻚面切换时，前端路由会根据浏览器中
对应 URL 文件的路径信息，动态地加载相应的 JavaScript 文件，并执行里面的逻辑来更新切换⻚面内容。

**什么时候适合使用前端路由** ？

##### 前端路由适合用于构建单⻚面应用，特别是需要快速响应用户操作，避免不必要的⻚面刷新应用，例如需要高度交

##### 互的应用，如社交网络，音乐播放器

##### 它有哪些优点和缺点 ？

##### 优点：

```
快速响应：前端路由进行⻚面切换时不需要向服务器发送http请求，从而快速响应用户操作，提高加载速度
降低服务器压力：采用前端路由，降低了请求次数，减轻了服务器的负担。
提高应用的交互性：前端路由实现⻚面无缝切换，避免了传统应用中⻚面卡顿白屏等现象
```

缺点：

```
不利于SEO，由于前端路由是根据文件里面的URL修改DOM来切换，而不是加载新的HTML⻚面，所以不利于
搜索引擎的搜索。
初次加载慢：由于前端路由需要在初次加载时候将所有的静态资源（HTML、CSS、JavaScript）文件都加载到
客户端，因此首次加载时间较⻓，影响用户体验
复杂度高：前端路由需要在客户端处理好切换⻚面逻辑以及前进后退等操作，增加了应用的复杂度。
```

```
⻥皮评论：理解正确
```

**useGieGie 的回答**

前端路由是指在 Web 应用程序中，将 URL 和对应的视图或组件之间的映射关系交给前端来处理的一种技术。具体来
说，前端路由会拦截浏览器的 URL 请求，然后根据 URL 中的信息，决定哪些组件或⻚面需要渲染。

前端路由适合用于单⻚面应用程序（Single Page Application，SPA）中，因为这种应用程序只有一个 HTML ⻚面，
所有的内容都是通过 JavaScript 来动态更新的。在这种情况下，前端路由可以让用户通过浏览器的后退和前进按
钮，来切换不同的应用程序状态，而不会重新加载整个⻚面。

前端路由的优点包括：

1. 快速响应：前端路由可以快速响应用户的操作，因为不需要向服务器发起新的请求。
2. 提高用户体验：前端路由可以让用户在不刷新⻚面的情况下，快速地浏览和切换不同的应用程序状态，提高用
   户的交互体验。
3. 更好的性能：前端路由可以减少服务器的负担，因为不需要频繁地向服务器发起请求。同时，前端路由可以利
   用浏览器的缓存机制，提高⻚面的加载速度。
4. 状态管理：前端路由可以帮助开发人员更好地管理应用程序的状态，使得应用程序更加可控。
5. 提高代码可维护性：前端路由可以将应用程序的不同功能拆分成多个组件，使得代码更加清晰易懂，便于维护
   和更新。
6. 可以实现无刷新⻚面加载：使用前端路由可以在不刷新整个⻚面的情况下，更新⻚面部分内容。

前端路由的缺点包括：

1. 不支持搜索引擎优化：由于前端路由是通过 JavaScript 来控制⻚面的显示和隐藏，搜索引擎无法读取⻚面内
   容，因此可能会影响 SEO。
2. 增加开发难度：前端路由需要开发人员编写复杂的 JavaScript 代码，对开发人员的技能要求较高。

3. 可能会增加⻚面加载时间：由于前端路由需要在浏览器中加载更多的 JavaScript 代码，可能会导致⻚面加载时
   间变慢。
4. 前进、后退不够可靠：前端路由通过 JavaScript 控制⻚面的显示和隐藏，如果用户手动修改 URL，可能会导致
   前进、后退等浏览器行为失效。
5. 不支持浏览器回退：由于前端路由是通过 JavaScript 控制⻚面的显示和隐藏，无法支持浏览器回退功能。
6. 可能会增加代码复杂性：使用前端路由需要对路由、状态管理等相关概念有一定的理解，并需要编写较为复杂
   的 JavaScript 代码，这可能会增加代码的复杂性。

除此之外，还有以下需要注意的点：

1. 前端路由需要注意浏览器兼容性。不同浏览器可能会有不同的实现，需要进行兼容性测试和处理。
2. 前端路由应该合理使用，不要滥用。如果应用程序只有少量⻚面和交互，使用前端路由可能并不合适，反而会
   增加代码复杂性和维护难度。
3. 在使用前端路由时，应该注意安全性。由于前端路由可以通过 URL 来控制⻚面的显示和隐藏，如果不进行正确
   的安全性处理，可能会被恶意攻击者利用来实现跨站脚本攻击（XSS）等安全问题。
4. 如果需要实现 SEO（搜索引擎优化），可以考虑使用服务端渲染（Server-Side Rendering，SSR）等技术来处
   理。SSR 可以让服务器将网⻚的 HTML 内容直接输出给浏览器，从而避免了前端路由无法被搜索引擎抓取的问
   题。
5. 前端路由可以使用不同的实现方式，例如基于 History API 的路由和基于 Hash 的路由。基于 History API 的路由
   使用真实的 URL，比较直观，但是需要服务器端的支持；基于 Hash 的路由则可以在不需要服务器端支持的情
   况下实现，但是 URL 可能会显得比较丑陋。
6. 前端路由应该尽可能的简化 URL，避免使用过于复杂的 URL，以提高用户体验和 SEO 效果。同时，也需要注意
   URL 的可读性和易记性，以方便用户进行⻚面导航和分享。
7. 前端路由可以结合使用其他技术，例如状态管理库（例如 Redux）和异步加载（例如按需加载），以提高应用
   程序的性能和可维护性。
8. 前端路由也需要考虑性能问题。如果路由配置过多或者⻚面内容过于复杂，可能会导致⻚面加载速度变慢。因
   此，在使用前端路由时需要进行性能优化，例如使用按需加载和代码分割等技术。
9. 前端路由可以结合使用路由守卫（Route Guard）来实现权限控制和⻚面跳转等功能。路由守卫可以在路由跳
   转前或者跳转后执行相应的逻辑，例如检查用户是否有权限访问某个⻚面、记录用户浏览历史、防止用户在未
   登录的情况下访问需要登录的⻚面等。
10. 前端路由可以使用编程式导航（Programmatic Navigation）来实现⻚面跳转。编程式导航是指在 JavaScript
    代码中通过调用路由实例的 API 来进行⻚面跳转，而不是通过点击链接或者刷新⻚面来触发路由跳转。编程式
    导航可以灵活控制路由跳转的时机和方式，从而提高用户体验和⻚面交互性。
11. 前端路由还可以结合使用动画效果来实现⻚面过渡和切换效果，从而提高用户体验。例如，可以在⻚面切换时
    添加渐变动画、滑动动画等效果，以增强⻚面之间的连贯性和视觉效果。
12. 在使用前端路由时，需要注意内存管理和⻚面卸载等问题。由于前端路由是单⻚面应用程序，⻚面之间的切换
    是通过 JS 实现的，因此需要注意内存泄漏和⻚面卸载等问题，以避免浪费内存和影响应用程序性能。
13. 前端路由可以使用路由参数（Route Parameters）来传递数据。路由参数是指在 URL 中使用特定的占位符来
    表示动态的数据，例如在 URL 中使用:id 来表示某个资源的唯一标识符。路由参数可以在路由配置中定义，并通
    过路由实例的 API 来访问和传递数据，以实现动态的⻚面内容和交互效果。
14. 前端路由还可以使用路由导航钩子（Route Navigation Hook）来实现⻚面跳转前和跳转后的逻辑处理。路由
    导航钩子是指在路由跳转前或者跳转后执行相应的逻辑，例如在跳转前检查用户是否登录、在跳转后记录用户
    浏览历史等。路由导航钩子可以在路由配置中定义，并通过路由实例的 API 来访问和执行。

15. 前端路由还可以使用动态路由（Dynamic Route）来实现动态⻚面的创建和配置。动态路由是指在路由配置
    中使用动态的路径来匹配不同的 URL，例如在路径中使用:id 来匹配不同的资源标识符。动态路由可以实现动态
    的⻚面生成和路由配置，从而提高应用程序的灵活性和可扩展性。
16. 前端路由可以通过异步组件加载（Lazy Loading）来优化应用程序性能。异步组件加载是指在需要使用某个
    组件时再进行组件的加载和初始化，而不是在应用程序启动时一次性加载所有组件。通过异步组件加载，可以
    减少应用程序的初始化时间和内存占用，从而提高应用程序的性能和响应速度。
17. 前端路由还可以结合使用状态管理器（State Management）来实现全局状态的管理和共享。状态管理器是指
    在应用程序中使用专⻔的库或框架来管理应用程序的全局状态，例如使用 Vuex 或 Redux 来管理应用程序的状
    态。通过状态管理器，可以实现全局状态的共享和响应式更新，从而提高应用程序的可维护性和可扩展性。
18. 前端路由还可以使用路由别名（Route Alias）来实现 URL 的重定向和简化。路由别名是指在路由配置中使用
    一个路径别名来代替另一个路径，例如使用/alias 代替/path/to/some/page。通过路由别名，可以实现 URL 的
    简化和重定向，从而提高用户体验和⻚面交互性。
19. 前端路由可以使用路由元信息（Route Meta）来实现路由级别的元数据管理。路由元信息是指在路由配置中
    使用特定的属性来定义路由的元数据，例如⻚面标题、⻚面布局、访问权限等。通过路由元信息，可以实现路
    由级别的元数据管理和访问，从而提高应用程序的灵活性和可维护性。
20. 前端路由还可以使用嵌套路由（Nested Route）来实现复杂⻚面的组合和嵌套。嵌套路由是指在路由配置中
    使用嵌套的路由结构来实现⻚面的组合和嵌套，例如使用子路由来组合不同的⻚面组件。通过嵌套路由，可以
    实现复杂⻚面的分解和组合，从而提高应用程序的可维护性和可扩展性。
21. 前端路由还可以使用路由拦截器（Route Interceptor）来实现路由级别的拦截和处理。路由拦截器是指在路
    由跳转前或者跳转后执行相应的拦截和处理逻辑，例如在跳转前检查用户是否登录、在跳转后记录用户浏览历
    史等。通过路由拦截器，可以实现路由级别的安全检查和状态管理，从而提高应用程序的可靠性和安全性。

```
⻥皮评论：#
```

### 20 、为什么 JS 要被设计为单线程？

#### 官方解析

##### JS 被设计为单线程的主要原因是为了避免多线程编程所带来的复杂性。如果 JS 是多线程的，那么在处理并发问题

##### 时，需要考虑锁、同步等一系列复杂的问题，这会增加代码的复杂度和开发难度。

##### 此外，JS 最初是为了解决网⻚交互的问题而诞生的，而网⻚交互的需求大部分是基于用户事件的，比如点击按钮、

##### 输入文本等。这些操作的响应速度要求很高，如果在响应事件的同时还要处理其他任务，可能会导致网⻚卡顿、响

##### 应变慢等用户体验不佳的问题。

##### 因此，为了避免多线程所带来的复杂性和降低开发难度，并且满足网⻚交互的高响应速度需求，JS 被设计为单线

##### 程。虽然单线程有局限性，但是可以通过异步编程、事件循环机制等技术手段来实现高效的并发处理。

#### ⻥友的精彩回答

##### 淡云的回答

因为 js 主要用于用户交互，单线程可以使用户的操作响应迅速；

HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作
DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

##### 你还费解吗的回答

##### JS 的单线程

##### JS 是单线程的，这表示它同一时间只能执行一个任务，其他任务都必须在后面排队等待。

##### 它之所以被设计为单线程，而非多线程，和历史有关。JS 最初只是用于做一些简单的输入验证处理，开发者并没有

##### 想法要将它应用于复杂的场景。另外，如果采用多线程，则需要共享资源，并且有可能修改彼此的运行结果。比

##### 如，假设 JS 同时有两个线程，一个要修改某个 DOM 节点，另一个要删除它，这时浏览器应该以哪个线程为准呢？

##### 当然可以通过锁来解决上面的问题。但为了避免因引入了锁而带来更大的复杂性，JS 在最初就选择了单线程执行。

##### 尽管单线程实现起来比较简单，执行环境相对单纯，但它还是存在明显的缺点：只要一个任务耗时非常⻓，后面的

##### 任务就必须排队等待，这会严重拖慢整个程序的执行。比如，执行代码时遇到一段死循环，浏览器就会不断地执

##### 行，在此期间，不能与⻚面进行任何交互，⻚面会出现一种卡死的现象。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JS 脚本创建多个线程，但是子线程完全受
主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JS 单线程的本质。

**浏览器的多进程架构**

补充一下，“JS 是单线程的”指的是执行 JS 的线程只有一个，是浏览器提供的 JS 引擎线程（主线程）。如今的主流
浏览器都是多进程架构的，以 Chrome 为例，它包含了 1 个 浏览器主进程、 1 个 GPU 进程、 1 个网络进程、多个
渲染进程或多个插件进程。作为前端开发者，应重点关注其渲染进程，渲染进程的核心任务是将 HTML、CSS 和
JavaScript 转换为可交互的网⻚，排版引擎 Blink 和 JS 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为
每个 Tab 标签创建一个渲染进程。一个渲染进程通常由以下线程组成：

JS 引擎线程（主线程）：

JavaScript 引擎，也称为 JS 内核，负责处理 JS 脚本，执行代码。

当主线程空闲且任务队列不为空时，会依次取出任务执行。

注意，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JS 时间过⻓，将导致⻚面渲染的阻塞。

GUI 渲染线程：

主要负责⻚面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。

当界面需要重绘或者由于某种操作引发重排时，将执行该线程。

注意：该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 线程会被挂起，当任务队列空闲时，主线程才会去
执行 GUI 渲染。

事件触发线程：

用于控制事件循环，将准备好的事件交给 JS 引擎线程执行。

当主线程遇到异步任务，如 setTimeOut（或 ajax 请求、鼠标点击事件），会将它们交由对应的线程处理，处理完
毕后，事件触发线程会把对应的事件添加到任务队列的尾部，等待 JS 引擎的处理。

注意：由于 JS 的单线程关系，队列中的待处理事件都得排队等待，只有在 JS 引擎空闲时才能被执行。

定时器触发线程：

负责执行定时器一类函数的线程，如 setTimeout，setInterval 等。

主线程依次执行代码时，遇到定时器，会将定时器交由该线程进行计时，当计时结束，事件触发线程会将定时器的
回调函数添加到任务队列的尾部，等待 JS 引擎空闲后执行。

异步 http 请求线程：

负责执行异步请求一类的函数的线程，如 Promise，axios，ajax 等。
主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理。当监听到状态码变更，如果设置有回调函数，
事件触发线程会将相应的回调函数添加到任务队列的尾部，等待 JS 引擎空闲后执行。

### 21 、JS 代码中的 use strict 是什么？有什么作用？

#### 官方解析

"use strict" 是 ECMAScript 5 引入的一种严格模式，它用于指示 JavaScript 引擎采用更严格的解析和执行模式。

当在 JavaScript 代码中使用 "use strict" 声明时，代码将会在严格模式下执行。严格模式包含了一些额外的规则和
限制，有助于开发者避免一些常⻅的错误。

使用 "use strict" 的主要作用包括：

1. 消除 JavaScript 中的一些不合理、不安全的语法，减少代码出错的可能性。
2. 防止使用未声明的变量、函数，强制开发者进行声明。
3. 强制函数中的 this 值只能在函数内部使用，避免在全局作用域中误用 this 值。
4. 禁止删除变量、函数等，避免意外删除重要的变量和函数。
5. 提高代码性能，因为 JavaScript 引擎可以更好地进行优化。

使用 "use strict" 的方式有两种：

1. 在 JavaScript 文件开头使用 "use strict"。
2. 在函数体内第一条语句中使用 "use strict"。

例如，在 JavaScript 文件开头使用 "use strict" 的方式如下：

在函数体内第一条语句中使用 "use strict" 的方式如下：

```
"use strict";
var x = 1;
```

总之，"use strict" 是一种在 JavaScript 中使用严格模式的方法，它可以提高代码的可靠性和性能，避免一些常⻅
的错误。

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### 严格模式的简介

**"user strict"** 是 ES5 新增的一个预处理指令，它不是一条语句，而是一个字面量表达式，能为代码开启 **严格模式
（Strict Mode）** 。

严格模式是一种具有限制性的 JavaScript 模式，能让浏览器以更加严格、规范的方式对代码进行检测和执行。严格
模式可以应用在两个地方，一个是 JS 文件的开头，也就是在头部加上 **"use strict"** ;，这会为整个脚本开启严格模
式；另一个则是函数体开头，也就是在函数内部的最顶端加上 **"use strict"** ;，这指定了函数会在严格模式下执行。

严格模式的限制
JavaScript 在最初设计时，为了让开发者能快速上手，没有对语法做严格的限制，从而导致了一些不合理的代码能
被正常解析和运行，但这会带来一些安全隐患，例如，变量可以直接使用，不使用关键字声明： **x = 1** ;，这显然是
不合理的，任何变量理应在声明后才能使用。在严格模式中，为了使代码更加规范、合理，做了以下限制：

1. 变量必须声明后再使用，不能通过不使用关键字创建全局变量
2. 不能通过 delete 操作符删除变量（包括对象和函数）
3. 不允许使用转义字符
4. 不允许函数参数重名
5. 变量名不能使用 eval 或 arguments
6. 不能使用 0 作为开头表示八进制，而是应使用 0o
7. 禁止 this 默认指向全局对象 window
8. 不可修改对象的只读属性（writable = false）
9. 不可使用 delete 操作符删除对象的不可配置属性（configurable = false）
10. 不能修改对象中只定义了 getter() 无设置 setter() 的属性
11. 不能读取对象中只定义了 setter() 无设置 getter() 的属性
12. 不能使用 with 语句
13. eval 不会在它的外层作用域引入变量
14. 淘汰 arguments.callee 和 arguments.caller
15. 增加了一些保留字，不能作为变量名：implements、interface、let、package、private、protected、
    public、static、yield。

优点和缺点

```
function myFunction() {
"use strict";
var x = 1;
}
```

##### 优点：

##### 消除 JS 语法的一些不合理、不严谨之处，减少一些怪异行为。

##### 提高代码的可靠性和可维护性，避免代码运行时出现意外。

##### 提高编译器效率，增加代码运行速度。

##### 缺点：

##### IE10 以下不支持严格模式。

##### 由于某些库和框架可能依赖于 JS 的一些非标准行为，在严格模式下这些行为可能会失效。

##### 如今大部分网站都会对 JS 进行合并压缩，一些文件开启了严格模式，而另一些没有。这些原本是严格模式的

##### 文件被压缩后就成为了大文件的某一部分，不仅没有了严格模式，还在压缩后浪费了字节。

```
注意：ES6 的模块自动采用严格模式，不管有无在头部加上 "use strict";。
```

### 22 、如何使用 JS 判断某个字符串⻓度（要求支持 Emoji 表情）？

#### 官方解析

在 JavaScript 中，可以使用 String 类型的 length 属性来获取字符串的⻓度。但是，由于 Emoji 表情在字符串中占
用了两个字符的位置，因此直接使用 length 属性得到的结果并不准确。

为了正确地获取字符串的⻓度，可以使用如下的方法：

举个例子，对于字符串 "Hello,$!"，使用该函数计算出的⻓度为 8 ，而使用 length 属性计算出的⻓度则为 9 。

##### /\*\*

```
* 计算字符串的⻓度（支持 Emoji 表情）
* @param {string} str - 要计算⻓度的字符串
* @returns {number} - 字符串的⻓度
*/
function getLength(str) {
let length = 0;
for (let i = 0; i < str.length; i++) {
const code = str.charCodeAt(i);
if (code >= 0xd800 && code <= 0xdbff) {
i++;
}
length++;
}
return length;
}
```

#### ⻥友的精彩回答

##### 九仞的回答

##### 正则表达式替换

利用正则表达式将 emoji 替换成单字符的符号，然后再获取 len 就是正确的 length 了。

```
replace不会影响原字符串的内容
```

##### 输出

##### ES6 特性

ES6 大幅增强了对字符串的处理能力。 借用数组，可以快速判断带有 emoji 字符的字符串⻓度。

##### 输出：

##### 局限性

多码点的 emoji 比如%，会显示⻓度为 5 ，这是因为 unicode 的约定导致的，详情可看阮一峰的这篇博文 [http://ww](http://ww)
w.ruanyifeng.com/blog/2017/04/emoji.html

### 23 、JS 在什么情况下会存在数字精度丢失的问题，如何解决？

#### 官方解析

在 JavaScript 中，数字类型是采用 IEEE 754 标准的双精度浮点数表示的，由于双精度浮点数只有 52 位精度，因此
在进行精度较高的数值计算时，可能会出现数字精度丢失的问题。例如：

##### 可以看到，实际上 0.1 + 0.2 的结果并不等于 0.3，这是因为双精度浮点数的精度限制导致的。在处理货币等需要高

##### 精度计算的场景时，这种精度丢失的问题可能会导致计算错误。

##### 为了解决这个问题，可以采用以下几种方法：

```
const str = "H&";
const len = str.replace(/\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]/g,"-").length;
console.log(len)
```

##### 2

```
const str = "A&";
const arr = Array.from(str);
console.log(str.length,arr.length)
```

##### 3 2

```
console.log(0.1 + 0.2); // 输出结果为 0.30000000000000004
```

##### 使用整数进行计算：可以将数字转换成整数进行计算，例如将货币的单位从元转换成分进行计算，避免小数计算带

##### 来的精度问题。

使用第三方库：例如 decimal.js 和 big.js 等第三方库，可以提供更高精度的数字计算功能，避免精度丢失的问题。

使用 toFixed 方法：可以使用 JavaScript 中的 toFixed 方法将数字转换成指定位数的字符串，例如将 0.1 和 0.2 转
换成一位小数的字符串再进行相加，避免精度丢失的问题。

总之，在进行精度较高的数值计算时，需要注意 JavaScript 中存在的数字精度丢失问题，并根据具体情况选择合适
的解决方案。

### 24 、说说你对 JS 模块化方案的理解，比如 CommonJS、AMD、CMD、

### ES Module 分别是什么？

#### 官方解析

##### JS 模块化是指将一个 JS 应用拆分成多个模块或文件，并通过一定的规范或语法定义它们之间的依赖关系，从而达

##### 到复用、维护、扩展的目的。常⻅的 JS 模块化方案有以下几种：

1. CommonJS：一种用于服务器端的模块化规范，主要用于 Node.js，它通过 require 来引入模块，通过
   module.exports 或 exports 来导出模块。
2. AMD：一种用于浏览器端异步加载模块的规范，主要用于 RequireJS，它通过 define 来定义模块，通过
   require 来异步加载模块。
3. CMD：一种用于浏览器端延迟执行的模块化规范，主要用于 SeaJS，它通过 define 来定义模块，通过
   require 来延迟执行模块。
4. ES Module：一种官方规范，用于浏览器端和 Node.js 中，通过 import 来引入模块，通过 export 来导出模
   块。

这些模块化方案在实现上有不同的语法和规范，但它们都是为了实现 JS 的模块化而产生的，都可以使 JS 应用更易
于维护和扩展。

其中，ES Module 是官方规范，具有更好的兼容性和可扩展性，而 CommonJS 和 AMD/CMD 则更多地用于
Node.js 和浏览器端的异步加载，各有优缺点。

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### 模块化是一种管理代码的方案，它的思想是将一个复杂的程序按功能的不同划分成不同的模块（文件），各个模块

##### 存储自己的私有数据，外部不可访问，但同时模块也会向外暴露一些公共接口，使得多个模块之间可以互相通信。

##### 采用模块化方案能让开发者对程序的各项功能有更加清晰的认识，从而方便对代码进行维护和管理，提高开发效

##### 率。JS 的模块化在经历了多年发展后，最终形成了统一的规范，如今比较常⻅的有：

1. **CommonJS** ：

```
console.log((0.1 + 0.2).toFixed(1)); // 输出结果为 "0.3"
```

Node.js 实现了 CommonJS 规范，在 Node.js 中，每个文件就是一个模块，有自己的作用域，也就是说，在一个
文件里定义的变量或函数，都是私有的，对其他文件不可⻅。如果想提供给其它文件使用，可将它们挂载到
exports 或 module.exports 接口对象上，比如：

其中，module 是一个对象，代表当前模块，它有一个属性 exports ，是对外的接口，所以 module.exports 和
exports 保存的是同一个引用。

如果要获取另一个模块暴露的接口，则使用 require(xxx) ，如果是第三方模块，xxx 为模块名；如果是自定义模
块，xxx 为模块文件路径。require() 会读入并执行一个 JS 文件，然后返回该模块的 module.exports 对象，如果没
有发现指定模块，会报错。

2. **AMD** ：AMD 是一种异步模块化方案，主要用于浏览器端。它采用异步加载模块的方式，可以在⻚面加载时并
   行加载多个模块，提高了⻚面的加载速度。AMD 的模块化语法主要是通过 define 和 require 来实现的，最著
   名的实现是 RequireJS。
3. **CMD** ：CMD 是另一种异步模块化方案，也是主要用于浏览器端的。它采用异步加载模块的方式，但是与
   AMD 不同的是，CMD 是按需加载模块，只有在需要使用某个模块时才会加载。CMD 的模块化语法主要是通
   过 define 和 require 来实现的，最著名的实现是 SeaJS。
4. **ES6 Module** ：ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，极大可能成为浏览器和服
   务器通用的模块解决方案。其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块
   的对外接口，import 命令用于输入其他模块提供的功能。

**ES6 Module 与 CommonJS 的差异：**

```
CommonJS 模块输出的是一个值的拷⻉，ES6 模块输出的是值的引用。
CommonJS 模块输出的是值的拷⻉，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令
import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里
面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会
跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个
对象上面读取方法，这种加载称为“运行时加载”。
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的
形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
```

CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是
对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

```
exports.a = 1;
// 等价于
module.exports.a = 1;
```

```
console.log(exports === module.exports); // true
```

### 25 、如果使用 Math.random() 来计算中奖概率，会有什么问题吗？

#### 官方解析

使用 Math.random() 来计算中奖概率是不可靠的。因为 Math.random() 函数的随机性并不是真正的随机，它是基
于一个种子值（seed）生成的伪随机数序列。如果你在相同的环境中使用相同的种子值，那么生成的随机数序列是
相同的。因此，如果不使用合适的种子值生成伪随机数，就有可能出现概率计算错误的情况。

为了准确地计算中奖概率，可以使用其他的随机数生成算法，比如 crypto 模块中的 randomBytes() 方法，它可以
生成真正的随机数。例如，如果要计算 1/1000 的中奖概率，可以使用如下代码：

在上面的代码中，使用 crypto.randomBytes() 生成 4 个字节的随机数，然后将它转换为无符号的 32 位整数，判
断该随机数是否小于 429496729 ，如果小于，则认为中奖了。这样计算中奖概率是比较准确的。

#### ⻥友的精彩回答

**codexgh 的回答**

Math.random() 函数返回一个 0~1 之间的伪随机浮点数，其在 V8 中的实现原理式这样的：
为了能够保证足够的性能，Math.random() 随机数并不是实时生成的，而是直接生成一组随机数（ 64 个），并放
到缓存中，当这一组随机数取完之后会再重新生成一批新的随机数，放到缓存中。
由于 **Math.random()** 的底层算法是公开的（xorshift128+ 算法），V8 源码可⻅，因此，是可以使用其他语言模
拟的，这就导致，如果攻击者知道了当前随机生成器的状态，那就可以知道缓存中的所有随机数，那就很容易匹配
与破解。所以说使用 Math.random() 来计算中奖概率是不可靠的。

**Et cetera 的回答**

如果使用 Math.random() 计算中奖概率，可能会存在以下问题：

1. 不够随机：虽然 Math.random() 方法可以生成一个 0 到 1 之间的随机数，但是这个随机数并不是真正的随机
   数，而是伪随机数。在一些特定的情况下，比如连续生成多个随机数，可能会出现重复的情况。
2. 容易被猜测：由于 Math.random() 方法本质上是一个伪随机数生成器，因此可以通过分析和猜测算法，来推
   测下一个数是什么。在安全性要求较高的场合，使用 Math.random() 生成随机数可能会暴露系统的安全漏
   洞。
3. 难以控制精度：如果仅仅使用 Math.random() 方法生成随机数，很难精确控制中奖概率。例如，如果要控制
   中奖概率为 1%，那么就需要根据随机数生成的概率来调整算法，可能需要多次尝试才能得到合适的结果

```
const crypto = require('crypto');
```

```
function isWinner() {
const rand = crypto.randomBytes(4).readUInt32BE();
return rand < 429496729; // 429496729 = Math.pow(2, 32) / 1000
}
```

### 26 、怎么使用 JS 实现元素拖拽功能？

#### 官方解析

要使用 JavaScript 实现元素的拖拽功能，您可以按照以下步骤操作：

为需要拖拽的元素添加 mousedown、mousemove 和 mouseup 事件监听器。 在 mousedown 事件处理函数中，
记录鼠标按下时的位置，以及鼠标相对于元素的位置。 在 mousemove 事件处理函数中，计算鼠标移动的距离，
并更新元素的位置。 在 mouseup 事件处理函数中，移除 mousemove 和 mouseup 事件监听器。 以下是一个简
单的实现示例：

```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Draggable Element</title>
<style>
#draggable {
width: 100px;
height: 100px;
background-color: blue;
position: absolute;
cursor: move;
}
</style>
</head>
<body>
<div id="draggable"></div>
```

```
<script>
const draggableElement = document.getElementById('draggable');
```

```
draggableElement.addEventListener('mousedown', (event) => {
// 记录鼠标按下时的位置
let startX = event.clientX;
let startY = event.clientY;
```

```
// 计算鼠标相对于元素的位置
let offsetX = startX - draggableElement.offsetLeft;
let offsetY = startY - draggableElement.offsetTop;
```

```
// 处理鼠标移动事件
const onMouseMove = (event) => {
// 计算鼠标移动的距离
let deltaX = event.clientX - startX;
let deltaY = event.clientY - startY;
```

```
// 更新元素的位置
```

##### 这个示例将实现一个简单的拖拽功能，您可以在此基础上根据需要进行调整和优化。注意，这个示例未考虑边界限

##### 制和性能优化，请根据实际需求进行相应调整。

#### ⻥友的精彩回答

**codexgh 的回答**

使用元素拖拽效果，我们需要给 需要拖拽的元素添加 mousedown mousemove mouseup 这三个事件。当鼠标按
下需要拖拽的元素时， 给元素的 mousemove 事件绑定拖动事件，处理对应的逻辑，当鼠标松开时移出拖动事
件。下面举个常⻅的例子，我们在使用编辑器时，会发现文件目录模块和内容模块之间可以拖动开调整对应大小,如
下图所示：

```
draggableElement.style.left = `${event.clientX - offsetX}px`;
draggableElement.style.top = `${event.clientY - offsetY}px`;
};
```

```
// 处理鼠标松开事件
const onMouseUp = () => {
document.removeEventListener('mousemove', onMouseMove);
document.removeEventListener('mouseup', onMouseUp);
};
```

```
// 添加事件监听器
document.addEventListener('mousemove', onMouseMove);
document.addEventListener('mouseup', onMouseUp);
});
</script>
</body>
</html>
```

##### 那我们来实现以下这个效果：

```
<!DOCTYPE html>
<html lang="en">
```

```
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
<style>
body {
display: flex;
margin: 0;
min-height: 100vh;
}
```

```
.scalable {
min-width: 200px;
position: relative;
```

background-color: beige;
}

.content img {
display: block;
width: 150px;
user-select: none;
}

.main {
flex: 1;
background-color: aqua;
}

.scalable .content {
padding: 20px;
padding-right: 34px;
}

.scalable .separator {
width: 14px;
height: 100%;
background-color: #fff;
box-shadow: 0 0 2px rgba(0, 0, 0, 0.35);
position: absolute;
top: 0;
right: 0;
cursor: col-resize;
display: flex;
justify-content: center;
align-items: center;
}

.scalable .separator i {
width: 2px;
height: 14px;
display: inline-block;
background-color: #e9e9e9;
margin: 0 1px;
}
</style>

</head>

<body>
<div class="scalable">
<div class="content">
<img src="https://avatars.githubusercontent.com/u/61002730?v=4" alt="">
</div>
<div class="separator">

##### 效果如下：

```
<i></i>
<i></i>
</div>
</div>
<div class="main"></div>
```

```
<script>
let startX, startWidth;
let $ = tag => document.querySelector(tag)
```

```
let getWidth = () => {
return parseInt(window.getComputedStyle($('.scalable')).width)
}
```

```
let onDrag = (e) => {
let newWidth = e.clientX - startX + startWidth;
$('.scalable').style.width = newWidth + 'px'
}
let stopDrag = () => {
document.documentElement.removeEventListener('mousemove', onDrag)
document.documentElement.removeEventListener('mouseup', stopDrag)
}
```

```
let startDrag = (e) => {
startX = e.clientX
startWidth = getWidth()
document.documentElement.addEventListener('mousemove', onDrag)
document.documentElement.addEventListener('mouseup', stopDrag)
}
```

```
$('.separator').addEventListener('mousedown', startDrag)
```

```
</script>
</body>
```

```
</html>
```

### 27 、JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？

#### 官方解析

JavaScript 也会出现 **内存泄漏问题** 。内存泄漏是指一些 **被分配的内存空间** ，因为某些原因而无法被 **垃圾回收机制** 回
收，导致占用内存空间无法被释放，最终会导致程序崩溃。

在 JavaScript 中，内存泄漏通常出现在以下情况：

1. **意外的全局变量** ：如果一个变量没有被垃圾回收，那么它的作用域会被认为是全局的，这样就会造成意外的全
   局变量，导致内存泄漏。
2. **定时器没有被清除** ：如果在⻚面关闭前，某个定时器没有被清除，它所引用的对象就不会被垃圾回收，从而导
   致内存泄漏。
3. **闭包** ：如果一个闭包中引用了外部变量，而这个闭包被其他代码引用，那么它所引用的外部变量就不会被垃圾
   回收，从而导致内存泄漏。
4. **DOM 引用** ：如果在⻚面上有大量的 DOM 元素，而这些元素被 JavaScript 代码所引用，但是却没有被正确地
   释放，就会导致内存泄漏。
5. **循环引用** ：如果两个或多个对象之间形成了循环引用，即相互引用对方，那么它们都不会被垃圾回收，从而导
   致内存泄漏。

为了避免 JavaScript 中的内存泄漏问题，可以采取以下措施：

1. **避免意外的全局变量** ，可以使用 "use strict" 模式，或者在函数中使用 var、let 或 const 声明变量。
2. 在使用 **定时器** 时，一定要记得及时清除定时器。
3. 尽量避免使用 **闭包** ，如果必须使用闭包，要注意不要引用外部变量或者及时清除闭包。

##### 4. 在操作 DOM 元素时，要 及时释放引用 ，避免 DOM 引用导致内存泄漏。

##### 5. 避免循环引用 ，可以在对象不再使用时，手动断开对象之间的引用关系。

#### ⻥友的精彩回答

**useGieGie 的回答**

JavaScript 也有可能出现内存泄漏问题。内存泄漏是指在程序运行过程中，已经无用的内存没有被及时释放，导致
系统可用内存逐渐减少，最终可能会导致程序崩溃。以下是一些可能会导致内存泄漏的情况：

1. 意外的全局变量：在函数中未使用 var、let 或 const 关键字声明变量，会导致变量被赋值到全局对象上，这
   样可能会在不必要的情况下占用大量内存空间。
2. 被遗忘的定时器和回调函数：设置了定时器和回调函数，但在不需要的时候未及时清除，导致它们仍然被保存
   在内存中。
3. 闭包：由于闭包会引用包含函数的变量，如果闭包一直存在，这些变量也会一直存在于内存中，无法被垃圾回
   收。
4. DOM 引用：由于 DOM 对象很少被自动垃圾回收，如果对 DOM 元素的引用一直存在，则这些元素所占用的
   内存也无法被释放。来自剪贴板
5. 循环引用：当两个或多个对象互相引用，并且在程序执行过程中不再需要这些对象时，它们可能会被垃圾回收
   器忽略，从而导致内存泄漏。 6. 递归会占用大量的内存，如果递归的深度过大，可能会导致内存泄漏。

避免内存泄漏的方法包括：

1. 避免循环引用。可以在不需要对象时手动解除引用，或者使用 WeakMap 或 WeakSet 等数据结构来避免循环
   引用。
2. 及时清除引用：手动清除不再需要的变量、对象和事件监听器等引用，以便 JavaScript 垃圾回收器回收内
   存。
3. 避免创建过多的全局变量：全局变量会一直存在于内存中，因此应该尽量减少全局变量的使用，将变量限制在
   函数或局部作用域内。
4. 使用闭包：使用闭包可以有效地控制变量的作用域和生命周期，避免变量在不需要的时候一直占用内存。
5. 避免使用递归：递归会占用大量的内存，如果递归的深度过大，可能会导致内存泄漏。
6. 使用定时器和事件处理器：在使用定时器和事件处理器时，要及时清除这些定时器和事件处理器，以避免它们
   一直占用内存。
7. 使用可复用的对象池：可复用的对象池是一种有效的内存管理技术，它可以在需要时创建对象，而不是一直创
   建新的对象。这样可以减少内存的使用量，并提高程序的性能。
8. 使用内存分析工具：使用内存分析工具可以帮助开发者快速定位内存泄漏的问题，并采取相应的措施进行修
   复。
9. 避免在 DOM 上创建大量的数据，可以使用虚拟滚动等技术；
10. 使用事件委托来避免绑定过多的事件；
11. 避免使用过多的闭包，可以使用节流和防抖等技术来控制函数执行次数。

总之，要避免内存泄漏，需要我们具备良好的编程习惯，及时清除不再需要的引用，合理使用闭包和定时器等技
术，以及使用内存分析工具进行监测和调试。

**Kristen 的回答**

1. **内存泄漏**

指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。

2 **.JS 的回收机制**

JS 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开
销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔，周期性的执行。

到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没有使用，对于不再有用的变量打上标记，以备
将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引
用计数。引用计数不太常用，标记清除较为常用。

**（ 1 ）标记清除：**

js 中常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为
“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能
会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

##### （ 2 ）引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object
array）赋给该变量时，则这个值的引用次数就是 1 。如果同一个值又被赋给另一个变量，则该值的引用次数加 1 。

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1.当这个值的引用次数变成 0
时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行
时，它就会释放那些引用次数为 0 的值所占用的内存。

##### 3. 哪些操作会造成内存泄露

##### （ 1 ）意外的全局变量引起的内存泄露：

```
function test(){
var a=10;//被标记，进入环境
var b=20;//被标记，进入环境
}
test();//执行完毕之后a、b又被标记离开环境，被回收
```

```
function test(){
var a={};//a的引用次数为 0
var b=a;//a的引用次数加 1 ，为 1
var c=a;//a的引用次数加 1 ，为 2
var b={};//a的引用次数减 1 ，为 1
}
```

##### （ 2 ）闭包引起的内存泄漏：

##### 闭包可以维持函数内部局部变量，使其得不到释放。上例定义事件回调时，由于是函数内定义函数，并且内部函数

##### ——事件回调的引用外暴了，形成了闭包。

##### 解决方法：

##### ① 将事件处理函数定义在外部，解除闭包。

##### ② 在定义事件处理函数的外部函数中，删除对 DOM 的引用。

##### （ 3 ）没有清理的 DOM 元素引用：

```
function leak(){
leak="xxx";//leak成为一个全局变量，不会被回收
}
```

```
function bindEvent(){
var obj=document.createElement("XXX");
obj.οnclick=function(){
//Even if it's a empty function
}
}
```

##### //将事件处理函数定义在外部

```
function onclickHandler(){
//do something
}
function bindEvent(){
var obj=document.createElement("XXX");
obj.οnclick=onclickHandler;
}
```

```
//在定义事件处理函数的外部函数中，删除对dom的引用
function bindEvent(){
var obj=document.createElement("XXX");
obj.οnclick=function(){
//Even if it's a empty function
}
obj=null;
}
```

##### （ 4 ）被遗忘的定时器或者回调：

这样的代码很常⻅，如果 id 为 Node 的元素从 DOM 中移除，该定时器仍会存在，同时，因为回调函数中包含对
someResource 的引用，定时器外面的 someResource 也不会被释放。

**（ 5 ）循环引用引起的内存泄漏**

上面的例子在一个 DOM 元素（element）与一个原生 js 对象（myObject）之间创建了循环引用。其中，变量
myObject。由于存在这个循环引用，即使例子中的 DOM 从⻚面中移除，它也永远不会被回收。

例如，我们经常会这么做：

obj 引用了 document.getElementById("element")，而 document.getElementById("element") 的 onclick 方法
会引用外部环境中的变量，自然也包括 obj，非常隐蔽，这样就造成了循环引用。

最简单的解决办法就是手动解除循环引用：

```
var elements={
button: document.getElementById("button"),
image: document.getElementById("image"),
text: document.getElementById("text")
};
function doStuff(){
image.src="http://some.url/image";
button.click():
console.log(text.innerHTML)
}
function removeButton(){
document.body.removeChild(document.getElementById('button'))
}
```

```
var someResouce=getData();
setInterval(function(){
var node=document.getElementById('Node');
if(node){
node.innerHTML=JSON.stringify(someResouce)
}
},1000)
```

```
var element=document.getElementById("some_element");
var myObject=new Object();
myObject.e=element;
element.o=myObject;
```

```
window.οnlοad=function outerFunction(){
var obj=document.getElementById("element"):
obj.οnclick=function innerFunction(){};
};
```

myObject.e=null; element.o=null;

window.οnlοad=function outerFunction(){ var obj=document.getElementById("element"):
obj.οnclick=function innerFunction(){}; obj=null; }; 将变量设置为 null 意味着切断变量与它此前引用的值之间的
连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。要注意的是，IE9+ 并不存在引用导致
DOM 内存泄露问题，可能是微软做了优化，或者 DOM 的回收方式已经改变。

4. **如何避免内存泄漏**

为了避免 JavaScript 中的内存泄漏问题，可以采取以下 **措施** ：

```
避免意外的全局变量，可以使用 "use strict" 模式，或者在函数中使用 var、let 或 const 声明变量。
在使用定时器时，一定要记得及时清除定时器。
尽量避免使用闭包，如果必须使用闭包，要注意不要引用外部变量或者及时清除闭包。
在操作 DOM 元素时，要及时释放引用，避免 DOM 引用导致内存泄漏。
避免循环引用，可以在对象不再使用时，手动断开对象之间的引用关系。
```

### 28 、什么是 Javascript 的事件流？有哪些事件流模型？

#### 官方解析

JavaScript 的事件流是指浏览器中所有事件的传递和处理过程。事件流可以分为三个阶段：事件捕获、目标阶段和
事件冒泡。

1. 事件捕获阶段：事件从最外层的文档节点一直往下传递，直到事件到达事件的目标元素。在这个过程中，事件
   会经过父节点和祖先节点，直到到达目标节点。如果在这个过程中有事件处理程序，则事件将被调用。
2. 目标阶段：事件到达了目标元素后，将在目标元素上调用事件处理程序。如果有多个事件处理程序绑定到目标
   元素上，将按照它们的顺序执行。
3. 事件冒泡阶段：事件在目标元素上处理后，会从目标元素开始，向上传递回文档节点。在这个过程中，事件也
   会遇到任何绑定的事件处理程序。

目前有两种事件流模型：

1. W3C 标准事件模型（DOM2 级事件模型）：事件流由三个阶段组成：捕获阶段、目标阶段和冒泡阶段。这种
   事件模型中，事件处理程序的调用顺序与它们注册的顺序相同。
2. Microsoft 事件模型（IE 事件模型）：事件流由两个阶段组成：目标阶段和冒泡阶段。在这个事件模型中，事
   件处理程序的调用顺序与它们注册的相反。

总体来说，W3C 标准事件模型是当前主流的事件流模型。对于事件流，我们需要了解事件捕获、目标阶段和事件
冒泡，以便于正确地使用事件处理程序。

##### 作者：编程导航知识星球 + 星球⻥友们

## ES6

### 1 、ES6 有哪些新特性？

#### 官方解析

ES6（ECMAScript 6）是 JavaScript 的第六个版本，也称为 ES2015，引入了很多新特性来增强 JavaScript 语言的
能力。下面是 ES6 中一些常⻅的新特性：

1. let 和 const 声明变量
2. 模板字符串（Template Literals）
3. 解构赋值（Destructuring）
4. 箭头函数（Arrow Functions）
5. Promise 对象
6. 函数参数默认值
7. 对象字面量增强（Object Literal Enhancements）
8. 类和继承（Classes and Inheritance）
9. 迭代器（Iterators）
10. 生成器（Generators）
11. 模块（Modules）
12. Set 和 Map 数据结构
13. Symbol 数据类型
14. for...of 循环
15. let 和 const 块级作用域
16. 异步函数 async/await

ES6 的新特性增强了 JavaScript 的表现力和编程能力，使得开发者可以更加高效和便捷地编写代码。

#### ⻥友的精彩回答

##### 你还费解吗的回答

ES6（ECMAScript 6.0）是 JavaScript 语言的下一代标准，泛指 ES2015、ES2016、ES2017 及以后的标准，但有
时特指 ES2015 标准。ES6 的新特性有：

1. let 和 const：ES6 引入了用于声明变量的新关键字 let 和 const，解决了使用 var 时出现的一些不合理的问
   题，如变量提升、重复声明等。
2. 变量的解构赋值：所谓解构赋值，就是按照一定的规则从变量（如数组、对象）中提取值，然后同时给多个变
   量赋值。数组、对象、字符串以及函数参数等都可以进行解构赋值。
3. rest 参数：rest 参数用于获取函数的多余参数，可以替代函数的 arguments 对象。
4. 扩展运算符：相当于 rest 参数的逆运算，可将一个数组转为用逗号分隔的参数序列。
5. 箭头函数：ES6 引入了箭头函数，使得函数的定义更加方便、简洁。
6. BigInt：ES6 引入了一种新的原始数据类型 BigInt（大整数），它能表示范围更大的数值。

7. Symbol：Symbol 是 ES6 引入一种新的原始数据类型，表示独一无二的值。可作为对象的属性使用，确保属
   性名不重复。
8. Set 和 Map：Set 是一种类似于数组的数据结构，但无重复的值。Map 是一种类似于对象的集合，但属性可
   以是任意类型。
9. Promise：Promise 是一种异步编程的解决方案，比回调函数更加强大。与 Promise 相关的还有 Generator
   和 async。
10. Iterator：Iterator 是一种接口，若部署在数据结构（如对象）上，该数据结构就能被 for...of 遍历。数组
    身上默认部署了该接口，所以能被遍历。
11. Class：Class 类似于其它面向对象语言（如 Java、C++）的写法，可以看成是 ES5 构造函数的语法糖。
12. Module：ES6 引入了新的模块加载方案 Module，在编译时就能确定模块的依赖关系，相比于 CommonJS 的
    运行时加载效率更高。

增加的新特性还有 Proxy 和 Reflect，另外，数组、对象、正则、数值、字符串以及运算符也增加了不少新特性。

##### 九仞的补充

##### 本文用示例来展现一些新特性的方便用法

1. **模板字符串** （Template Literals）

模板字符串中所以类似于"${}"的字符串都将视为可执行的 js 语句。并且也会被语句中的实际值给替换。

像上面的示例，若没有模板化字符串这个特性，就得手动用一堆加号来拼接了。

2. **解构赋值** （Destructuring）

假设示例 1 是后端返回的数据，用解构赋值可以快速解构出对象中的变量。

##### 函数传参时也可以快速解构参数

3. **箭头函数** （Arrow Functions）

```
const data = [1,2,3,4,5]
const result = `
{
code: 200,
data: [${data}]
}
`
```

```
const {code,data} = Api.getData()
```

```
const res = Api.getData()
const resolveData = ({data})=>{
return data;
}
const data = resolveData(res);
```

箭头函数表面上看是 function 的替换，但是他有一个非常实用的特性，那就是自动绑定定义时上下文的 this 指针。

在一些特殊场景中，我们需要使用 this 指针，而对于 function 定义的函数，this 的指向是令人迷惑的，常常要分析代
码。

而箭头函数定义的函数则会自动将它的 this 和定义它时的上下文中的 this 绑定。

比如，以下代码，调用 getThis 时，会返回当前模块中的 app 变量(只是个演示)

##### 其实可以把它看做是以下代码的语法糖，省事儿了不少。

4. **对象字面量增强** （Object Literal Enhancements）

以下示例可以展现这个语法特性的方便之处

5. **Promise 对象**

这个特性可以让我们用.then 链替换掉以前的地狱嵌套式 callback 写法。

```
this = app;
const getThis = ()=>this;
```

```
/// Error
function a()
{
return this; // unknown this
}
/// Right
var a = (function (){return this}).bind(this)
/// ES6
const a = ()=>this
```

```
/// Old
let a = {
type:"Object",
funcProp: function(){return "result"}
}
let DynamicProp = Math.random();
a[DynamicProp] = "test";
```

##### /// ES6

```
const DynamicProp = Math.random();
const a = {
type:"Object",
funcProp() {return "result"},
[DynamicProp]: "test"
}
```

6. **async/await**

这个特性可以很方便的将同步函数变为异步函数。

不过我经常使用这个特性做其他一些事儿。比如上面提到的 Promise 可以使用.then 链解决多层 callback 的问题。但
是，如果我需要顺序执行一系列返回 Promise 的异步函数，即后一个异步函数需要前一个函数的返回值作为参数或
作为参考。这时如果继续用.then 链，则还是会不可避免的形成多层嵌套。

解决办法就是在 try 语句中使用 await 关键字。

之所以要用 try 是为了捕获原来需要用.catch 链捕获的异常

...

剩下特性有的用得不多，有的要写的话篇幅太⻓了，就不写了。以后有空在写笔记。

### 2 、ES5 中的类和 ES6 中的 class 有什么区别？

#### 官方解析

在 ES5 中，我们通常使用构造函数来创建对象和实现继承，而在 ES6 中，引入了类（class）的概念来简化对象创
建和继承的过程。下面是 ES5 中类和 ES6 中的 class 的一些区别：

```
语法不同：ES5 中使用构造函数来定义类，而 ES6 中使用 class 关键字来定义类。
继承方式不同：ES5 中使用原型链继承来实现继承，而 ES6 中使用 extends 关键字和 super 函数来实现继
承。
类方法的定义方式不同：ES5 中类方法定义在构造函数的原型对象上，而 ES6 中类方法定义在类的内部。
```

```
getData()
.then(/* Do something */)
.then(/* Do something */)
.catch(/* Catch error */)
```

```
try{
const ret1 = await asyncFunc1();
if(!ret1)
{
return false;
}
const ret2 = await asyncFunc2(ret1)
...
}
catch(err)
{
console.log(err);
return false
}
```

##### 类属性的定义方式不同：ES5 中类属性定义在构造函数的原型对象上，而 ES6 中类属性定义在类的内部，并

```
且需要使用 static 关键字来定义静态属性。
类的调用方式不同：ES5 中需要使用 new 关键字来创建类的实例，而 ES6 中类的调用方式更加简单，只需要
像函数一样调用即可。
```

需要注意的是，虽然 ES6 中引入了类的概念，但在底层实现上仍然是基于原型链的。因此，理解原型链继承和类的
继承是理解 JavaScript 面向对象编程的关键。

### 3 、什么是 ES6 中的 Promise？它的使用场景有哪些？

#### 官方解析

ES6 中的 Promise 是一种处理异步操作的方式，它是一个对象，用于表示一个异步操作的最终完成或失败及其结果
值的表示。Promise 对象有三种状态：pending（等待中）、fulfilled（已完成）和 rejected（已失败）。

Promise 有以下几个优点：

1. 可以避免回调地狱：将回调函数转换成了链式调用，代码可读性更好。
2. 可以支持多个并发请求：Promise.all() 可以让多个 Promise 并行执行，提高了执行效率。
3. 可以在异步代码中捕获错误：Promise.catch() 可以捕获异步代码中的错误。

Promise 的使用场景包括：

1. 处理异步操作：比如 Ajax 请求、文件读取等。
2. 优化回调函数：将回调函数转换成 Promise 链，提高代码可读性。
3. 实现并发请求：Promise.all() 可以让多个请求并行执行。
4. 解决回调地狱：将嵌套的回调函数转换成链式调用，提高代码可读性。

以下是使用 JS 编码实现 Promise 的例子

```
// 定义一个 Promise
const promise = new Promise((resolve, reject) => {
// 异步操作
setTimeout(() => {
if (Math.random() > 0.5) {
resolve('成功');
} else {
reject(new Error('失败'));
}
}, 1000);
});
```

```
// 处理 Promise 的结果
promise.then((value) => {
console.log(value);
}).catch((error) => {
console.error(error);
```

```
⻥皮补充：这题可以多说说自己在项目中是如何运用 promise 的
```

#### ⻥友的精彩回答

**useGieGie 的回答**

ES6 中的 Promise 是一种用于处理异步操作的机制，它可以更加优雅地处理异步操作，避免了回调地狱的问题。在
JavaScript 中，Promise 对象代表一个异步操作的最终状态（成功或失败），并且可以链式调用。

Promise 的三种状态：

```
Pending（进行中）：初始状态，不是成功也不是失败。
Fulfilled（已成功）：操作成功完成，返回结果。
Rejected（已失败）：操作失败，返回错误信息。
```

Promise 对象提供了 then 方法，可以将异步操作成功的回调函数和失败的回调函数注册到 Promise 对象上，当
Promise 对象状态变为 Fulfilled 或 Rejected 时，会自动调用对应的回调函数。

Promise 的使用场景有很多，比如：

```
Ajax 请求：Promise 可以用于异步获取数据，当数据请求成功时，调用 Promise 的 resolve 方法，否则调用
reject 方法。
定时器：Promise 可以结合定时器一起使用，实现定时器的延时操作。
图片加载：Promise 可以用于图片的异步加载，当图片加载成功时，调用 Promise 的 resolve 方法，否则调
用 reject 方法。
异步编程：Promise 可以帮助开发者更好地处理异步编程，避免了回调地狱的问题。
```

需要注意的是，Promise 的 then 方法是异步执行的，也就是说，当 Promise 对象状态变为 Fulfilled 或 Rejected
时，then 方法中的回调函数并不是立即执行，而是放入微任务队列中，在 JavaScript 主线程执行栈为空时，才会
被调用执行。

除了 then 方法外，Promise 还提供了一些其他方法：

1. catch 方法：捕获 Promise 对象的错误信息，相当于 then(null, onRejected)。
2. finally 方法：无论 Promise 对象状态如何，finally 方法总是会执行，通常用于资源清理等操作。
3. Promise.all 方法：接收一个 Promise 对象数组，当所有 Promise 对象状态都变为 Fulfilled 时，返回一个
   Promise 对象，状态为 Fulfilled，并携带所有 Promise 对象的结果；当有任意一个 Promise 对象状态变为
   Rejected 时，返回的 Promise 对象状态变为 Rejected，并携带第一个 Promise 对象的错误信息。
4. Promise.race 方法：接收一个 Promise 对象数组，当其中任意一个 Promise 对象状态变为 Fulfilled 或
   Rejected 时，返回一个 Promise 对象，状态为对应 Promise 对象的状态，并携带对应 Promise 对象的结果
   或错误信息。

通过这些方法，可以更加方便地处理异步编程的问题。需要注意的是，Promise 也有一些缺点，比如无法取消
Promise，一旦创建就会立即执行，无法处理同步操作等。

##### });

**Kristen 的回答**

所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可
以用同样的方法进行处理。

Promise 对象有以下两个特点。

（ 1 ）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled
（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变
这个状态。

（ 2 ）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从
pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持
这个结果 Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，
由 JavaScript 引擎提供，不用自己部署。

resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作
成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变
为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出
去。 Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。 then 方法返回
的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。

因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。

上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入
第二个回调函数。

```
getJSON("/posts.json").then(function(json) {
return json.post;
}).then(function(post) {
// ...
});
```

```
const promise = new Promise(function(resolve, reject) {
// ... some code
```

```
if (/* 异步操作成功 */){
resolve(value);
} else {
reject(error);
}
});
promise.then(function(value) {
// success
}, function(error) {
// failure
```

then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回
调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接
受 Promise 对象传出的值作为参数。 下面是一个 Promise 对象的简单例子。

上面代码中，timeout 方法返回一个 Promise 实例，表示一段时间以后才会发生的结果。过了指定的时间（ms 参
数）以后，Promise 实例的状态变为 resolved，就会触发 then 方法绑定的回调函数。

Promise 新建后就会立即执行。

上面代码中，Promise 新建后立即执行，所以首先输出的是 Promise。然后，then 方法指定的回调函数，将在当前
脚本所有同步任务执行完才会执行，所以 resolved 最后输出。

下面是异步加载图片的例子。

##### });

```
function timeout(ms) {
return new Promise((resolve, reject) => {
setTimeout(resolve, ms, 'done');//setTimeout的第三个参数是给第一个函数的参数
});
}
```

```
timeout(100).then((value) => {
console.log(value);
});
```

```
let promise = new Promise(function(resolve, reject) {
console.log('Promise');
resolve();
});
```

```
promise.then(function() {
console.log('resolved.');
});
```

```
console.log('Hi!');
```

```
// Promise
// Hi!
// resolved
```

```
function loadImageAsync(url) {
return new Promise(function(resolve, reject) {
const image = new Image();
```

```
image.onload = function() {
resolve(image);
};
```

上面代码中，使用 Promise 包装了一个图片加载的异步操作。如果加载成功，就调用 resolve 方法，否则就调用
reject 方法。

下面是一个用 Promise 对象实现的 Ajax 操作的例子。

```
image.onerror = function() {
reject(new Error('Could not load image at ' + url));
};
```

```
image.src = url;
});
}
```

```
const getJSON = function(url) {
const promise = new Promise(function(resolve, reject){
const handler = function() {
if (this.readyState !== 4) {
return;
}
if (this.status === 200) {
resolve(this.response);
} else {
reject(new Error(this.statusText));
}
};
const client = new XMLHttpRequest();
client.open("GET", url);
client.onreadystatechange = handler;
client.responseType = "json";
client.setRequestHeader("Accept", "application/json");
client.send();
```

```
});
```

```
return promise;
};
```

```
getJSON("/posts.json").then(function(json) {
console.log('Contents: ' + json);
}, function(error) {
console.error('出错了', error);
});
```

### 4 、ES6 中的 Reflect 对象有什么用？

#### 官方解析

在 ES6 中，Reflect 对象是一个内置的对象，提供了一组用于操作对象的方法。它的作用是对对象的某些操作进行
拦截和修改，从而提供更加灵活和强大的对象操作方式。

以下是一些 Reflect 对象的常用方法和用途：

1. Reflect.get(target, property, receiver)：读取对象的属性值。与对象的点运算符和方括号运算符相比，这个
   方法提供了更加灵活和可控的属性读取方式。
2. Reflect.set(target, property, value, receiver)：设置对象的属性值。与对象的点运算符和方括号运算符相比，
   这个方法提供了更加灵活和可控的属性设置方式。
3. Reflect.has(target, property)：检查对象是否具有指定的属性。与 in 运算符相比，这个方法提供了更加灵活
   和可控的属性检查方式。
4. Reflect.deleteProperty(target, property)：删除对象的属性。与 delete 运算符相比，这个方法提供了更加灵
   活和可控的属性删除方式。
5. Reflect.construct(target, argumentsList[, newTarget])：使用给定的参数列表创建对象。与 new 运算符相
   比，这个方法提供了更加灵活和可控的对象创建方式。
6. Reflect.apply(target, thisArgument, argumentsList)：调用对象的方法。与函数调用运算符相比，这个方法
   提供了更加灵活和可控的方法调用方式。

除了上述方法之外，Reflect 对象还提供了许多其他的方法，例如 Reflect.defineProperty、
Reflect.getOwnPropertyDescriptor、Reflect.getPrototypeOf、Reflect.setPrototypeOf 等，都可以用于对对象
进行拦截和修改。

总之，Reflect 对象提供了一组灵活和强大的对象操作方法，可以用于实现代理、拦截、元编程等功能，使
JavaScript 更加强大和灵活。

#### ⻥友的精彩回答

**luckythus 的回答**

**ES6 中的 Reflect 对象有什么用？**

Reflect 对象是一个内置对象，它提供了一组用于操作对象的方法

1. 简化了操作对象：Reflect 方 法是函数式的，与 Object 方法是命令式的不同
2. Reflect 方法的返回值更加明确，定义属性成功后直接返回布尔值来表示是否设置成功，而
   Object.defineProperty()会返回 obj

```
const person = { name: 'Tom' }
const objName = Object.getOwnPropertyDescriptor(person,'name').value
const reflectName = Reflect.get(person,'name')
console.log(objName) // 'Tom'
console.log(reflectName) // 'Tom'
```

3. 统一了对象操作的 API：通过 Reflect 方法可以操作对象的属性，与 Object 方 法基本类似
4. 与 Proxy 对象进行配合使用：Reflect 对象和 Proxy 对象配合使用，可以实现拦截对象操作，例如使用
   Reflect.get()方法获取被代理对象的属性，在获取属性值之前可以先进行一些拦截操作，从而实现拦截对象操
   作的效果
5. Reflect 内置对象里面还有许许多多的方法 API，Reflect 对象提供了许多灵活和强大的对象操作方法

##### 其他回答

Reflect 可以用于获取目标对象的行为，他与 Objectl 类似，但是更易读，为操作对象提供了一种更优雅的方式，它
的方法与 Proxy 是对应的。

**代替 Object 的某些方法**

**修改某些 Object 方法的返回结果**

```
const person = { name: 'Tom'}
const result1 = Object.defineProperty(person,'gender',{
value: 'man',
writable: false,
enumerable: true,
configurable: true
})
const result2 = Reflect.defineProperty(person,'address',{
value: 'Beijing',
writable: false,
enumerable: true,
configurable: true
})
console.log(result1) // 返回对象 {name: 'Tom',gender: 'man'}
console.log(result2) // 返回布尔值 true 表示操作成功
```

```
const obj = { name: 'Tom' }
const proxy = new Proxy(obj,{
get(target,key,receiver) {
console.log(`获取属性${key}`)
return Reflect.get(target,key,receiver)
}
})
console.log(proxy.name)
```

```
const obj = {}
Reflect.defineProperty(obj, "name", {
value:"codexgh",
writable: false
})
```

##### 命令式变为函数行为

**配合 Proxy 使用：**

##### // 老写法

```
try {
Object.defineProperty(target, property, attributes);
}catch(e) {
// fail
}
```

```
// 新写法
if(Reflect.defineProperty(target, property, attributes)){
// success
} else {
// fail
}
```

```
const obj1 = {
name: "codexgh",
}
// 老写法
console.log("name" in obj1); // true
// 新写法
console.log(Reflect.has(obj1, "name")); // true
```

```
// 老写法
delete obj1.name
// 新写法
Reflect.deleteProperty(obj1, "name")
```

```
const set = new Set();
let proxy = new Proxy(set, {
get(target, key){
// 判断如果是方法，修正this指向
let value = Reflect.get(target, key);
if(value instanceof Function){
return value.bind(target)
}
return value
},
set(){
Reflect.set(...arguments)
}
});
```

##### 作者：编程导航知识星球 + 星球⻥友们

## 浏览器

### 1 、什么是浏览器的同源策略？为什么要有同源策略？

#### 官方解析

同源策略（Same-Origin Policy）是指浏览器安全策略中的一项重要规则，它规定了浏览器只允许当前网⻚的脚本
与来自同一站点（协议、主机、端口号相同）的窗口进行交互，而限制了与不同源（协议、主机、端口号任一不
同）的窗口进行交互。这种限制能够有效保障用户的信息安全和隐私。

同源策略限制了跨域请求、Cookie、LocalStorage、IndexedDB 等跨站点资源的访问，防止恶意网站窃取用户数
据和攻击。同源策略的存在是 Web 安全的重要保障，是浏览器防范跨站脚本攻击（XSS）、跨站请求伪造
（CSRF）等安全威胁的关键措施。

如果需要进行跨域请求或共享数据，可以通过特定的手段（如 JSONP、CORS、代理等）来实现。同时，Web 应用
开发中应当严格遵守同源策略的原则，避免将敏感信息暴露在跨域⻚面中。

```
⻥皮补充：这道题目建议大家可以多讲下自己在项目中遇到的跨域问题、以及是如何解决的
```

#### ⻥友的精彩回答

##### 昼夜暗雨的回答

##### 浏览器同源策略是网景公司出于浏览器安全考虑而制定的策略。同源指的是协议、域名、端口三者均相同，如果三

##### 者中存在有不同之处，而称为跨域。跨域请求会被发送到服务器，但是返回的响应会被浏览器拦截。

##### 同源策略又分为三种：

##### 1. DOM 同源策略

2. XMLHttpRequest 请求同源策略
3. Cookie、LocalStorage 存储同源策略

如果不存在同源策略的限制，则会出现 XSS、CSRF 等 Web 攻击。比如如果用户通过 iframe 引入了其他⻚面，用户在
⻚面中填写了用户名和密码，那么恶意攻击者就可以获取不同源的 DOM 结构，从而获取用户的信息。又比如用户
向网站 A 发送的请求，网站 A 向 Cookie 中添加了用户表示，此时用户访问恶意网站 B，执行了恶意脚本，导致网站 B
向网站 A 发送 Ajax 请求并且携带了网站 A 对应的 Cookie，此时网站 B 就可以从 Cookie 中解析出用户的信息。

```
⻥皮评论：这个例子举的不错
```

### 2 、怎么解决跨域问题？

#### 官方解析

**跨域问题** （Cross-Origin Resource Sharing，CORS）是由于浏览器的 **同源策略** （Same-Origin Policy）导致的。
同源策略指的是， **如果两个 URL 的协议、主机名和端口号都相同，那么它们就是同源的，否则就是跨域的** 。当网
⻚发起跨域请求时， **浏览器会根据同源策略限制请求** 。解决跨域问题的方法有以下几种：

**JSONP（JSON with Padding）**

JSONP 是一种 **跨域请求数据** 的方式，它利用了 <script> 标签不受同源策略限制的特性，可以从不同的域名请求数
据。实现原理是在服务端生成一个 JavaScript 函数，客户端使用 <script> 标签请求该函数，服务端返回该函数的调
用，并将需要传输的数据作为函数参数传入。

**CORS（Cross-Origin Resource Sharing）**

CORS 是一种通过 **添加一些 HTTP 头** 来允许浏览器 **跨域访问资源** 的机制，主要是服务端配置。服务端需要在响应头
中添加 **Access-Control-Allow-Origin** 和其他一些参数，指示允许哪些域名进行跨域请求。

**反向代理**

反向代理是 **将客户端的请求转发到真正的服务端** ，从而解决跨域问题。反向代理服务器和真正的服务端在 **同一个域
名下** ，客户端的请求只需要向反向代理服务器发起，由反向代理服务器将请求转发到真正的服务端，最后将响应返
回给客户端。

**WebSocket**

WebSocket 是一种在单个 TCP 连接上进行 **全双工通信** 的协议，可以用于 **跨域通信** 。由于 **WebSocket 协议并不受
同源策略的限制** ，因此可以实现跨域通信。

总的来说，不同的解决方案有各自的优缺点，应根据实际情况选择最适合的方式。例如，如果需要在客户端和服务
端之间进行 **实时通信** ， **WebSocket 是最佳选择** ；如果只需要在客户端发起 **简单的 GET 请求** ，可以使用 **JSONP 等**
方式。

```
⻥皮补充：这题在回答时可以先把解决方案分为两类：服务端解决和客户端解决
```

#### ⻥友的精彩回答

##### ' 的回答

##### 解决跨域的方法有以下几种：

1.jsonp：利用 script 标签不受浏览器跨域的影响，前端通过 src 属性将回调函数和请求参数拼接在请求 url 地址后面
并发送给后端，后端通过拼接请求数据和回调函数一并返回给前端，前端通过执行回调函数拿到请求数据。所以
jsonp 解决的跨域问题具有很明显的不足，它只能实现 get 方法的请求。对于 post put delete 等其它请求无法实
现。 具体代码实现：

2.Nginx 代理实现：

3.CORS 服务器配置：配置 Access-Control-Allow-Origin 为\*（所有源）或允许访问的域名/ip 地址，Access-
Control-Allow-Method 配置请求方法，这是最为常⻅解决跨域的方法。

4.WebSocket 协议通讯：利用 HTML5 提供的新协议，实现浏览器与服务器的 **全双工通信** ，从而解决浏览器的跨域
问题。

具体实现：

// 后端 nodejs

##### // 前端

```
<script src="https://xxx.com/getUserInfo?id=212&callback=getUserInfoRes"></script>
const getUserInfoRes = ({userName}) => {
console.log(userName)
}
```

```
// 后端 这里用 express 来模拟
app.get('/getUserInfo', (req, res) => {
const {id, callback} = req.query
const res = db.query('...', id, (err, res) => {
res.send(`callback(res.data)`)
})
})
```

##### {

```
listen 80
```

```
add_header Access-Control-Allow-Origin *;
add_header Access-Control-Headers X-Requested-With;
add_header Access-Control-Allow-Methods GET,POST,OPTIONS
location / {
proxy_pass http://www.domain.com:8080;
}
}
```

##### // 前端

```
const socket = new WebSocket('http://www.domain.com:8080')
socket.addEventListener('open', function () {
socket.send('...')
})
socket.addEventListener('message', function(e) {
console.log(e.data)
})
```

**mos 的回答**

跨域问题（Cross-Origin Resource Sharing，CORS）是由于浏览器的同源策略（Same-Origin Policy）导致的。
同源策略指的是，如果两个 URL 的协议、主机名和端口号都相同，那么它们就是同源的，否则就是跨域的。当网
⻚发起跨域请求时，浏览器会根据同源策略限制请求。解决跨域问题的方法有以下几种：

**1.JSONP**

因为浏览器同源策略的存在，导致存在跨域问题，以下这三个标签加载资源路径是不受束缚的

而 JSONP 就是利用了 script 的 src 加载不受束缚，从而可以拥有从不同的域拿到数据的能力，但是 JSONP 需要前端后
端配合，才能实现最终的跨域获取数据。

JSONP 通俗点说就是：利用 script 的 src 去发送请求，将一个方法名 callback 传给后端，后端拿到这个方法名，将所
需数据，通过字符串拼接成新的字符串 callback(所需数据),并发送到前端，前端接受到这个字符串之后，就会自动
执行方法 callback(所需数据)

前端代码

```
const WebSocket = require('ws')
const server = new WebSocket.Server({post: 8080})
server.addEventListener('connection', function(socket) {
socket.addEventListener('message', function(res) {
socket.send(res)
})
})
```

1. script 标签：<script src="加载资源路径"></script>
2. link 标签：<link herf="加载资源路径"></link>
3. img 标签：<img src="加载资源路径"></img>

```
// index.html http://127.0.0.1:5500/index.html
```

```
const jsonp = (url, params, cbName) => {
return new Promise((resolve,reject) => {
const script = document.createElement('script')
window[cbName] = (data) => {
resolve(data)
```

##### 后端代码

JSONP 的缺点就是，需要前后端配合，并且只支持 get 请求方法

**2.WebSocket**

WebSocket 根本不附属于同源策略，而且它本身就有意被设计成可以跨域的一个手段。由于历史原因，跨域检测一
直是由浏览器端来做，但是 WebSocket 出现以后，对于 WebSocket 的跨域检测工作就交给了服务端，浏览器仍然
会带上一个 Origin 跨域请求头，服务端则根据这个请求头判断此次跨域 WebSocket 请求是否合法

```
document.body.removeChild(script)
}
params = { ...params, callback：cbName }
const str = Object.keys(params).map(key => `${key}=${params[key]}`)
script.src = `${url}?${str.join('&')}`
document.body.appendChild(script)
})
}
```

```
jsonp('http://127.0.0.1:8000',{ name:'mos', age:18},'callback').then(data => {
console.log(data) // mos今年 18 岁了!!!
})
```

```
// index.js http://127.0.0.1:8000
const http = require('http');
const urllib = require('url');
```

```
const port = 8000;
```

```
http.createServer(function(req,res){
const { query } = urllib.parse(req.url,true);
if(query && query.callback){
const { name, age, callback } = query
const person = `${name}今年${age}岁了!!!`
const str = `${callback}(${JSON.stringify(person)})` //拼成callback(data)
res.end(str)
}else{
res.end(JSON.stringify('没东⻄啊你'));
}
}).listen(port,function(){
console.log('server is listening on port ' + port);
})
```

##### 前端代码

##### 后端代码

**3.Cors**

Cors，全称 Cross-Origin Resource Sharing,意思是跨域资源共享，Cors 一般是由后端来开启的，一旦开启，前端
就可以跨域访问后端。

```
// index.html http://127.0.0.1:5500/index.html
function myWebsocket(url,params){
return new Promise((resolve,reject)=>{
const socket = new WebSocket(url)
socket.onopen = () => {
socket.send(JSON.stringify(params))
}
socket.onmessage = (e) => {
resolve(e.data)
}
})
}
myWebsocket('ws://127.0.0.1:8000',{ name:'mos', age:18 }).then(data=>){
console.log(data) // mos今年 18 岁了!!!
}
```

```
// index.js http://127.0.0.1:8000
const Websocket = require('ws');
```

```
const port = 8000;
const ws = new Websocket.Server({ port })
ws.on('connection',(obj) =>{
obj.on('message',(data) =>{
data = JSON.parse(data.toString())
const { name, age } = data
obj.send(`${name}今年${age}岁了!!!`)
})
})
```

前端跨域访问到后端，后端开启 Cors，发送 Access-Control-Allow-Origin:域名字段到前端(其实不止一个)，前端浏
览器判断 Access-Control-Allow-Origin 的域名如果跟前端域名一样，浏览器就不会实行跨域拦截，从而解决跨域问
题。

##### 后端代码

##### 4.反向代理

Node 接口代理

##### 前端代码

```
// index.html http://127.0.0.1:5500/index.html
// 步骤一：创建异步对象
var ajax = new XMLHttpRequest();
// 步骤二：设置请求的url参数，参数一是请求的类型，参数二是请求的url，可以带参数
ajax.open('get','http://127.0.0.1:8000?name=林三心&age=23');
// 步骤三：发送请求
ajax.send();
// 步骤四：注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechang = function(){
if(ajax.readyState == 4 && ajax.status == 200){
// 步骤五 如果能够进到这个判断 说明数据完美的回来了，并且请求的⻚面是存在的
console.log(ajax.responseText);
}
}
```

```
// index.js http://127.0.0.1:8000
```

```
const http = require('http');
const urllib = require('url');
```

```
const port = 8000;
```

```
http.createServer(function(req,res){
// 开启Cors
res.writeHead(200,{
// 设置允许跨域的域名，也可设置*允许所有域名
'Access-Control-Allow-Origin': 'http://127.0.0.1.5500',
// 跨域允许的请求方法，也可以设置*允许所有方法
"Access-Control-Allow-Methods": 'DELETE,PUT,POST,GET,OPIIONS',
// 允许的header类型
'Access-Contorl-Allow-Headers': 'Content-Type'
})
const { query : { name, age } } = urllib.parse(req.url, true);
res.end(`${name}今年${age}岁啦！！！`);
}).listen(port,function(){
console.log('server is listening on port ' + port);
})
```

##### 同源策略它只是浏览器的一个策略而已，它是不限制后端的，也就是前端-后端会被同源策略限制，但是后端-后端

则不会被限制，所以可以通过 Node 接口代理，先访问已设置 Cors 的后端 1 ，再让后端 1 去访问后端 2 获取数据到后
端 1 ，后端 1 再把数据传到前端

前端代码

##### 后端 1 代码

```
// index.html http://127.0.0.1:5500
```

##### //步骤一:创建异步对象

```
var ajax = new XMLHttpRequest();
//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数
starName到服务端
ajax.open('get', 'http://127.0.0.1:8888?name=mos&age=18');
//步骤三:发送请求
ajax.send();
//步骤四:注册事件 onreadystatechange 状态改变就会调用
ajax.onreadystatechange = function () {
if (ajax.readyState == 4 && ajax.status == 200) {
//步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的⻚面是存在的
console.log(ajax.responseText);//输入相应的内容
}
}
```

```
// index2.js http://127.0.0.1:8888
```

```
const http = require('http');
const urllib = require('url');
const querystring = require('querystring');
const port = 8888;
```

```
http.createServer(function (req, res) {
// 开启Cors
res.writeHead(200, {
//设置允许跨域的域名，也可设置*允许所有域名
'Access-Control-Allow-Origin': 'http://127.0.0.1:5500',
//跨域允许的请求方法，也可设置*允许所有方法
"Access-Control-Allow-Methods": "DELETE,PUT,POST,GET,OPTIONS",
//允许的header类型
'Access-Control-Allow-Headers': 'Content-Type'
})
const { query } = urllib.parse(req.url, true);
const { methods = 'GET', headers } = req
const proxyReq = http.request({
host: '127.0.0.1',
port: '8000',
path: `/?${querystring.stringify(query)}`,
methods,
```

##### 后端 2 代码

**Nginx**

其实 Nginx 跟 Node 接口代理是一个道理，只不过 Nginx 就不需要我们自己去搭建一个中间服务

**5.postMessage**

场景：http://127.0.0.1:5500/index.html ⻚面中使用了 iframe 标签内嵌了http://127.0.0.1:5555/index.html 的⻚
面

虽然这两个⻚面存在于一个⻚面中，但是需要 iframe 标签来嵌套才行，这两个⻚面之间是无法进行通信的，因为他
们端口号不同，根据同源策略，他们之间存在跨域问题

那应该怎么办呢？使用 postMessage 可以使这两个⻚面进行通信

```
headers
}, proxyRes => {
proxyRes.on('data', chunk => {
console.log(chunk.toString())
res.end(chunk.toString())
})
}).end()
}).listen(port, function () {
console.log('server is listening on port ' + port);
})
```

```
// index.js http://127.0.0.1:8000
```

```
const http = require('http');
const urllib = require('url');
```

```
const port = 8000;
```

```
http.createServer(function (req, res) {
console.log(888)
const { query: { name, age } } = urllib.parse(req.url, true);
res.end(`${name}今年${age}岁啦！！！`)
}).listen(port, function () {
console.log('server is listening on port ' + port);
})
```

```
server{
listen 8888;
server_name 127.0.0.1;
```

```
location /{
proxy_pass 127.0.0.1:8000;
}
}
```

### 3 、浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？

#### 官方解析

##### 浏览器的本地存储方式主要有以下几种：

1. Cookie：Cookie 是浏览器中最古老的本地存储方式，它可以存储少量的文本数据，并在之后的 HTTP 请求中
   自动携带发送给服务器。Cookie 可以设置过期时间，也可以设置作用域（只在特定域名或路径下有效）。 应
   用场景：一般用于存储会话信息、用户偏好设置等少量的文本数据。
2. LocalStorage：LocalStorage 是 HTML5 新增的本地存储方式，可以存储较大量的数据，数据保存在浏览器
   本地且不会过期，除非手动删除或清除缓存。 应用场景：适用于存储用户个性化数据、本地数据缓存等。
3. SessionStorage：SessionStorage 也是 HTML5 新增的本地存储方式，与 LocalStorage 类似，但是数据只在
   会话期间有效，会话结束或关闭浏览器后数据会被清除。 应用场景：适用于需要短期保存数据的场景，如表
   单数据暂存、⻚面数据缓存等。
4. IndexedDB：IndexedDB 是 HTML5 中的一个本地数据库存储方案，可以存储大量结构化数据，支持事务处
   理和索引查找，功能比较强大。 应用场景：适用于需要离线存储数据、本地数据库操作等。
5. Web SQL：Web SQL 是 HTML5 中的另一种本地数据库存储方案，采用 SQL 语句进行数据存储和查询，但是
   目前已经被弃用，不建议使用。 应用场景：类似于 IndexedDB，适用于需要离线存储数据、本地数据库操作
   等。

不同的本地存储方式适用于不同的场景，选择合适的方式可以提高用户体验和网站性能。

```
// http:127.0.0.1:5500/index.html
```

```
<body>
<iframe src="http://127.0.0.1:5555/index.html" id="frame"></iframe>
</body>
<script>
document.getElementById('frame').onload = function () {
this.contentWindow.postMessage({ name:'mos', age:18 }, 'http://127.0.0.1:5555')
window.onmessage = function (e) {
console.log(e.data) // mos今年 18 岁啦！！！
}
}
</script>
```

```
// http://127.0.0.1:5555/index.html
<script>
window.onmessage = function (e) {
const { data: { name, age }, origin } = e
e.source.postMessage(`${name}今年${age}岁啦！！！`, origin)
}
</script>
```

#### ⻥友的精彩回答

**codexgh 的回答**

**ES6 中的 Reflect 对象有什么用？**

我么来看看常⻅的浏览器的本地存储方式：localStorage、sessionStorage、indexedDB、Cookies

**webStorage：**

**localStorage:**
用于存储持久数据，除非用户手动将其从浏览器中删除，否则数据经终身存储，即使用户关闭窗口后选项卡，他也
不会过期

**sessionStorage：**
用户存储临时会话数据，⻚面重新加载后数据仍然存在，当关闭浏览器或选项卡时数据就会丢失；

**方法和属性：**

● setItem() ：用于存储数据，它有两个参数，即 key 和 value。使用形式：localStorage.setItem(key, value)；
● getItem()：用于获取数据，它接受一个参数 key，即需要访问其值的键。使用形式：localStorage.getItem(key);
● removeItem()：用于删除数据，它接受一个参数 key，即需要删除其值的键。使用形式：
localStorage.removeItem(key);
● clear() ：用于清除其中存储的所有数据，使用形式：localStorage.clear();
● key()：该方法用于获取 localStorage 中数据的所有 key，它接受一个数字作为参数，该数字可以是 localStorage
项的索引位置。 localStorage 和 sessionStorage 都非常适合缓存非敏感应用数据，可以再需要存储少量简单值，
它们本质是同步的，并且会阻塞主 UI 线程，所以需要谨慎使用。

**Cookie：**

Cookie 主要用于身份验证和用户数据持久性。Cookie 与请求一起发送到服务器，并在响应时发送到客户端；因
此，cookies 数据在每次请求时都会与服务器交换。服务器可以使用 cookie 数据向用户发送个性化内容。严格来
说，cookie 并不是客户端存储方式，因为服务器和浏览器都可以修改数据。它是唯一可以在一段时间后自动使数据
过期的方式。 每个 HTTP 请求和响应都会发送 cookie 数据。存储过多的数据会使 HTTP 请求更加冗⻓，从而使应
用比预期更慢：
● 浏览器限制 cookie 的大小最大为 4kb，特定域允许的 cookie 数量为 20 个，并且只能包含字符串；
● cookie 的操作是同步的；
● 不能通过 web workers 来访问，但可以通过全局 window 对象访问。 Cookie 通常用于会话管理、个性化以及跨
网站跟踪用户行为。我们可以通过服务端和客户端设置和访问 cookie。Cookie 还具有各种属性，这些属性决定了
在何处以及如何访问和修改它们，

**Cookie 分为两种类型：**

● 会话 Cookie：没有指定 Expires 或 Max-Age 等属性，因此在关闭浏览器时会被删除；
● 持久性 Cookie：指定 Expires 或 Max-Age 属性。这些 cookie 在关闭浏览器时不会过期，但会在特定日期
(Expires) 或时间⻓度 (Max-Age) 后过期。

**IndexedDB：**

IndexedDB 提供了一个类似 NoSQL 的 key/value 数据库，它可以存储大量结构化数据，甚至是文件和 blob。 每
个域至少有 1GB 的可用空间，并且最多可以达到剩余磁盘空间的 60%。

**indexedDB 特点如下：**

● 可以将任何 JavaScript 类型的数据存储为键值对，例如对象（blob、文件）或数组等。
● IndexedDB API 是异步的，不会在数据加载时停止⻚面的渲染。
● 可以存储结构化数据，例如 Date、视频、图像对象等。
● 支持数据库事务和版本控制。
● 可以存储大量数据。
● 可以在大量数据中快速定位/搜索数据。
● 数据库是域专用的，因此任何其他站点都无法访问其他网站的 IndexedDB 存储，这也称为同源策略。

**IndexedDB 使用场景：**

● 存储用户生成的内容： 例如表单，在填写表单的过程中，用户可以离开并稍后再回来完成表单，存储之后就不会
丢失初始输入的数据。
● 存储应用状态： 当用户首次加载网站或应用时，可以使用 IndexedDB 存储这些初始状态。可以是登录身份验
证、API 请求或呈现 UI 之前所需的任何其他状态。因此，当用户下次访问该站点时，加载速度会增加，因为应用已
经存储了状态，这意味着它可以更快地呈现 UI。
● 对于离线工作的应用： 用户可以在应用离线时编辑和添加数据。当应用程序来连接时，IndexedDB 将处理并清
空同步队列中的这些操作。

### 4 、什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？

#### 官方解析

回流（Reflow）和重绘（Repaint）是浏览器渲染过程中的两个关键概念，它们对网⻚性能产生重要影响。理解回
流和重绘以及它们的触发场景有助于我们优化网⻚性能。

回流（Reflow）： 回流是当浏览器需要重新计算元素的布局、尺寸和位置时所发生的过程。回流通常发生在以下
场景：

1. 添加或删除可⻅的 DOM 元素。
2. 元素尺寸发生变化，如宽度、高度、边距、填充等。
3. ⻚面布局发生变化，如改变窗口大小。
4. CSS 伪类激活，如:hover。
5. 计算 offsetWidth、offsetHeight 等属性。

重绘（Repaint）： 重绘是浏览器在元素的外观发生变化，但不影响布局时所发生的过程。重绘通常发生在场景：
改变元素的颜色、背景、边框等样式，但不影响元素尺寸和位置。

减少回流和重绘的方法：

1. 避免频繁操作样式：多次修改样式时，可以使用一个 class 来修改，或者通过修改 style 属性进行批量操作。
2. 避免逐项改变样式：使用 CSS 的 transform、opacity 等属性进行动画，而不是改变宽度、高度、位置等会触
   发回流的属性。
3. 使用文档片段（DocumentFragment）或者 offscreen 元素进行批量操作：在对 DOM 元素进行大量操作
   时，可以先将它们从文档流中移除，然后在内存中进行操作，最后再插入文档流中。
4. 避免使用 table 布局：table 布局中的元素发生回流时，会影响到整个表格，从而导致更多的回流。
5. 对具有复杂动画的元素使用绝对定位：将动画元素脱离文档流，减少回流对其他元素的影响。

6. 避免频繁访问布局信息：如 offsetWidth、offsetHeight 等，可以在访问前将这些值缓存起来，避免多次触发
   回流。

回流和重绘对性能影响较大，尤其是在移动设备上。因此，优化代码以减少回流和重绘次数是提高网⻚性能的重要
手段。

#### ⻥友的精彩回答

**Kristen 的回答**

**回流与重绘**

回流一定会伴随这重绘，但是重绘可以单独发生。

**⻚面渲染过程**

```
解析 html 生成 DOM 树
处理 css 生成 cssom 树
将 dom 树和 cssom 树合并生成 render Tree(渲染树：不包括 display:none，head 节点，但是包括
visibility:hidden 的节点)
根据 render Tree, 得到每个节点的几何信息(位置与大小：margin,padding,width,height 等)
将上面的到的几何信息传送到 GPU进行绘制。
```

**回流(reflow) 与 重绘(repaint)** 回流(reflow): render Tree 中节点的 大小、边距等发生改变时候需要重新计算几何
信息的过程，叫回流 重绘(repaint): 改变元素的字体颜色、背景颜色等 不会影响到⻚面的布局变化，叫做重绘。

简而言之： 影响⻚面布局的需要 回流、重绘； 不会改变⻚面布局的只需要重绘

回流的消耗大（涉及到重新布局，而且一定会伴随着重绘），重绘的消耗小(相对回流)

**引起回流的操作**

```
⻚面初始化渲染
Dom 结构改变：删除、插入元素
改变节点的几何信息：margin/padding/width/height/display:none/border/fontSize
改变窗口的大小（resize）
获取某些属性的值（浏览器会为了获得准确的值也会触发回流的过程)
offsetTop, offsetLeft, offsetWidth, offsetHeight
scrollTop/Left/Width/Heigh
clientTop/Left/Width/Height
width,height
调用了 getComputedStyle(), 或者 IE的 currentStyle
```

减少回流

```
避免逐条样式的改变 ，这样会频繁触发。最好是一次性改变多条，或者通过 class 实现 (浏览器会对回流做优
化，他会等到足够数量的变化发生，在做一次批处理回流)
```

##### 避免循环操作 DOM 元素 ，可以先创建一个元素（文档片段），在这个元素上操作完后再插入⻚面中

##### 读取部分引起回流的属性时可以通过缓存方式将结果保存，尽量不要频繁调用获取。

##### 减少回流的代价 将回流的元素设置成绝对定位、固定定位，如此可使得元素脱离文本流，以达到减少代价的目的

**luckythus 的回答**

**什么是回流和重绘** ？

回流：当渲染树中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变而需要重新构建，就叫做回流（重
排）。每个界面至少需要一次回流（重排）。

**通俗来说就是：当增加或删除 dom 节点，改变元素的尺寸或者触发某些属性，引起⻚面结构改变时，浏览器就会重
新构造 dom 树会重新渲染⻚面，这就是回流；** ⻚面必须要

重绘：一个元素外观改变触发浏览器的行为，浏览器会根据元素的新属性重新回值，使元素呈现新的外观；

**某一个元素的样式改变了，虽然并不影响其在文档流中的位置，但是浏览器就会对元素进行重新绘制，这就是重
绘；**

**什么场景下会触发** ？

回流：任何⻚面布局和几何属性的改变都会触发重排。

重绘：重绘一般发生在 UI 界面；是一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重 新绘
制，使元素呈现新的外观。如 color、backgroundColor、size 等改变元素外观的属性

tip：

回流一定会触发重绘，但是重绘不一定会引起回流。

在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新
绘制受影响的部分到屏幕中，引发重绘。

**怎么减少回流和重绘** ？

1. 尽可能使用 class 类名来修改样式
2. 将需要多次重排的元素，position 属性设为 absolute 或 fixed ，元素脱离了文档流，它的变化不会影响到其
   他元素
3. 不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新；
4. 操作 DOM 时，尽量在低层级的 DOM 节点进行操作;尽可能让局部小部分发生变动
5. 减少 DOM 树的深度：避免在 DOM 树中嵌套过多的层级，这会增加回流的成本。
6. 使用 CSS3 动画 transform 属性来实现平移、旋转、缩放等动画效果，避免使用 position，width，height 等
   属性来实现动画，使用 transform 属性不会影响元素的位置和大小，只会影响元素的绘制

##### 作者：编程导航知识星球 + 星球⻥友们

## Vue

### 1 、说说 Vue 中的 diff 算法

#### 官方解析

Vue 中的 diff 算法是用于更新 Virtual DOM 树，从而实现高效的 DOM 操作。diff 算法会对比新旧两棵 Virtual
DOM 树的差异，然后只更新必要的部分，从而减少 DOM 操作的次数。Vue 中的 diff 算法包括以下几个步骤：

```
新旧节点的比较 diff 算法会首先比较新旧节点是否相同，如果相同，则继续比较子节点；如果不同，则进行
下一步操作。
对子节点进行比较 对新旧节点的子节点进行比较，具体分为以下四种情况：
新节点没有子节点，旧节点有子节点：直接删除旧节点的子节点
旧节点没有子节点，新节点有子节点：直接添加新节点的子节点
新旧节点都有子节点：继续比较子节点
新旧节点都有相同的子节点：对相同的子节点进行递归比较
对旧节点多余的子节点进行删除 如果旧节点的子节点比新节点的子节点多，那么对于多余的子节点，直接进
行删除。
```

在 diff 算法中，由于只更新必要的部分，所以可以大大提高 DOM 操作的效率。这也是 Vue 可以实现高效渲染的重
要原因之一。

#### ⻥友的精彩回答

**luckythus 的回答**

个人浅薄理解，核心点：patch，patchVnode，updateChildren，Vue 优化时间复杂度 O(n)

diff 算法通过比较新旧 VDOM，以最小的代价更新真实的 DOM，由于频繁操作 DOM 开销大，所以使用 js 对象模拟生
成虚拟的 VDOM，在虚拟的 VDOM 操作一次后更新为真实的 DOM

首先，框架将所有的节点先转化为虚拟节点 Vnode，在发生更改后与原本⻚面的旧节点 OldNode 进行比较；如果
tag 和 key 不同，则不进行比较直接替换，如果 tag 和 key 相同，则进行深入比较；深入比较节点的属性，再对节点的
孩子进行逐个比较。

patch 函数是 diff 算法的核心，首先 patch 函数调用 sameNode 函数来对新老节点进行比较，通过比较两个 DOM 的
tag 和 key 是否相同，相同节点则接着调用 patchVnode 函数进行深入比较，先比较它们节点的属性，再比较它们孩
子节点：

1. 如果旧 DOM 无孩子，新 DOM 有，则直接进行添加操作
2. 如果旧 DOM 有孩子，新 DOM 没，则直接进行删除操作
3. 如果旧 DOM 和新 DOM 都有，则调用 updateChildren 函数对它们的孩子节点进行比较

updateChildren：比较新旧节点的孩子列表，有许多种方式

个人浅薄理解的一种：四个指针指向新旧孩子列表的首尾，通过首尾两两比较找到相同的节点，如果有相同的节
点，则移动旧节点的位置，对节点进行复用并移动对应的指针；如果没有相同的节点，则遍历旧孩子列表中与当前
新孩子首节点相同节点，如果找到则可以复用，如果没有找到则创建插入。

diff 算法的核心思想就是尽可能减少操作 DOM 的开销。

**codexgh 的回答**

举一个例子，看 一个 如下的 代码结构：

将第三个 item 修改为：

我们发现，其实只有一个 li 标签修改了文本，其他都是没有变的，所以说没有必要所有的节点都更新一遍，只更新
这个 li 标签 就可以了，Diff 算法就是查出这个 li 标签 的算法；

总结：Diff 算法其实就是一种对比算法。对比的两者是：新旧虚拟 DOM，对比出是哪个 虚拟节点 更改了。找出这
个 虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他没有发生变化的节点数据，实现精确的更
新真实 DOM，进而提高效率。

### 2 、Vue 模板是如何编译的？经历了哪些过程？

#### 官方解析

Vue 模板在运行时会被编译成渲染函数，最终生成 Virtual DOM，进行⻚面渲染。

Vue 模板编译的过程主要分为以下三个步骤：

1. **解析模板** ：Vue 会使用正则表达式解析模板字符串，解析出其中的指令、标签、属性等内容。
2. **生成 AST（抽象语法树）** ：将解析后的模板字符串转化为抽象语法树，抽象语法树是一个以 JavaScript 对象
   表示的树形结构，它将模板中的各个节点和属性用 JavaScript 对象的形式表示出来，方便后续对模板进行分
   析和处理。

```
<ul class="list">
```

```
<li class="item">item1</li>
```

```
<li class="item">item2</li>
```

```
<li class="item">item3</li>
```

```
</ ul>
```

```
<ul class="list">
```

```
<li class="item">item1</li>
```

```
<li class="item">item2</li>
```

```
<li class="item">哈哈哈哈哈 item3</li>
```

```
</ ul>
```

3. **生成渲染函数** ：将 AST 转化为渲染函数，渲染函数是一个纯 JavaScript 函数，用于将模板转化为 Virtual
   DOM。

在模板的编译过程中，还会涉及到动态指令、插槽、组件等特殊情况的处理，不同的编译器实现可能存在一些差
异，但大体的编译流程是相似的。

通过模板的编译，我们可以将模板转化为可被 JavaScript 运行的函数，从而更高效地渲染⻚面，提高应用的性能。

```
⻥皮补充：这题很关键的一个点就是 Vue 最后是转化为 js 来执行的，其他细节的话根据自己的时间来，能了
解多少了解多少吧
```

#### ⻥友的精彩回答

**luckythus 的回答**

Vue 模板编译分为三个阶段：

1. 解析阶段
2. 优化阶段
3. 生成代码阶段

**在解析阶段：**

编译器会将模板解析成一个抽象语法树（AST），对模板进行逐个字符的解析，识别模板中的各种语法，然后将其
转化为 AST 节点，在这个阶段中，Vue 会使用正则表达式匹配模板中的指令，插值表达式、文本等内容，然后将其
转化为 AST 节点，同时再为每个 AST 节点添加对应的属性和指令。

**在优化阶段：**

对生成的 AST 节点进行静态优化，对 AST 节点进行遍历，识别其中不必要的节点，并将其删除。这些不必要的节点
包括：静态文本节点、静态表达式节点等，删除这些节点主要是为了减少运行时 DOM 操作的开销。因为在⻚面渲
染过程中，DOM 操作是一个比较耗费性能的操作，每次进行 DOM 操作都会引起浏览器的重绘和回流，所以删除节
点可以减少 DOM 操作的优化方式，提高⻚面的性能。

**在生成代码阶段：**

这个阶段主要将优化后的 AST 生成可执行的 JavaScript 代码，这个过程是通过对 AST 进行遍历，将 AST 中的每个节点
都转化为相应的 JavaScript 代码，并将其添加到最终的渲染函数中。

生成的渲染函数，接收一个数据对象作为参数，渲染函数中的接收的数据对象一般来自于组件的 props 和 data 属
性。当组件被渲染时，Vue 会根据组件定义中的 props 和 data 属性来生成一个数据对象，然后将这个数据对象传入
渲染函数中，在渲染函数中，会对这个数据对象进行解析和处理，得到虚拟的 DOM 树，接着就涉及到 diff 算法，将
这份虚拟的 DOM 树与上一次渲染的虚拟的 DOM 树进行比较，找出需要更新部分进行更新。

渲染函数里面不执行 diff 算法，只是通过生成虚拟的 DOM 树的方式来描述⻚面结构，diff 算法是在虚拟 DOM 树生成
后，Vue 对比新旧虚拟 DOM 树的过程中执行的。

### 3 、Vue 中 computed 和 watch 区别？分别适用于什么场景？

#### 官方解析

Vue 中的 computed 和 watch 是两种用于响应式数据更新的方法。

computed 是计算属性，它会根据响应式数据的变化自动计算出新的值，并缓存结果，只有在计算属性所依赖的响
应式数据发生改变时才会重新计算。computed 适用于需要根据响应式数据计算得出结果的场景，例如根据商品的
数量和单价计算商品的总价，或者根据选中的过滤条件过滤出数据列表。

watch 是侦听器，它可以监听指定的响应式数据的变化，并在数据发生改变时执行指定的回调函数。watch 适用于
需要执行一些异步或复杂操作的场景，例如监听表单输入框的变化并发送 Ajax 请求，或者监听路由变化并根据路
由参数切换⻚面。

总的来说，computed 适用于计算数据的场景，而 watch 适用于需要执行异步或复杂操作的场景。

```
⻥皮补充：一旦面试官问你应用场景，都是希望你能结合自己项目中的实践经历去说
```

#### ⻥友的精彩回答

**codexgh 的回答**

Vue 中的 computed 和 watch 都是当数据发生变化时去执行对应的逻辑代码：

computed：
computed 计算属性，顾名思义就是如果⻚面中某个地方需要计算某个值其实可以用 computed。

fullName 他的回调函数中有两个依赖的值分别为 firstName 和 lastName，当这两个值发生变化时，就会触发回调
函数的执行，当每次执行完后，会将结果缓存起来，如果下次再去使用这个 fullName 但是所依赖的值没有发生变
化，它会直接返回缓存的值。直到它所依赖的值发生改变时，才回去重新执行回调函数。需要注意的时 computed
必须要有返回值。

watch:
watch 称为侦听器，就是说它会监听一个值的变化，当这个值发生变化时去执行一个对应的逻辑。

```
<template>
<input v-model="firstNum" /> + <input v-model="secondNum" /> = {{ finalValue }}
</template>
```

```
<script setup>
import { ref, computed } from 'vue'
const firstNum = ref(0)
const secondNum = ref(1)
```

```
// 计算属性：
const finalValue = computed(()=>{
return firstNum + secondNum;
})
</script>
```

```
<template>
姓：<input v-model="firstName" />
名：<input v-model="lastName" />
<p> 您的姓名为：{{ fullName }} </>
</template>
```

```
<script setup>
import { ref, watch } from 'vue'
const firstName = ref('')
const lastName = ref('')
const fullName = ref('')
// 侦听器：
watch([firstName, lastName], ([newFirstName, newSecondName], [oldFirstName,
oldSecondName])=>{
fullName.value = newFirstName + newSecondName;
})
</script>
```

##### 总结：

● 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避
免每次获取值时都要重新计算。 ● 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用
watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这
些都是计算属性无法做到的。

### 4 、什么是 Vuex？使用 Vuex 有哪些好处？

#### 官方解析

Vuex 是 Vue.js 框架中用于实现集中式状态管理的插件。它的主要作用是在多个组件之间共享状态，并且提供了一些
工具来方便地管理应用程序的状态。

使用 Vuex 可以将应用程序的状态存储在一个集中的地方，从而使状态管理更加容易、可维护性更高。它还提供了一
些工具来简化状态的更改和操作，例如：在组件中使用 mutations 来修改状态，或者使用 actions 来异步操作数据。

使用 Vuex 的好处包括：

1. 集中化的状态管理：将应用程序的状态集中存储在一个地方，可以方便地进行状态管理和维护。
2. 易于调试：使用 Vuex 可以方便地跟踪和记录状态的更改历史，有助于快速诊断和解决问题。
3. 状态共享：在多个组件之间共享状态，避免了组件之间繁琐的传值，提高了组件之间的解耦性。
4. 插件化：Vuex 提供了插件机制，可以方便地扩展和自定义 Vuex 的功能。

Vuex 的缺点包括：

1. 增加了学习成本：Vuex 相对于直接在组件中管理状态来说，增加了一些学习成本，需要花费时间去学习 Vuex
   的概念和使用方式。
2. 增加了代码复杂度：在使用 Vuex 的过程中，需要增加一些额外的代码来管理状态，有时可能会增加代码的复
   杂度。

```
⻥皮补充：注意，不是说什么情况下都要用 Vuex，要理解【状态管理】的含义。因为有的时候你自己定义一
个全局变量也许就能解决问题
```

#### ⻥友的精彩回答

**mos 的回答**

vuex 的概念

vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态，解决多组件
数据通信。(简单来说就是管理数据的,相当于一个仓库,里面存放着各种需要共享的数据,所有组件都可以拿到里面的
数据)

```
watch是不支持缓存的，只要有数据变化时，就会触发响应的操作，并且watch支持异步监听。监听的回调函数接收两
个参数，第一个参数时最新的值，第二个参数时变化前的值。如果需要在组件加载时就出发回调函数可以使用
immediate属性来设置；如果需要对对象进行深层的监听，可以使用deep属性开启深度监听。
```

使用 Vuex 管理数据的好处：

1 、能够在 vuex 中集中管理共享的数据，易于开发和后期维护；

2 、能够高效地实现组件之间的数据共享，提高开发效率；

3 、存储在 vuex 的数据都是响应式的，能够实时保持数据与⻚面的同步；

##### 你还费解吗的回答

##### 简单的介绍

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。简单理解，Vuex 维护了一个对象，该对象存储了 Vue 应
用中多个组件所需要共同使用的变量，使得组件可以共享它们，当对象中的变量发生变化时，不同组件中使用变量
的地方（视图）也会相应地更新。其中，状态自管理应用包含以下几个部分：

state，驱动应用的数据源；

view，以声明方式将 state 映射到视图；

actions，响应在 view 上的用户输入导致的状态变化。下图为单向数据流示意图：

##### 当应用中遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：

##### 多个视图依赖于同一状态。

##### 来自不同视图的行为需要变更同一状态。

##### 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题

##### 二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷⻉。以上的这些模式非常脆弱，通

##### 常会导致无法维护的代码。

##### 优势

响应式：相比于一个简单的全局对象，Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若
store 中的状态发生变化，那么相应的组件也会进行高效的更新，从而确保了单向数据流的简洁性不被破坏。

集中化管理：Vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取
和修改状态，使代码变得更具结构化且易于维护。

插件式扩展：Vuex 允许开发者编写插件来扩展其功能，比如实现日志记录、持久化存储和调试等。也就是说，开
发者可以根据应用程序的需求来选择性地扩展其功能。

高度集成：由于 Vuex 是专⻔为 Vue.js 设计的，因此可以与 Vue.js 高度集成。在使用 Vuex 的同时，还可以利用
Vue.js 的许多特性，如指令、组件、计算属性等来构建更强大的应用程序。

**应用场景**

如果需要开发大型单⻚应用或应用里需要维护大量全局的状态，就可以使用 Vuex，否则，一个简单的 store 模式
就够了。

**用法**

Vuex 将全局状态放入 state 对象中，它本身是一颗状态树，组件中使用 store 实例的 state 访问这些状态。

然后用配套的 mutation 方法修改这些状态，并且只能用 mutation 修改状态，在组件中调用 commit 方法提交
mutation。

如果应用中有异步操作或复杂逻辑组合，需要编写 action，执行结束如果有状态修改仍需提交 mutation，组件中
通过 dispatch 派发 action。

最后是模块化，通过 modules 选项组织拆分出去的各个子模块，在访问状态（state）时需注意添加子模块的名
称，如果子模块有设置 namespace，那么提交 mutation 和派发 action 时还需要额外的命名空间前缀。

### 5 、Vue Router 的 $route 和 $router 对象有什么区别？

#### 官方解析

在 Vue.js 中，$route 和 $router 都是 Vue Router 提供的对象，但它们的作用不同。

$route 对象代表着当前激活的路由信息，它包含了当前 URL 解析得到的信息，如当前路径、参数、查询参数等。
$route 对象是一个只读对象，我们无法通过改变 $route 对象来改变当前路由。

$router 对象则是 Vue Router 的实例对象，它负责管理整个路由的状态，包括当前路径、路由参数、路由切换
等。$router 对象可以通过编程的方式来改变当前路由，如通过 $router.push()、$router.replace()、$router.go()
等方法。

总的来说，$route 对象是获取当前路由信息的方式，$router 对象则是控制当前路由状态的方式。

#### ⻥友的精彩回答

##### 猫十二懿的回答

$route 对象代表当前激活的路由信息，包含了当前 URL 解析得到的路由参数、查询参数和 hash 值等信息。可以
通过 $route 对象获取当前路由的各种信息，如 $route.params 获取路由参数，$route.query 获取查询参数等。
$route 对象是只读的，即不允许直接修改 $route 对象。

$router 对象则是 Vue Router 全局路由的实例本身，是router构造方法的实例，它提供了一些方法用于编程式地
操作路由，如 $router.push、$router.replace、$router.go 等。通过 $router 对象可以实现在代码中进行路由的
跳转、修改 URL 等操作。

$route 和 $router 的主要区别在于：

$route 是只读的，用于获取当前路由信息；而 $router 是可读写的，用于编程式地操作路由。
$route 是路由组件的属性，可以通过 this.$route 访问；而 $router 是全局的 Vue Router 实例，可以通过
this.$router 访问。

##### 会冒泡的可乐的回答

Vue Router 的 $route 和 $router 对象都是路由相关的对象，它们之间的区别主要在于其作用范围和生命周
期。

$route 对象是当前路由的详细信息，包括路由的 path、params、query、hash 等信息。当路由匹配成功
后，$route 对象会被更新，并且可以通过 this.$route 属性获取到。$route 对象的作用范围是单次路由匹

配，即当路由匹配成功后，$route 对象会被创建，并在路由匹配结束后被销毁。

```
$router 对象是 Vue Router 的实例，它代表了整个路由系统，包含了路由的跳转方法、路由导航守卫等路由相关
```

的方法和属性。当路由创建时，$router 对象会被创建，并在路由创建和销毁的整个生命周期内存在。

### 6 、Vue Router 路由有哪些模式？各模式有什么区别？

#### 官方解析

Vue Router 路由有三种模式：

1. **hash 模式：** 使用 URL 中的 hash（即 # 后面的内容）来作为路由路径。这种模式下，⻚面不会重新加载，只
   会更新 hash 值，并触发路由变化，从而渲染对应的组件。
2. **history 模式：** 使用 HTML5 中新增的 History API 来管理浏览历史记录，从而实现⻚面的前进和后退。在这
   种模式下，URL 中不会带有 # 号，而是使用真实的 URL 路径来作为路由路径。
3. **abstract 模式：** 在不需要基于浏览器的 API 时，可以使用这种模式。在这种模式下，路由器并不会监听 URL
   变化，而是通过调用 router.replace 或 router.push 来进行导航。
   区别：
4. **hash 模式** 可以兼容较老的浏览器，但 URL 中会带有 # 号。
5. **history 模式** 无需带有 # 号，更加美观，但需要后端支持，否则刷新⻚面会导致 404 错误。
6. **abstract 模式** 主要用于一些特定场景，例如在使用 Node.js 时，可以使用 abstract 模式来构建路由。
   一般来说，如果需要支持较老的浏览器，或者不需要后端支持，可以使用 hash 模式；否则建议使用 history
   模式。

#### ⻥友的精彩回答

##### 猫十二懿的回答

Vue Router 路由有三种模式：hash 模式、history 模式和 abstract 模式。

```
区别 hash模式 history模式 abstract模式
```

##### URL

##### 格式

```
URL 中带有 #，如：http://e
xample.com/#/home
```

##### URL 中没有 #，而是直接使用

```
path,如：http://example.com/
home
```

##### 没有真实的 URL，只使用虚

```
拟路径，如：/home
```

##### 浏览

##### 器兼

##### 容性

##### 兼容性好，支持所有浏览器

##### 需要 HTML5 支持，不支持 IE9

##### 及以下版本

##### 无浏览器兼容问题

##### 服务

##### 端配

##### 置

##### 不需要进行额外配置，可以

##### 直接在前端中使用

##### 需要服务器端进行配置，防止

##### 404

##### 不需要服务端配置

##### SEO

##### 不利于 SEO，因为搜索引擎

##### 不会爬取 URL 中的 # 后面的

##### 内容

##### 对 SEO 更加友好，因为路径更

##### 加规范

##### 不利于 SEO

##### 使用

##### 场景

##### 不需要考虑浏览器兼容性和

##### 服务端配置，适用于简单应

##### 用场景

##### 需要考虑 SEO 和更规范的 URL

##### 地址，适用于较复杂应用场景

##### 非浏览器环境下的应用程序

##### 或者只需要使用编程式导航

##### 的情况

一般情况下，我们建议使用 history 模式，因为它对 SEO 更加友好、URL 更加规范，并且随着 HTML5 技术的普
及，浏览器兼容性也不再是问题。但是在特定场景下，如需要支持 IE9 及以下浏览器，或者不方便进行服务端配置
时，可以选择使用 hash 模式。而 abstract 模式则适用于一些特殊的场景，如非浏览器环境下的应用程序或者只需
要使用编程式导航的情况。

##### 作者：编程导航知识星球 + 星球⻥友们

## React

### 1 、React 中的路由懒加载是什么？原理是什么？

#### 官方解析

React 中的路由懒加载指的是在使用 React Router 进行⻚面路由时，将⻚面组件按需加载，而不是一次性加载所
有⻚面组件。这可以提高⻚面加载速度和性能，尤其在⻚面中有大量组件的情况下更为明显。

路由懒加载的原理是基于 ES6 的动态 import 特性，通过在 Webpack 打包时使用 React.lazy() 和 Suspense 进行
懒加载，当路由被匹配时才会加载对应的组件，而不是一次性加载所有路由组件，从而减少⻚面加载时间和网络带
宽的消耗。

下面是一个使用路由懒加载的例子：

```
import React, { lazy, Suspense } from 'react';
```

#### ⻥友的精彩回答

##### 一的回答

React 的路由懒加载是一种定义路由组件为函数的技术。路由组件只在需要时加载,通过代码拆分和按需加载提高加
载速度和性能。

优点

```
懒加载减少初始加载时间和提高加载速度,通过拆分代码到更小的块并按需加载。
它减少初始包大小,提高用户体验和减少资源加载。
```

通过拆分代码,初始加载时间减少和加载速度提高。只有在访问其路由时,路由组件才会被调用,从而实现懒加载。
import() 返回 Promise,允许在 then() 中获得模块对象。Webpack 识别动态导入语法并执行代码拆分。

React Router v4/v5 支持路由懒加载。对于有许多路由组件的较大项目,使用路由懒加载可以减少初始包大小和提高
用户体验。但是,它需要捆绑器,如 Webpack 或 Browserify。

这里是一个路由懒加载的例子:

```
import { Route, Switch } from 'react-router-dom';
```

```
const Home = lazy(() => import('./components/Home'));
const About = lazy(() => import('./components/About'));
const Contact = lazy(() => import('./components/Contact'));
```

```
function App() {
return (
<div>
<Suspense fallback={<div>Loading...</div>}>
<Switch>
<Route exact path="/" component={Home} />
<Route path="/about" component={About} />
<Route path="/contact" component={Contact} />
</Switch>
</Suspense>
</div>
);
}
```

```
export default App;
```

总之,React 懒加载是优化前端性能的有效技术,值得在 React 项目中广泛采用。

##### 昼夜暗雨的补充

谈谈对 Vue 中使用到的懒加载的理解：

懒加载出现原因：Vue 用于开发单⻚面应用，如果没有采用路由懒加载，则 webpack 打包时会形成一个大的 js 文
件，将所有⻚面都放在一个 js 文件中会影响加载速度，所以需要采用懒加载的方式对⻚面进行划分，只有在访问⻚
面时对应的组件才会加载。

想要实现懒加载必须要保证子组件是一个单独的模块，这样才能和其他组件区分开，这点可以借助 webpack 中的
import() 来实现，另外由于函数只有在调用时才会执行其中的代码，所以可以借助函数来实现延迟执行子模块的加
载代码.

### 2 、你常用的 React Hooks 有哪些?

#### 官方解析

React Hooks 是 React 16.8.0 引入的一个新特性，它可以让我们在函数组件中使用 state、生命周期等特性，不再
需要使用类组件。我常用的 React Hooks 包括：

1. useState：用于在函数组件中使用 state，可以通过调用 useState 方法来设置初始值，返回一个数组，包含
   当前的 state 值和一个更新 state 值的函数。
2. useEffect：用于在函数组件中使用生命周期，可以通过调用 useEffect 方法来实现 componentDidMount、
   componentDidUpdate 和 componentWillUnmount。
3. useContext：用于在函数组件中使用 context，可以通过调用 useContext 方法来获取 context 的值。
4. useRef：用于在函数组件中使用 ref，可以通过调用 useRef 方法来创建一个 ref 对象，可以用于获取组件的
   DOM 元素或保存一个值，在组件重新渲染时不会改变。
5. useMemo：用于在函数组件中使用记忆化计算，可以通过调用 useMemo 方法来缓存计算结果，避免重复计
   算。
6. useCallback：用于在函数组件中使用记忆化函数，可以通过调用 useCallback 方法来缓存函数，避免重复创
   建函数。

这些 Hooks 非常方便，能够大大简化我们编写 React 代码的过程，提高开发效率。

```
const Home = lazy(() => import('./Home'));
```

```
const RouterComponent = () => (
<Suspense fallback={<div>Loading...</div>}>
<Switch>
<Route exact path="/" component={Home} />
// ...
</Switch>
</Suspense>
);
```

```
⻥皮补充：这题可以结合自己的项目经验去说一说你在什么时候会用哪些 hooks？
```

#### ⻥友的精彩回答

##### 九仞的回答

React 为函数组件提供了一些 React Hooks，来让函数组件也能拥有类组件的一些特性。

常用 Hooks

```
useState 在函数中使用state
useEffect 用于在函数组件中使用生命周期
useContext 不使用组件嵌套就可以订阅 React 的 Context
useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象
在组件的整个生命周期内保持不变。
useMemo 返回一个memoized值。，它仅会在某个依赖项改变时才重新计算，有助于避免在每次渲染时都进
行高开销的计算。
useCallback 返回一个memoized回调函数。把内联回调函数及依赖项数组作为参数传入 useCallback，它将
返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。
```

**部分用法示例**

useState

首先看他在 type.d.ts 中的原型

##### 可以推测出他的用法为

其中 var 为变量名，setVar 为设置 var 的回调函数，修改 var 的值都需要通过该回调函数。

initValue 为 var 的初始值。

```
// Unlike the class component setState, the updates are not allowed to be partial
type SetStateAction<S> = S | ((prevState: S) => S);
// this technically does accept a second argument, but it's already under a deprecation
warning
// and it's not even released so probably better to not define it.
type Dispatch<A> = (value: A) => void;
/**
* Returns a stateful value, and a function to update it.
*
* @version 16.8.0
* @see https://reactjs.org/docs/hooks-reference.html#usestate
*/
useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
```

```
const [var, setVar] = useState(initValue);
```

##### 示例

##### 测试输出

useEffect

还是看他的原型

##### 示例

```
export const DemoComponent: React.FC = () => {
const [time, setTime] = useState([new Date().toString()]);
return <div>{time}</div>;
};
```

```
Fri Mar 03 2023 19:02:05 GMT+0800 (China Standard Time)
```

```
// NOTE: callbacks are _only_ allowed to return either void, or a destructor.
type EffectCallback = () => (void | Destructor);
type DependencyList = ReadonlyArray<unknown>;
/**
* Accepts a function that contains imperative, possibly effectful code.
*
* @param effect Imperative function that can return a cleanup function
* @param deps If present, effect will only activate if the values in the list change.
*
* @version 16.8.0
* @see https://reactjs.org/docs/hooks-reference.html#useeffect
*/
function useEffect(effect: EffectCallback, deps?: DependencyList): void;
```

```
export const DemoComponent: React.FC = () => {
const [count, setCount] = useState(0);
useEffect(() => {
return () => {
console.log('unMounted');
};
}, []);
useEffect(() => {
console.log('count++');
}, [count]);
return (
<div>
<button onClick={() => setCount(count + 1)}>Count {count}</button>
</div>
);
};
```

其中以下代码可以被用作 onMount 和 unMount 生命周期函数

### 3 、React 组件间怎么进行通信？

#### 官方解析

React 组件间通信可以通过以下方式实现：

1. Props 传递：父组件可以通过 Props 将数据传递给子组件，从而实现数据通信。
2. Context：Context 是 React 提供的一种组件间通信的机制，可以通过 Context 在组件树中传递数据，避免
   Props 层层传递的麻烦。
3. Refs：Refs 允许我们直接操作组件实例或者 DOM 元素，从而实现组件间通信。
4. 自定义事件：可以通过自定义事件的方式实现组件间的通信。在组件中定义一个事件，当需要在其他组件中触
   发这个事件时，可以通过回调函数的方式实现。
5. 全局状态管理：使用全局状态管理工具（如 Redux、Mobx）来管理组件状态，从而实现组件间通信。

需要根据实际场景选择适合的通信方式。

```
⻥皮补充：这题还是挺重要的，因为组件通信是开发中的一个必备技能，建议大家把以上几种方式都实践一
下
```

### 4 、React.memo() 和 useMemo() 的用法是什么，有哪些区别？

#### 官方解析

**React.memo()** 和 **useMemo()** 是 **React** 中用于性能优化的两个钩子函数。

**React.memo()** 是一个高阶组件，用于优化组件的性能。它会比较组件的新旧 props，如果 props 没有发生改
变，则跳过渲染，直接使用上一次渲染的结果。使用 **React.memo()** 可以避免组件不必要的重新渲染，从而提高
应用程序的性能。

用法示例：

**useMemo()** 是一个 Hook，用于缓存函数的计算结果。它可以缓存组件的 props 或其他数据的计算结果，只有当
依赖项发生改变时才重新计算。

用法示例：

```
useEffect(()=>{
console.log('onMount')
return ()=>{
console.log('unMounte')
}
},[])
```

```
const MemoizedComponent = React.memo(MyComponent);
```

##### 区别：

```
React.memo() 用于优化组件的性能，它会比较组件的新旧 props，如果 props 没有发生改变，则跳过渲
染，直接使用上一次渲染的结果。而 useMemo() 用于缓存函数的计算结果，只有当依赖项发生改变时才重新
计算。
React.memo() 是一个高阶组件，必须包裹组件才能使用，而 useMemo() 是一个 Hook，可以在函数组件
中使用。
综上所述， React.memo() 用于缓存组件的渲染结果，从而提高应用程序的性能，而 useMemo() 则用于缓
存函数的计算结果，可以在函数组件中使用。
```

#### ⻥友的精彩回答

##### 悟道的回答

React.memo() 和 useMemo() 都是 React 中的性能优化工具，但是它们的用途和区别是不同的。

1 、React.memo() React.memo() 是一个高阶组件，它可以帮助我们避免在不必要的情况下进行不必要的组件重新
渲染。它的作用是对组件进行浅比较（shallow comparison）来判断是否需要重新渲染。如果组件的 props 没有
发生变化，则 React.memo() 将会阻止组件重新渲染。React.memo() 可以接收一个可选的第二个参数，它是一个
函数，用于比较新旧 props 是否相等。

示例：

2 、useMemo() useMemo() 是一个 hook，它的作用是在渲染过程中缓存变量的值。useMemo() 接收两个参数，
第一个参数是一个函数，用于计算缓存的值，第二个参数是一个数组，用于指定依赖项。如果依赖项发生变化，
useMemo() 将重新计算缓存的值。如果依赖项没有变化，则 useMemo() 将返回之前缓存的值。

示例：

```
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

```
import React from 'react';
```

```
const MyComponent = React.memo(props => {
return <div>{props.title}</div>;
});
```

```
import React, { useMemo } from 'react';
```

```
const MyComponent = ({ list }) => {
const expensiveOperation = useMemo(() => {
// 计算复杂的操作
return list.map(item => item * 2);
}, [list]);
```

```
return <div>{expensiveOperation}</div>;
};
```

##### 区别：

React.memo() 适用于优化组件的重新渲染，而 useMemo() 适用于缓存变量的值。React.memo() 通常用于优化组
件性能，而 useMemo() 通常用于优化复杂计算的性能。此外，React.memo() 仅比较 props 是否相等，而
useMemo() 则可以根据依赖项进行计算，所以两者的应用场景也有所不同。

##### 作者：编程导航知识星球 + 星球⻥友们

## TypeScript

### 1 、说说你对 TypeScript 的理解？与 JavaScript 的区别？

#### 官方解析

TypeScript 是一种开源的编程语言，它是 JavaScript 的一个超集，支持静态类型、类、接口等特性，并且在编译时
进行类型检查。TypeScript 的设计目标是提高代码的可维护性和可读性，并且可以在大型项目中提供更好的代码组
织和重用。

相比于 JavaScript，TypeScript 具有以下特点：

```
支持类型：TypeScript支持静态类型，在编译时进行类型检查，能够在代码编写阶段发现类型错误，减少运行
时错误。
支持面向对象编程：TypeScript支持类、接口、泛型等面向对象编程特性，可以更好地组织代码和重用代码。
支持ES6+特性：TypeScript支持ES6+的语法和特性，可以使用最新的语言特性来提高代码质量和可读性。
更好的编辑器支持：TypeScript 提供了更好的编辑器支持，包括类型检查、代码补全、重构等功能，可以提
高开发效率。
更好的可维护性：TypeScript 的类型系统和面向对象特性可以提高代码的可维护性和可读性，使得代码更加
易于维护和扩展。
```

总之，TypeScript 可以看作是 JavaScript 的一个超集，它扩展了 JavaScript 的功能，提供了更好的类型检查和面向
对象编程特性，可以提高代码的可维护性和可读性。

#### ⻥友的精彩回答

##### 逝时流光的回答

TypeScript 是 JavaScript 的类型的超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等

特性 typescript 的特性主要有如下：

```
类型批注和编译时类型检查 ： 在编译时批注变量类型
类型推断： ts中没有批注变量类型会自动推断变量的类型
类型擦除： 在编译过程中批注的内容和接口会在运行时利用工具擦除
接口： ts中用接口来定义对象类型
枚举： 用于取值被限定在一定范围内的场景
```

```
Mixin： 可以接受任意类型的值
泛型编程： 写代码时使用一些以后才指定的类型
名字空间： 名字只在该区域内有效，其他区域可重复使用该名字而不冲突
元组： 元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组
```

区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法 TypeScript 可处理已有的 JavaScript 代码，并只
对其中的 TypeScript 代码进行编译 TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js 在编写
TypeScript 的文件的时候就会自动编译成 js 文件。

**Et cetera 的回答**

就从老生常谈的'TS 是 JS 的超集'一句延伸总结一下：TS 就是能够在拥有 JS 所有特性下，赋予代码能在编写阶段(而非
浏览器或 node 这些 runtime 阶段)有更好预⻅性的强类型语言(然后基于 TS 一些内置工具什么的类型操作就不谈了)

### 2 、TypeScript 的内置数据类型有哪些？

#### 官方解析

TypeScript 的内置数据类型包括：

1. boolean：布尔类型，true 或 false。
2. number：数值类型，包括整数和浮点数。
3. string：字符串类型，表示文本。
4. Array：数组类型，可以存储多个相同类型的值。
5. Tuple：元组类型，可以存储多个不同类型的值，每个值的类型可以自定义。
6. Enum：枚举类型，用于定义一些具有特定含义的常量。
7. any：任意类型，表示不确定的数据类型。
8. void：空类型，表示没有返回值。
9. null 和 undefined：表示 null 和 undefined 值。
10. never：表示永远不会返回的类型。

#### ⻥友的精彩回答

**H.lj** !ᯤᯤ **⁶ᴳ 的回答**

TypeScript 是 JavaScript 的超集，它在 JavaScript 的基础上增加了类型系统。TypeScript 提供了与 JavaScript 相
同的数据类型，同时还增加了一些额外的类型。TypeScript 的内置数据类型如下：

1. 布尔类型（boolean）：表示 true 或 false。
2. 数字类型（number）：表示数值，包括整数和浮点数。
3. 字符串类型（string）：表示文本字符串。

4. 数组类型（array）：表示一个元素列表，可以包含任意类型的元素。
5. 元组类型（tuple）：表示一个固定⻓度的、类型确定的数组。
6. 枚举类型（enum）：表示一组命名的常量值。
7. 任意类型（any）：表示任意类型。
8. 空类型（void）：表示没有返回值的函数的返回类型。
9. null 和 undefined 类型（null 和 undefined）：分别表示 null 和 undefined 值。
10. 对象类型（object）：表示一个非原始类型的对象，包括函数、数组、类等。
11. Never 类型（never）：表示永远不会出现的类型。
12. Unknown 类型（unknown）：表示一个未知的类型，类似于 any 类型，但是更加类型安全。

除了以上内置类型，TypeScript 还支持定义自定义类型和联合类型等高级类型。

### 3 、TypeScript 中的 Declare 关键字有什么用？

#### 官方解析

TypeScript 中的 declare 关键字用于声明一个变量、函数、类等的类型信息，但不实现其具体实现。它主要用于在
编译时进行静态类型检查，并在编译后移除声明的代码，以减少 JavaScript 文件的大小。

使用 declare 关键字声明的类型信息可以是任何类型，如对象、函数、类、变量、命名空间等。常⻅的使用场景
有：

声明全局变量或模块

声明外部的 JavaScript 库

##### 声明命名空间

##### // 声明全局变量

```
declare const jQuery: (selector: string) => any;
```

```
// 声明模块
declare module "lodash" {
export function debounce(fn: Function, wait: number): Function;
}
```

```
declare module "some-library" {
export function someFunction(): void;
export const someVariable: number;
}
```

```
declare namespace MyNamespace {
function myFunction(): void;
}
```

通过使用 declare 关键字，可以让 TypeScript 在编译时检查代码的类型信息，并避免一些类型错误。同时，也可
以提高代码的可读性和维护性。

### 4 、什么是 TypeScript 中的命名空间和模块？两者有什么区别？

#### 官方解析

在 TypeScript 中，命名空间和模块都是用来组织和管理代码的方式。

命名空间提供了一种将代码划分为逻辑单元的方式，可以避免命名冲突。在命名空间内，所有变量、函数、类等都
是私有的，需要使用 export 关键字进行导出，才能被其他代码使用。例如：

##### 模块是用来组织和管理代码的方式，与命名空间类似，不同之处在于模块是按文件划分的，一个文件就是一个模

块。模块可以使用 export 和 import 关键字来导出和导入代码。例如：

##### 命名空间和模块的主要区别在于，命名空间是将代码划分为逻辑单元，而模块是按照文件划分的。在使用模块时，

可以使用 import 和 export 进行代码的导入和导出，可以更方便地组织和管理代码。

```
namespace MyNamespace {
export const PI = 3.14;
export function sayHello(name: string) {
console.log(`Hello, ${name}!`);
}
export class Person {
constructor(public name: string) {}
}
}
```

```
// moduleA.ts
export const PI = 3.14;
export function sayHello(name: string) {
console.log(`Hello, ${name}!`);
}
export class Person {
constructor(public name: string) {}
}
```

```
// moduleB.ts
import { PI, sayHello, Person } from './moduleA';
console.log(PI); // 3.14
sayHello('world'); // Hello, world!
const person = new Person('Alice');
console.log(person.name); // Alice
```

#### ⻥友的精彩回答

##### 悟道的回答

在 TypeScript 中，命名空间（Namespace）和模块（Module）是两种不同的组织代码的方式。

命名空间是一种将相关的代码放在一个特定的命名空间下的方式，以避免名称冲突。可以使用 namespace 关键字
来创建一个命名空间。

例如，下面是一个 Shapes 命名空间的示例，其中包含了三个形状的类定义：

##### 模块是一种将代码组织成单独的文件，并且可以通过导入和导出来实现跨文件的代码共享的方式。可以使用

module 或 export 关键字来创建一个模块。

例如，下面是一个包含两个模块的示例：

##### 区别：

##### 命名空间是一种在一个文件内组织代码的方式，而模块是一种跨文件组织代码的方式。因此，命名空间主要用于组

##### 织单个文件中的代码，而模块则主要用于跨文件共享代码。

##### 命名空间可以通过嵌套来创建子命名空间，但模块没有这种方式。

```
namespace Shapes {
export class Circle {
// ...
}
export class Square {
// ...
}
export class Triangle {
// ...
}
}
```

```
// shape.ts
export interface Shape {
// ...
}
```

```
// circle.ts
import { Shape } from "./shape";
```

```
export class Circle implements Shape {
// ...
}
```

```
// main.ts
import { Circle } from "./circle";
```

```
let c = new Circle();
```

命名空间的内部成员可以通过没有 export 关键字来隐藏，而模块中的所有成员都是公开的，需要通过 export 显式
导出才能在其他模块中使用。

模块可以使用更灵活的导入和导出语法，例如按需导入和导出、重命名导入和导出等。而命名空间只能使用
namespace 和 import 语法来导入和导出。

##### 作者：编程导航知识星球 + 星球⻥友们

## Node.js

### 1 、说说你对 Node.js 的理解？优缺点？应用场景？

#### 官方解析

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许开发者使用 JavaScript 进行服务器端编程。

Node.js 拥有事件驱动、非阻塞 I/O 的特性，能够处理高并发的请求，因此它被广泛应用于实时应用、Web 应用和
API 的开发。

以下是 Node.js 的优缺点：

优点：

```
事件驱动和非阻塞I/O的特性能够处理高并发的请求，提高了程序的性能和响应速度；
使用 JavaScript 进行开发，具有丰富的开源模块和组件，可以大大提高开发效率；
支持跨平台，可以在 Windows、Linux、MacOS 等多个操作系统上运行；
可以进行快速原型开发和实时调试。
```

缺点：

```
Node.js 对于计算密集型的任务和多线程编程支持不够好，适合于 I/O 密集型任务；
因为 Node.js 是基于事件驱动和回调机制的，开发时需要特别注意回调地狱和异步操作的异常处理，否则容
易导致代码难以维护。
```

Node.js 的应用场景主要包括以下几个方面：

```
Web 开发：使用 Node.js 可以快速搭建 Web 服务器，进行 Web 开发；
实时应用：Node.js 支持事件驱动和非阻塞I/O，可以用于实时数据传输和消息通信等领域；
命令行工具：Node.js 可以用于编写命令行工具和脚本；
微服务：Node.js 支持跨平台和轻量级开发，可以用于编写微服务。
```

总之，Node.js 具有很多优点，如高并发处理能力、跨平台性、丰富的开源组件等，但也需要注意其局限性，开发
者需要在实践中根据具体需求合理选用技术。

⻥皮补充：这道题目面试官其实很想知道你是否用过 Node.js、用 Node.js 做过什么，以及前端同学经常用来拿
Node.js 做什么？（比如后端中间层）

### 2 、什么是 Node.js 中的 process？它有哪些方法和应用场景？

#### 官方解析

在 Node.js 中，process 是一个全局变量，它提供了与当前 Node.js 进程相关的信息和控制。process 对象是
EventEmitter 的一个实例，因此它可以使用 EventEmitter 的 API，例如注册事件监听器和触发事件。

process 对象的一些常用方法和属性：

```
process.argv：返回一个数组，其中包含命令行参数。第一个元素是 Node.js 可执行文件的路径，第二个元素
是正在执行的 JavaScript 文件的路径，后面的元素是命令行参数。
process.env：返回一个包含当前 Shell 环境变量的对象。
process.exit([code])：终止 Node.js 进程。如果指定了 code，那么进程将以 code 退出。
process.cwd()：返回当前工作目录的路径。
process.chdir(directory)：将 Node.js 进程的工作目录更改为 directory。
process.pid：返回 Node.js 进程的进程 ID。
process.nextTick(callback[, arg1][, arg2][, ...])：将 callback 添加到下一个 tick 队列。callback 会在当前操作
完成后、事件循环继续之前调用。
process.on(event, listener)：注册事件监听器。常用的事件包括 "exit"、"uncaughtException"、"SIGINT"
等。
```

process 对象的应用场景：

```
监听进程退出事件，执行资源清理操作。
通过 process.argv 读取命令行参数。
通过 process.env 读取环境变量。
通过 process.cwd 和 process.chdir 修改 Node.js 进程的工作目录。
通过 process.pid 获取进程 ID。
通过 process.nextTick 将某个操作放到下一个 tick 队列中，以实现异步执行。
```

总之，process 对象提供了与 Node.js 进程相关的许多信息和控制，是 Node.js 编程中不可或缺的一部分。

```
⻥皮补充：可以说下自己在项目中是如何用 process 的，比较常⻅的就是 process.env 读取环境变量
```

### 3 、什么是 npm？你用过哪些 npm 包？是否开发过自己的 npm 包？

#### 官方解析

npm（Node Package Manager）是一个基于 Node.js 的包管理器，用于管理 Node.js 项目中的依赖和包。npm
提供了一种简单、方便的方式来安装、更新和卸载第三方库和工具，同时还可以用于发布和共享自己开发的包。通
过 npm，开发者可以轻松地引入各种库，提高开发效率。

提供一些常⻅的 npm 包：

1. express：一个简洁、灵活的 Node.js Web 应用框架，提供了一系列强大的功能来开发 Web 和 API 应用。
2. react：一个用于构建用户界面的 JavaScrip t 库，由 Facebook 开发，广泛应用于前端开发。

3. lodash：一个强大的 JavaScript 实用库，提供了许多有用的工具函数，如数组操作、对象操作、函数操作
   等。
4. axios：一个基于 Promise 的 HTTP 客户端库，用于浏览器和 Node.js，提供了简单、易用的 API 来发起
   HTTP 请求。
5. moment：一个用于解析、处理和显示日期和时间的 JavaScript 库，提供了丰富的 API 来处理各种日期和时
   间操作。
6. nodemon：一个实用的开发工具，用于监视 Node.js 应用程序中的文件更改，并在发生更改时自动重启应
   用。

开发自己的 npm 包的过程大致如下：

1. 创建项目文件夹，并在文件夹中初始化 npm 项目，使用 npm init 命令生成 package.json 文件。
2. 开发功能模块，确保遵循模块化的原则，编写模块的导出和引入。
3. 编写详细的 README 文件，说明模块的用途、安装方法、使用方法以及 API 文档。
4. 确保项目中包含.gitignore 和 .npmignore 文件，以排除不需要发布到 npm 的文件和文件夹。
5. 在 npm 官网 https://www.npmjs.com/ 注册一个账号，然后在命令行中使用 npm login 命令登录。
6. 使用 npm publish 命令发布包到 npm 仓库。

发布后，其他开发者可以通过 npm install 命令安装和使用您的包。注意在开发过程中遵循语义化版本规范
（Semantic Versioning），便于其他开发者理解版本变更。

#### ⻥友的精彩回答

##### 悟道的回答

npm 是 Node.js 的包管理器，可以方便地安装、升级、删除、发布和管理 Node.js 的包（也称为模块）。npm 包
括一个命令行客户端，用于从 npm 仓库中下载、安装和管理依赖项，以及一个在线的包注册表，用于存储和分享
npm 包。

我使用过很多 npm 包，包括 Express、React、Lodash、Moment.js、Axios、Jest 等。这些包为 JavaScript 开发
提供了许多便利的功能和工具，使得开发人员可以更快、更高效地构建应用程序。

我也曾经开发过自己的 npm 包。我开发的包名叫做 “my-utils”，提供了一些常用的 JavaScript 工具函数，如深度
克隆、对象合并、类型判断等等。开发过程中，我首先在本地使用 npm init 命令初始化了一个新的 npm 包，并将
代码上传到了我的 GitHub 仓库中。接着，我使用 npm publish 命令将包发布到了 npm 仓库中，使得其他开发人
员可以方便地安装和使用我的工具函数。这个过程非常简单和便捷，使得我可以快速地分享我的代码并为其他开发
人员提供帮助。

### 4 、什么是 Node.js 的事件循环机制？它是怎么实现的？

#### 官方解析

Node.js 的事件循环（Event Loop）机制是 Node.js 中实现异步非阻塞 I/O 的核心。事件循环允许 Node.js 可以在
单个线程中处理高并发的请求，提高了程序的性能和响应能力。

事件循环是 Node.js 的运行机制，负责调度和处理各种事件（如 I/O 操作、定时器、网络请求等）。以下是事件循
环的主要实现流程：

1. Node.js 在启动时会初始化事件循环。
2. 执行输入的脚本，可能会注册各种事件（如 I/O 操作、定时器等）。
3. 事件循环开始运行，进入不同的阶段（Phases），如 Timers、I/O callbacks、Idle/Prepare、Poll、Check 和
   Close callbacks。每个阶段负责处理特定类型的事件。
4. 当事件队列中的事件被处理完毕，事件循环会检查是否还有待处理的事件或回调。如果没有，事件循环结束，
   程序退出；否则，事件循环继续运行，处理新的事件。

Node.js 的事件循环机制是基于 libuv 库实现的。libuv 是一个跨平台的异步 I/O 库，提供了事件循环、线程池等功
能。Node.js 使用 libuv 来实现事件循环，处理各种异步操作，如文件 I/O、网络请求、定时器等。

值得注意的是，Node.js 的事件循环与浏览器的事件循环有一定的区别。虽然它们的核心概念相似，但在实现细节
和运行环境上有所不同。在使用 Node.js 时，需要理解其事件循环的特点，以便更好地编写异步代码。

### 5 、Node.js 有哪些全局对象？它们分别有什么作用？

#### 官方解析

Node.js 中有一些全局对象，它们可以在任何模块中直接访问，无需进行导入。以下是一些常⻅的全局对象及其作
用：

1. global：它是 Node.js 的全局命名空间，类似于浏览器环境中的 window 对象。在 global 对象上定义的属性
   和方法可以在任何地方访问。然而，在实际开发中，应避免在 global 对象上添加属性，以防止全局命名空间
   污染。
2. process：它是一个全局对象，提供了关于当前 Node.js 进程的信息和对其进行控制的方法。process 对象包
   含诸如环境变量、命令行参数、内存使用情况、当前工作目录等属性和方法。
3. console：它是一个全局对象，提供了用于输出信息和调试的方法，如 console.log()、console.error()、
   console.warn() 等。
4. setTimeout 和 clearTimeout：这两个方法用于设置和清除定时器。setTimeout 方法用于在指定的毫秒数后
   执行一个回调函数，clearTimeout 方法用于取消一个先前通过 setTimeout 设置的定时器。
5. setInterval 和 clearInterval：这两个方法用于设置和清除周期性定时器。setInterval 方法用于每隔指定的毫
   秒数执行一个回调函数，clearInterval 方法用于取消一个先前通过 setInterval 设置的定时器。
6. setImmediate 和 clearImmediate：这两个方法用于在当前事件循环结束时执行一个回调函数。
   setImmediate 方法会将回调函数添加到事件循环的队列末尾，以便在当前事件循环的所有 I/O 事件和定时器
   事件处理完毕后执行。clearImmediate 方法用于取消一个先前通过 setImmediate 设置的回调函数。
7. Buffer：它是一个全局的构造函数，用于处理二进制数据，如文件 I/O、网络 I/O 等。Buffer 提供了一系列方
   法来创建和操作字节缓冲区。

8. require 和 module：require 是一个全局函数，用于导入其他模块。module 是一个全局对象，表示当前模
   块。每个 Node.js 文件都是一个模块，模块可以导出函数、对象或值，以便其他模块使用。

注意，虽然这些对象在全局范围内可用，但它们并非严格意义上的全局变量。在 Node.js 模块中，它们是模块作用
域内的变量，这意味着在一个模块中定义的变量不会自动成为全局变量。

### 6 、怎么调试 Node.js 程序？

#### 官方解析

调试 Node.js 程序有多种方法，以下是一些常⻅的调试技巧和工具：

使用 console.log()：在代码中添加 console.log() 语句，输出变量值、函数执行情况等，以便了解程序运行状态。
这是最基本的调试手段，适用于简单的问题排查。

使用内置调试器：Node.js 提供了一个内置的命令行调试器。要使用它，只需在启动脚本时在命令行中添加
inspect 或 inspect-brk 标志，例如：

##### 或

这将启动一个调试会话。你可以在代码中添加 debugger; 语句，作为断点。调试器将在遇到断点时暂停执行。

使用 Chrome DevTools：你可以使用 Chrome DevTools 来调试 Node.js 程序。首先，使用 inspect 或 inspect-
brk 标志启动 Node.js 应用，然后打开 Chrome 浏览器，输入 chrome://inspect，在 "Devices" 下找到你的
Node.js 应用，并点击 "inspect"。这将打开一个 DevTools 实例，你可以像调试浏览器中的 JavaScript 代码一样调
试 Node.js 代码。

使用 Visual Studio Code：Visual Studio Code 是一个流行的开源代码编辑器，内置了对 Node.js 的调试支持。要
在 VSCode 中调试 Node.js 应用，需要创建一个名为 .vscode/launch.json 的配置文件，配置调试参数。以下是一
个简单的配置示例：

```
node inspect app.js
```

```
node --inspect-brk app.js
```

##### {

```
"version": "0.2.0",
"configurations": [
{
"type": "node",
"request": "launch",
"name": "Launch Program",
"program": "${workspaceFolder}/app.js"
}
]
}
```

然后，按下 F5 或点击左侧 "Run and Debug" 选项卡上的 "Run" 按钮开始调试。你可以在代码中添加断点、查看
变量值、使用控制台等。

使用其他 IDE 和编辑器：许多其他 IDE 和代码编辑器也提供了 Node.js 调试支持，如 WebStorm、Atom 等。具体
操作方法因工具而异，请参考相应工具的文档。

选择合适的调试工具和方法可以帮助你更高效地找到和解决 Node.js 程序中的问题。

#### ⻥友的精彩回答

**codexgh 的回答**

调试 Node.js 程序可以使用以下方法：

1. console.log()：使用 console.log() 打印变量或者调试信息，可以在控制台中查看输出的结果。
2. debugger：在代码中使用 debugger 命令设置断点，当程序执行到该点时会暂停，可以在控制台中查看变量
   的值和程序运行状态。
3. VS Code 调试工具：在 VS Code 编辑器中使用调试工具，可以设置断点、单步执行、查看变量的值等操作，
   方便快速地定位程序问题。
4. node-inspector：使用 node-inspector 工具可以在浏览器中调试 Node.js 程序，可以使用 Chrome 浏览器调
   试工具的各种功能。
5. ndb：ndb 是一个基于 Chrome DevTools 的 Node.js 调试器，可以使用 Chrome 的调试功能来调试 Node.js
   程序，支持断点、单步执行、查看变量等调试功能。 这些调试方法都有各自的优势和适用场景，可以根据具
   体情况选择合适的方法来调试 Node.js 程序。

##### 作者：编程导航知识星球 + 星球⻥友们

## 计算机网络

### 1 、介绍下从 HTTP/1.0、HTTP/1.1 到 HTTP/2 再到 HTTP/3 的演化过

### 程，各个阶段相对前一阶段做了哪些优化？

#### 官方解析

##### HTTP/1.0、HTTP/1.1 到 HTTP/2 再到 HTTP/3 的演化 过程主要是为了解决 HTTP 协议在网络传输过程中出现的一

##### 些问题，提高网络传输效率和性能。

**HTTP/1.0** 是最早的 HTTP 协议，它使用一条 **⻓连接** （keep-alive）传输一个请求和响应，存在以下问题：

```
队头阻塞问题 ：因为只有一个连接，所以如果有一个请求被阻塞，后续请求也会被阻塞。
无法多路复用 ：只能按顺序传输一个请求和响应，无法同时传输多个请求和响应。
每次请求需要新建连接 ：每次请求都需要新建连接，连接的建立和关闭过程会消耗时间。
```

**HTTP/1.1** 引入了以下优化：

##### 持久连接 ：即 连接重用 ，通过一个 TCP 连接传输多个请求和响应，减少了连接建立和关闭的时间。

```
分块传输编码 （chunked）：把响应数据分成多个块，每个块前面加上⻓度信息，便于客户端逐步接收。
虚拟主机 （Virtual Host）：通过在请求头中添加 Host 字段来区分不同的主机。
```

**HTTP/2** 引入了以下优化：

```
多路复用 ：允许同时通过 同一个连接并行传输多个请求和响应 ，解决了 队头阻塞 问题。
二进制分帧 ：将传输的数据分成一个个 二进制帧 ，每个帧都有自己的 ID，可以 独立传输 ，解决了 队头阻塞 问
题，提高了传输效率。
头部压缩：使用 HPACK 算法对头部信息进行压缩，减少了头部信息的传输量。
```

**HTTP/3** 引入了以下优化：

```
QUIC 协议 ：使用 QUIC 协议替代 TCP，支持更快的连接建立和更快的重传，能够解决 TCP 队头阻塞 和 TCP
握手延迟 的问题。
数据流分离 ：将一个连接分成多个数据流，每个数据流都有独立的 ID，可以独立控制和传输数据。
```

总的来说，HTTP/1.0、HTTP/1.1 到 HTTP/2 再到 HTTP/3 的演化过程主要是从 **连接** 的⻆度进行了优化，提高了 **并
发能力和传输效率** ，提高了 **用户体验** 。

```
⻥皮补充：这题还蛮重要的，建议大家学习一下，面试的时候很容易被问到：HTTP/2 为什么快之类的问题
```

#### ⻥友的精彩回答

**mos 的回答**

**HTTP/1.0 到 HTTP/1.1 的优化：**

持久连接：在 HTTP/1.0 中，每次请求都需要建立一个新的 TCP 连接，而在 HTTP/1.1 中，引入了持久连接（也称为
复用连接），这样可以在一个 TCP 连接上发送多个 HTTP 请求和响应，减少了 TCP 连接的建立和关闭所需的时间和资
源消耗。 管线化：在 HTTP/1.1 中，支持请求管线化，即客户端可以同时发送多个请求，在服务端处理完第一个请
求之前不必等待其它请求的返回。这种方式虽然提高了性能，但由于各个请求之间存在依赖关系，当其中一个请求
出错时，会导致后续请求都失败。

**HTTP/1.1 到 HTTP/2 的优化：**

二进制传输：HTTP/1.x 使用明文文本进行通信，而 HTTP/2 引入了二进制格式来代替文本格式，这样可以减少解
析数据的开销，提高通信效率。 多路复用：HTTP/1.x 中一个 TCP 连接只能同时处理一个请求，而 HTTP/2 中支持
多路复用，即同一个连接可以同时传输多个请求和响应，这样可以避免浪费底层 TCP 连接和减少网络延迟。 数据
流和帧：HTTP/2 中将请求和响应分割成若干个数据流，并对其进行编号，同时对每个数据流中的数据进行拆分成
更小的帧进行传输，这样使得多个数据流可以并发交错地在一个连接上传输，从而提高了传输效率和速度。 首部压
缩：HTTP/2 中采用 HPACK 算法对消息头进行压缩，避免了重复数据的传输，降低了传输量，提高了性能。

**HTTP/2 到 HTTP/3 的优化：**

对 QUIC 协议的使用：HTTP/3 将 HTTP 协议与 QUIC 协议结合起来，QUIC 是基于 UDP 的传输协议，相较于基于
TCP 的协议，QUIC 具有更低的延迟和更好的拥塞控制，从而提高了性能和稳定性。 报头压缩算法更新：HTTP/2
中采用的 HPACK 算法对消息头进行压缩，但该算法存在一些安全漏洞，因此 HTTP/3 中使用了 QPACK 算法对报
头进行压缩，QPACK 算法具有更好的安全性和效率。 无阻塞式的流：HTTP/3 中使用了 QUIC 协议的无阻塞式流
特性，使得数据能够更快地通过网络传输，提高了性能和稳定性。 总的来说，HTTP/1.0、HTTP/1.1 到 HTTP/2 再

##### 到 HTTP/3 的演化过程主要是从连接的⻆度进行了优化，提高了并发能力和传输效率，提高了用户体验。

##### 解析上文中的复用连接和多路复用 ：都是为了提高 HTTP 的性能，但它们的实现方式不同。

##### 复用连接指的是在一个 TCP 连接上可以重复发送多个请求-响应对，从而避免了每次请求都要建立新的 TCP 连接的

开销。这种方式可以减少 TCP 连接的建立和关闭所需的时间和资源消耗，但是由于 HTTP/1.x 中使用“队头阻塞”机
制，即同一时刻只能处理一个请求，因此在传输多个请求时，需要按顺序一个一个发送，不能同时进行，会浪费带
宽资源。

多路复用（Multiplexing）则是指在一个 TCP 连接上同时传输多个请求-响应对，这样多个请求可以并发交错地在
一个连接上传输，从而减少了网络延迟，提高了传输效率和速度。HTTP/2 中就采用了多路复用技术来提高性能。
在多路复用中，每个请求都有一个唯一的标识符，并且每个请求和响应都被分解成很小的数据包（称为帧），这些
帧之间没有任何固定的顺序要求，所以可以随时根据需要交错发送。这种方式可以避免浪费底层 TCP 连接和减少网
络延迟，更加高效。

总之，复用连接和多路复用都可以减少建立和关闭 TCP 连接的开销，从而提高 HTTP 的性能，但多路复用还能同时
传输多个请求-响应对，更加高效。

### 2 、DNS HTTP 缓存有哪些实现方式？什么是协商缓存和强制缓存？

#### 官方解析

##### HTTP 缓存 可以通过以下几种方式进行实现：

##### 1. 浏览器缓存 ：浏览器可以将最近请求过的资源保存到本地，下次请求时可以直接从本地读取，从而提高访问速

##### 度。

##### 2. 代理缓存 ：代理服务器可以缓存响应，减少对原始服务器的请求次数，从而加快响应速度。

##### 3. 网关缓存 ：网关可以缓存来自多个原始服务器的响应，然后将响应发送到客户端，从而提高性能。

##### HTTP 缓存可以分为 协商缓存 和 强制缓存 两种类型。

##### 强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从而提高响应速度。常⻅

##### 的实现方式包括：

1. Expires 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资
   源。
2. Cache-Control 头部：可以指定资源的缓存策略，包括 public、private、no-cache 等，控制浏览器的缓存行
   为。

**协商缓存** 是指浏览器在请求资源时，会发送一些 **请求头** 到服务器， **询问服务器资源是否已经发生改变** 。如果资源未
发生改变，服务器将返回 **304 状态码** ，告诉浏览器可以从缓存中读取资源，从而减少了网络带宽的使用。常⻅的实
现方式包括：

1. **Last-Modified / If-Modified-Since 头部** ：浏览器在请求资源时，会将资源最后修改时间（Last-Modified）
   发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则返回新的资源。
2. **ETag / If-None-Match 头部** ：服务器可以给每个资源分配一个唯一的标识符（ETag），浏览器在请求资源
   时，将该标识符发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则
   返回新的资源。

##### 需要注意的是， 协商缓存 虽然可以 减少网络带宽的使用 ，但是需要服务器进行资源比较，因此会 增加服务器的负

##### 载 。

### 3 、简述 TCP/IP 网络模型，分为几层？每层的职责和作用是什么？

#### 官方解析

##### TCP/IP 网络模型（也称为互联网协议套件）是一种用于描述网络通信的概念模型。它分为四层，每层都有特定的职

##### 责和作用，它们分别是：

1. **应用层（Application Layer）** ：应用层负责处理与应用程序的通信和数据传输。它包括各种应用层协议，例
   如 HTTP、HTTPS、FTP、SMTP、IMAP、POP3、DNS 等。这些协议定义了客户端和服务器之间如何互相发
   送和接收数据。应用层的主要职责是为应用程序提供用户接口、数据传输以及数据封装和解封装。
2. **传输层（Transport Layer）** ：传输层主要负责在网络中进行端到端的可靠数据传输。它提供了两种主要的传
   输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。TCP 提供了可靠、面向连接的数据传输，它可
   以确保数据在传输过程中不会丢失、重复或乱序。UDP 提供了不可靠、无连接的数据传输，它不能保证数据
   的传输质量，但传输速度更快，适用于实时通信等场景。
3. **网络层（Internet Layer）** ：网络层负责在不同网络之间进行数据包的路由和传输。它使用 IP（互联网协
   议）进行寻址和路由，将数据包从源主机传输到目的主机。网络层的主要职责包括：IP 地址分配、路由选
   择、分片和重组以及错误检测和处理。除了 IP 协议，网络层还包括其他协议，如 ICMP（互联网控制消息协
   议）和 IGMP（互联网组管理协议）。
4. **链路层（Link Layer）** ：链路层（又称网络接口层或数据链路层）负责在同一网络中进行数据帧的发送和接
   收。链路层的协议因网络硬件而异，如 Ethernet、Wi-Fi、PPP 等。链路层的主要职责包括：物理寻址、数据
   帧封装和解封装、差错检测、流量控制以及链路管理。

总的来说，TCP/IP 网络模型将网络通信划分为四个层次，每层都有自己的职责和功能。这种分层模型有助于降低网
络系统的复杂性，便于设计、实现和维护网络协议和设备。

#### ⻥友的精彩回答

**luckythus 的回答**

**简述 TCP/IP 网络模型，分为几层？每层的职责和作用是什么？**

1. 应用层：应用层为用户提供网络服务，应用层的任务是通过应用程序完成特定的网络功能。应用层负责处理与
   应用程序的通信和数据传输，它包括多种应用层协议，如 HTTP、FTP、DNS 等。这些协议定义了客户端和服
   务器之间如何互相发送和接收数据的交互规范。例如向服务器发送 HTTP 请求，或从 DNS 服务器获取 IP 地址
   等。为应用程序提供用户接口、数据传输以及数据封装和解析封装。
2. 传输层：传输层主要负责提供端到端的数据传输服务，包括 TCP 和 UDP 协议。TCP 提供面向连接、可靠的数
   据传输服务，而 UDP 则提供无连接、不可靠的数据传输服务。传输层的主要任务是保证数据的可靠性，实现
   数据的分段和重组，并且确保数据按照正确的顺序到达目的地。
3. 网络层：网络层负责在不同网络之间进行数据包的路由和传输。它使用 IP（互联网协议）进行寻址和路由，
   将数据包从源主机传输到目的主机。其中包括 IP 地址的分配、路由选择、分组传输和拥塞控制等功能。
4. 数据链路层：数据链路层主要负责在物理层上传输数据。它将网络层传输的数据进行分帧，并添加了物理地址
   （MAC 地址）以及校验和等信息，使其可以在物理层上传输。

##### 它们之间的具体过程是这样：

##### 发送方：

##### 应用层：应用层向下传输报文，报文中包含应用层自己的报头和应用层的数据。

##### 传输层：传输层接收到应用层的报文，将应用层报文封装成一个或多个数据段，同时添加传输层的报头信息，

##### 例如 TCP 的源端口和目标端口号等。

##### 网络层：网络层接收到传输层的数据段，将数据段打包成 IP 数据包，同时添加网络层的报头信息，例如源 IP

##### 地址和目标 IP 地址等。

##### 数据链路层：数据链路层接收到 IP 数据包，将其封装成数据帧，同时添加数据链路层的报头信息，例如源

##### MAC 地址和目标 MAC 地址等。

##### 物理层：物理层接收到数据帧，将其转换为 0 和 1 的电信号，通过物理介质传输到接收方，接收方的物理层

##### 将电信号转换为数据帧。

##### 接收方：接收方也会按照相反的顺序层层解析报文。

##### 物理层：物理层传来的 0 和 1 的电信号，并将其转换为数据帧。

##### 数据链路层：会解析数据帧中的报头信息，剥离数据链路层的报头信息，并将剩余的数据包交给网络层。

##### 网络层：解析数据包中的报头信息，剥离网络层的报头信息，并将剩余的数据段交给传输层。

##### 传输层：解析数据段中的报头信息，剥离传输层的报头信息，并将剩余的数据段重组成完整的数据，并交给应

##### 用层。

##### 应用层：解析数据中的应用层报文，并进行处理和响应。

##### 整个接收过程与发送过程类似，但是在每一层都需要进行不同的处理，以确保数据能够被正确地接收、还原和处

##### 理。

**Kristen 的回答**

TCP/IP 模型

协议(protocol)是规定网络中双方通信方法的规则。TCP/IP 是一个泛指，包括了 TCP，UDP，IP，FTP，HTTP，
ICMP，SMTP 等协议。

TCP/IP 从上往下共分为四层模型，分别是： 链路层：负责封装和解封装 IP 报文，发送和接受 ARP/RARP 报文等。

网络层：负责路由以及把分组报文发送给目标网络或主机。

传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。

应用层：负责向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS、SMTP 等。

数据在发送端经过各层时都会通过附加协议头(经过数据链路层还会附加协议尾)进行封装，以标识对应层所用的通
信协议。

## 打包工具

#### 1 、什么是 webpack？它有什么作用？

#### 官方解析

Webpack 是一个开源的前端打包工具，它主要用于将多个 JavaScript 文件打包成一个或多个文件，以便在浏览器
中加载。Webpack 的核心功能是对模块进行打包，并支持多种资源的加载和打包，如 JavaScript、CSS、图片、字
体等。

Webpack 的主要作用包括：

1. **模块化** ：Webpack 支持各种模块化规范，包括 ES6、CommonJS、AMD 等，可以将应用程序拆分为多个模
   块，方便管理和维护。
2. **资源加载** ：Webpack 可以处理各种类型的文件，包括 JavaScript、CSS、图片、字体等，可以将这些文件作
   为模块进行加载和打包。
3. **代码压缩** ：Webpack 可以对代码进行压缩和混淆，减小文件体积，提高⻚面加载速度。
4. **代码分割** ：Webpack 可以将应用程序拆分成多个 chunk，从而实现按需加载，减小首屏加载时间。
5. **模块热替换** ：Webpack 支持模块热替换，可以在开发过程中快速预览应用程序的变化，提高开发效率。
6. **优化打包速度** ：Webpack 可以使用多线程打包、缓存等技术，优化打包速度。

需要注意的是，Webpack 本身只是一个打包工具，对于项目的构建和管理，通常需要结合其他工具和插件一起使
用，如 Babel、ESLint、PostCSS、Vue Loader 等。同时，Webpack 的配置也比较复杂，需要一定的学习成本。
但是一旦熟练掌握，Webpack 可以大大提高项目的可维护性和开发效率。

#### ⻥友的精彩回答

**useGieGie 的回答**

Webpack 是一个开源的静态模块打包工具，它可以将多个模块组合成一个文件，同时可以将 Less、Scss、
TypeScript、ES6 等代码转换为浏览器可以识别的 JavaScript 代码。

Webpack 最重要的特性之一就是模块化。它允许使用模块化的方式来管理前端代码，可以将应用程序分成多个模
块，每个模块包含自己的 JavaScript、CSS、图片等资源。Webpack 会自动解析模块之间的依赖关系，并将它们打
包成一个或多个文件，这样可以减少 HTTP 请求的次数，提高⻚面加载速度。
Webpack 还有以下几个重要的作用：

1. 支持代码拆分和懒加载，可以将代码拆分成多个块，按需加载，提高⻚面加载速度和性能。
2. 支持插件和 Loader，可以通过插件和 Loader 实现各种各样的自动化任务，如压缩代码、生成 HTML 文件、
   图片压缩、样式预处理等。
3. 支持开发和生产环境的不同配置，可以通过不同的配置文件来满足不同环境下的需求，如开发环境下需要支持
   热更新，生产环境下需要压缩代码等。
4. 提供了开发服务器，可以在开发过程中快速构建和预览应用程序，提高开发效率。

Webpack 的工作原理可以概括为以下几个步骤：

1. 读取入口文件：Webpack 会读取入口文件，根据入口文件和配置信息，构建出一个或多个代码块
   （Chunk）。
2. 解析模块依赖：Webpack 会递归解析入口文件和其它模块之间的依赖关系，直到所有依赖关系都被解析出
   来。
3. 加载和转换模块：Webpack 会根据不同的 Loader，将模块中的不同类型的文件转换为 JavaScript 模块，如
   将 Less、Scss、TypeScript、ES6 等代码转换为浏览器可以识别的 JavaScript 代码。
4. 合并模块：Webpack 会将所有模块合并到一个或多个 Chunk 中，每个 Chunk 中包含了所有相关的模块和代
   码。
5. 输出打包结果：Webpack 会根据配置信息，将打包后的代码生成一个或多个文件，如输出到 dist 目录中，生
   成多个 JavaScript 和 CSS 文件。 在实际开发的时候，Webpack 的配置非常灵活，可以根据项目的需求来进
   行配置，包括入口文件、输出文件、Loader、插件、代码拆分、懒加载、开发服务器等。因此，熟练掌握
   Webpack 可以更好地进行项目开发和维护。

### 2 、如何提高 webpack 的打包速度？

#### 官方解析

Webpack 的打包速度受多个因素影响，以下是一些提高打包速度的方法：

1. 升级 webpack 版本：Webpack 不断更新优化打包速度，升级到最新版本可以获得更好的性能。
2. 使用更快的文件系统：使用更快的文件系统（如 RAM 磁盘）可以提高读写速度，加快 webpack 打包速度。
3. 减少文件搜索范围：在 Webpack 的配置中指定更少的文件搜索路径，可以减少文件搜索的范围，提高打包速
   度。
4. 使用 loader 缓存：Webpack 的 loader 会缓存处理后的结果，加快下次打包的速度。可以使用 cache-loader
   和 hard-source-webpack-plugin 等插件来进一步优化 loader 的缓存。

5. 拆分代码块：将代码拆分为更小的代码块，可以减少打包时间。可以使用 Webpack 的 code splitting 功能或
   手动将代码拆分为多个文件。
6. 避免不必要的插件和 loader：减少不必要的插件和 loader 可以减少打包时间。
7. 使用 Happypack：Happypack 可以将 Webpack 的 loader 转换为多线程模式，加快打包速度。
8. 启用 Tree Shaking：Tree Shaking 可以排除未使用的代码，减少打包大小，加快打包速度。

总之，提高 webpack 打包速度需要从多个方面综合考虑，需要不断进行尝试和优化。

```
⻥皮补充：这题建议大家自己尝试一下，学好打包工具可以让你的前端水平上升一个档次，不再是像我一样
的⻚面仔
```

#### ⻥友的精彩回答

**H.lj** !ᯤᯤ **⁶ᴳ 的回答**

以下是一些提高 Webpack 打包速度的技巧：

1. 升级 Webpack 版本：Webpack 的新版本通常具有更快的构建速度和更好的性能。
2. 减少模块解析范围：通过设置 resolve.modules、resolve.extensions、resolve.alias 等选项，可以让
   Webpack 减少查找和解析模块的范围，从而加快构建速度。
3. 使用 LoaderOptionsPlugin 插件：该插件可以将 Loader 的选项提取到 Webpack 的配置中，避免在每个 Loader
   中重复设置相同的选项，从而提高构建速度。
4. 使用 HappyPack 插件：该插件可以将 Webpack 的构建任务分解成多个子进程并行执行，从而加快构建速度。
5. 使用 DllPlugin 和 DllReferencePlugin 插件：该插件可以将常用的第三方库预先编译成一个单独的文件，从而避
   免重复打包，提高构建速度。
6. 开启缓存：通过设置 cache 选项或使用 cache-loader 等插件，可以让 Webpack 在第二次构建时复用已经处理过
   的结果，从而加快构建速度。
7. 压缩代码：使用 UglifyJsPlugin 等插件可以将代码压缩，从而减少文件大小和加载时间，提高性能。
8. 移除不必要的插件和 Loader：删除不必要的插件和 Loader 可以减少 Webpack 的处理时间，从而加快构建速
   度。
9. 使用 Tree shaking：使用 ES6 的 import 和 export 语句以及 Webpack 的 tree shaking 功能可以减少打包后的文件
   大小，从而提高构建速度和性能。
10. 使用多个 entry 和 output：使用多个 entry 和 output 可以将不同的代码分别打包成多个文件，从而减少每个文
    件的大小，提高构建速度和性能。

### 3 、什么是 webpack 的热更新？它的实现原理是什么？

#### 官方解析

webpack 的热更新（Hot Module Replacement，简称 HMR）是一种开发时提高开发效率的技术，可以实现无需
刷新⻚面即可看到代码修改后的效果。在使用 HMR 后，当修改了代码后，webpack 只会重新编译修改的代码，并
将新的模块发送到客户端，替换掉旧的模块，从而达到实时更新⻚面的目的。

实现 HMR 的关键是在客户端和服务器端之间建立一个 WebSocket 连接，当代码发生变化时，服务器端会将新的
模块发送给客户端，客户端接收到新的模块后会用新模块替换旧模块，从而实现实时更新。

具体来说，webpack HMR 主要分为以下几个步骤：

1. 启动 webpack-dev-server，配置 HMR 插件
2. 当代码变化时，webpack-dev-server 会编译出新的模块
3. HMR runtime（客户端运行时）会通过 WebSocket 与服务器通信，获取最新的模块
4. 当 HMR runtime 接收到新模块时，会将新模块加载到浏览器中，并通过模块热替换算法将新模块与旧模块进
   行比较，只替换有变化的模块部分
5. ⻚面更新完成，无需刷新⻚面即可看到最新的效果。

总之，HMR 可以大大提高开发效率，同时也能够减少代码变更时的刷新操作，提高开发体验。

#### ⻥友的精彩回答

**antlu1 的回答**

**Webpack 热更新：**

热更新（HMR）全程 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行的过程中，替换、添
加、删除模块，而无需重新刷新整个应用。

例如在运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那⻚面中的状态信息都会丢失；如
果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新应用。

**实现原理：**

1.第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置
文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。

2.第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件
webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代
码变化进行监 控，并且告诉 webpack，将代码打包到内存中。

3.第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。
当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态
文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。

4.第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏
览器端和服务端之间建立一个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同
时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端
传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。

5.webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了
webpack,webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的
配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。

6.HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通
过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的
模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7 、 8 、
9 步骤。

7.而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定
是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。

8.最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码

## 前端工程化

### 1 、什么是前后端分离？它有什么优点和缺点？

#### 官方解析

##### 前后端分离是指将前端和后端分别进行独立开发和部署。使前端和后端分别由不同的开发团队负责，通过 API 接口

##### 进行数据交互。前端负责⻚面展示和用户交互，后端负责业务逻辑和数据存储，两者通过 API 进行通信。

##### 前后端分离的优点包括：

##### 1. 分工明确：前端和后端分别由不同的开发团队负责，各司其职，有利于开发流程的管理和控制。

##### 2. 前后端解耦：前后端分离可以使前端和后端解耦，前端只关注⻚面展示和用户交互，后端只关注业务逻辑和数

##### 据存储，有利于模块化开发和维护。

##### 3. 更好的性能和用户体验：前后端分离可以使前端采用现代化的前端框架和技术，提高网站的性能和用户体验。

##### 4. 更好的可扩展性：前后端分离可以使后端提供更丰富的 API，方便前端进行开发和维护，同时也使得后端更易

##### 于扩展和修改。

##### 前后端分离的缺点包括：

##### 1. 开发难度增加：前后端分离需要前端和后端分别进行开发，需要更多的协调和沟通，开发难度增加。

##### 2. 维护难度增加：前后端分离使得前端和后端的代码分离，需要分别进行维护，维护难度增加。

##### 3. 安全问题：前后端分离可能会导致一些安全问题，例如跨站点脚本攻击（XSS）和跨站点请求伪造（CSRF），

##### 需要采取相应的安全措施来解决。

##### 总之，前后端分离有其优点和缺点。前后端分离可以提高开发效率、网站性能和用户体验，但也可能会增加开发和

##### 维护的难度，需要采取相应的措施来解决。

### 2 、你用过哪些包管理工具？它们各有什么特点？

#### 官方解析

前端常⻅的包管理工具包括 npm、Yarn 和 PNPM，它们各有不同的特点：

1. npm：npm 是 Node.js 自带的包管理工具，也是前端开发中最常用的包管理工具之一。它是一个基于命令行
   的工具，可以方便地安装、管理和升级依赖包。npm 拥有丰富的开源包，使用方便，但可能会出现包冲突等
   问题。

2. Yarn：Yarn 是 Facebook 开源的包管理工具，它是为了解决 npm 在包安装速度和版本管理上的一些问题而
   开发的。Yarn 支持离线安装、并行下载等特性，可以提高包安装的速度和可靠性。与 npm 相比，Yarn 具有
   更好的性能和稳定性，但是可能会出现版本冲突的问题。
3. PNPM：PNPM 是另一种基于命令行的包管理工具，它也可以用于安装和管理依赖包。与 npm 和 Yarn 不同
   的是，PNPM 支持重用已安装的包，减少了重复下载包的问题，从而提高了安装速度和减少了磁盘空间占
   用。PNPM 支持锁定版本、并行安装、缓存依赖等特性，但可能需要更多的学习成本。

综上所述，npm、Yarn 和 PNPM 都是可靠的包管理工具，使用场景和需求不同可以选择不同的工具。一般来说，
对于小型项目或初学者，使用 npm 即可；对于大型项目或需要更好的性能和可靠性的项目，可以考虑使用 Yarn
或 PNPM。

#### ⻥友的精彩回答

##### 板砖的小何的回答

##### 我用过以下包管理工具：

1. pip：Python 的包管理工具，可以轻松地安装、升级和卸载 Python 包。它是 Python 社区中最常用的包管理工
   具之一，能够从 PyPI（Python Package Index）中自动下载、安装和管理依赖。
2. npm：JavaScript 的包管理工具，可以轻松地安装、升级和卸载 JavaScript 包。它是 Node.js 社区中最常用的包
   管理工具之一，可以从 npm registry 中下载、安装和管理依赖。
3. yarn：也是 JavaScript 的包管理工具，由 Facebook 开发。它具有与 npm 相同的功能，但有一些额外的特性，
   例如离线模式、并行安装、缓存等等。
4. Homebrew：macOS 上的包管理工具，可以方便地安装、升级和卸载开源软件。它是基于 Ruby 语言的，可以
   从 Homebrew 的官方仓库中下载、安装和管理软件。
5. apt-get：Linux 上的包管理工具，可以方便地安装、升级和卸载软件。它是 Debian 和 Ubuntu Linux 系统中最
   常用的包管理工具之一，可以从系统的软件仓库中下载、安装和管理软件。

这些包管理工具都有各自的特点，比如支持的平台、安装速度、安全性等等。选择合适的包管理工具需要考虑到自
己的使用场景和需求。

### 3 、什么是 CSS 工程化？你用过哪些相关的工具？

#### 官方解析

##### CSS 工程化是指将 CSS 在项目中进行模块化、组件化、可维护性、可重用性等方面的处理，以达到工程化管理 CSS

##### 的目的。

##### 在 CSS 工程化中，通常会使用一些相关的工具来辅助管理 CSS，常用的工具包括：

1. CSS 预处理器：如 Sass、Less、Stylus 等，可以通过变量、函数、混合等方式，提高 CSS 的可维护性和可重
   用性。
2. CSS 后处理器：如 PostCSS，可以用来处理 CSS 代码，通过插件的形式可以实现一些自动化处理，如自动添
   加前缀、压缩 CSS 等。

3. CSS 模块化工具：如 CSS Modules、styled-components 等，可以将 CSS 样式与组件代码结合在一起，提高
   CSS 的可维护性和可重用性。
4. CSS 命名规范：如 BEM、SMACSS、OOCSS 等，可以通过规范化 CSS 的命名方式，提高 CSS 的可读性和可
   维护性。

通过使用这些工具，可以提高 CSS 的可维护性、可重用性和可读性，从而使得前端开发更加高效、简洁。

```
⻥皮补充：建议大家实践一下上面提到的技术，最少掌握一个 CSS 预处理器。
```

##### 作者：编程导航知识星球 + 星球⻥友们

## 性能优化

### 1 、说说常规的前端性能优化手段

#### 官方解析

##### 前端性能优化是一个重要的工作，可以有效地提升用户的体验和网站的访问速度。以下是一些常规的前端性能优化

##### 手段：

##### 减少 HTTP 请求：合并文件、使用 CSS 精灵、减小图片大小等。

```
压缩文件：使用压缩工具压缩 HTML、CSS、JavaScript、图片等文件大小。
缓存：使用缓存来减少网络请求。
懒加载：图片或者资源在真正需要的时候再加载，可以有效减少⻚面加载时间。
静态资源 CDN 加速：利用 CDN 分发静态资源，减少服务器压力，提高网站的访问速度。
减少 DOM 操作：DOM 操作是很耗费性能的，所以要尽量减少 DOM 操作的次数，尽量使用批量操作。
使用 CSS3 动画：使用 CSS3 动画而不是 JavaScript 动画，因为 CSS3 动画的性能更优。
使用字体图标：使用字体图标可以减少图片的请求，提高⻚面性能。
去除不必要的插件：移除不必要的插件可以提高⻚面加载速度，减少不必要的代码。
图片优化：对图片进行压缩和优化，减少图片的大小和请求次数。
```

以上是一些常规的前端性能优化手段，可以根据实际项目情况选择适合的优化手段来提高⻚面性能。

```
⻥皮补充：建议大家在上线网站后，可以尝试一下性能优化，并且学习下网站性能的分析工具的用法，得到
明确的性能优化数据，比如网⻚首屏渲染时间由 2 s 优化为 1.1 s
```

#### ⻥友的精彩回答

##### 你还费解吗的回答

##### 常⻅的前端性能优化手段有以下几种：

**DNS 优化** ：避免浏览器并发数限制，将 HTML/CSS/JS，jpg/png，api 接口等不同资源放在不同域名下，从而减少
DNS 的请求次数；DNS 预解析。

**CDN 回源** ：回源指浏览器访问 CDN 集群上静态文件时，文件缓存过期，直接穿透 CDN 集群而访问源站机器的行
为。

**浏览器缓存优化** ：IndexDB、cookie、localStorage、sessionstorage。

**HTML5 离线化** ：通过选用不同的离线包类型

```
全局离线包 ：包含公共的资源，可供多个应用共同使用
私有离线包 ：只可以被某个应用单独使用
```

**接口优化** ：

```
接口合并：减少http请求
接口上 CDN：把不需要实时更新的接口同步到CDN，如果接口数据更新再重新同步 CDN
接口域名上 CDN：增强可用性，稳定性
合理使用缓存：异步接口数据优先使用本地 localstorage 中的缓存数据，通过 md5 判断是否需要数据更新
```

**⻚面加载策略优化** ：

```
网络请求优化：减少网络资源的请求和加载耗时
预加载
开启GZIP
预渲染：可以让浏览器提前加载指定⻚面的所有资源。
使用 HTTP/2、HTTP/3提升资源请求速度
资源请求合并，减少http请求
合理使用defer，async
首屏加载优化
对⻚面内容进行分片/分屏加载
懒加载：监听scroll事件；使用IntersectionObserver
首屏只加载需要的资源，对于不需要的资源不加载。
客户端离线包方案
客户端进行预请求和预加载
渲染过程优化：减少用户操作等待时间
按需加载
减少回流和重绘
减少/合并dom操作，减少浏览器的计算损耗
浏览器运算逻辑优化
```

##### 拆解⻓任务，避免出现⻓时间计算导致⻚面卡顿

##### 提前将计算结果缓存

```
关键渲染路径优化：关键渲染路径是指浏览器将HTML，CSS，JavaScript转换为屏幕上所呈现的实际像素这期
间所经历的一系列步骤。
CSS 的 <link> 标签放在 <head></head> 之间
<script> 标签放在 </body> 之前
```

**⻚面静态化** （SSR）

**图片优化** ：选择合适的图片格式。

**HTML 代码优化** ：

```
精简HTML代码：减少HTML的嵌套；减少DOM节点数；减少无语义代码；删除多余的空格、换行符、缩进等
等
文件放在合适位置：CSS 样式文件链接尽量放在⻚面头部；JS 放在HTML底部
CSS 代码优化：
提升文件加载性能：使用外链的 CSS；尽量避免使用 @import，@import影响css文件的加载速度
精简 CSS 代码：利用CSS继承减少代码量；避免使用复杂的选择器，层级越少越好
字体文件优化：
使用cdn加载字体文件
开启gzip压缩字体文件
通过font-display来调整加载顺序
字体裁剪，剔除不需要使用到的字体
内联字体
JS 代码优化：
提升 JS 文件加载性能：JS 文件放在body 底部；合并js文件；合理使用defer和async
JS 变量和函数优化：尽量使用 id 选择器；尽量避免使用 eval；js 函数尽可能保持整洁；使用节流、防抖函
数；使用事件委托
JS 动画优化：避免添加大量 js 动画；尽量使用 css3 动画；尽量使用 Canvas 动画；使用
requestAnimationFrame 代替 settimeout 和 setinterval。
```

**webpack 打包优化**

**禾木的回答**

一、⻚面级优化
1 、减少 HTTP 请求数
2 、避免重复的资源请求
3 、减少 cookie 传输
4 、Lazy Load
5 、将 CSS 放在 HEAD 中
6 、将外部脚本置底
7 、减少重定向
8 、异步请求 Callback

##### 9 、使用 CDN

##### 10 、使用反向代理

##### 二、代码级优化

##### 1 、减少 DOM 操作

2 、慎用 with
3 、避免使用 eval 和 Function
4 、减少作用域链查找
5 、数据访问
6 、字符串拼接
7 、CSS 选择符优化

### 2 、前端性能优化指标有哪些？怎么进行性能检测？

#### 官方解析

##### 前端性能优化主要是通过一系列技术手段和优化策略来提升网站或应用的性能，从而提高用户的体验。下面列举一

##### 些常⻅的前端性能优化的指标和性能检测的方法：

1. 加载速度：网站或应用的加载速度是用户体验的重要因素。可以使用工具（如 WebPagetest、PageSpeed
   Insights）来测试网站或应用的加载速度，并通过优化图片大小、减少 HTTP 请求、使用浏览器缓存等方式来
   提升加载速度。
2. 渲染速度：渲染速度是指⻚面加载完成后⻚面内容渲染的速度。可以使用 Chrome 开发者工具中的
   Performance 面板来检测⻚面渲染速度，并通过减少 DOM 操作、使用 CSS3 动画、减少 JavaScript 的执行
   时间等方式来提升渲染速度。
3. 响应速度：响应速度是指网站或应用处理请求的速度。可以使用工具（如 Pingdom、GTmetrix）来测试响应
   速度，并通过优化服务器响应时间、压缩 JavaScript 和 CSS 文件等方式来提升响应速度。
4. 可访问性：可访问性是指网站或应用是否易于使用和访问。可以通过使用 HTML5、WAI-ARIA 标准、有意义
   的网⻚标题、有意义的链接等方式来提高可访问性。
5. 移动端性能：随着移动设备的普及，移动端性能越来越重要。可以使用工具（如 Google Mobile-Friendly
   Test）来测试移动端性能，并通过使用响应式设计、优化图片和视频大小、使用 viewport meta 标签等方式
   来提高移动端性能。

总结：前端性能优化指标包括加载速度、渲染速度、响应速度、可访问性和移动端性能等方面。可以使用各种工具
来检测这些指标，并采取相应的优化策略来提高网站或应用的性能。

#### ⻥友的精彩回答

**mumu 的回答**

前端性能可以通过打开「Lighthouse」查看：

```
首次渲染时间：测量⻚面第一次呈现内容的时间，包括 HTML、CSS 和 JavaScript 的加载时间。
首次交互时间：测量从⻚面开始加载到用户首次可以与⻚面进行交互的时间，例如点击按钮或滚动⻚面。
速度指数：测量⻚面渲染速度的指标，即⻚面中可⻅内容的加载速度，以及非可⻅内容的加载速度。
⻚面加载时间：测量从发出请求到⻚面加载完成的时间，包括所有资源的加载时间。
```

##### 可⻅最大内容检测：用于衡量⻚面渲染性能和用户体验。它衡量的是在⻚面上出现的最大可⻅内容的加载时

##### 间，例如图片、视频、文字等。LCP 的目标是在⻚面开始加载后的前 2.5 秒内完成加载。

##### 累积布局移位：衡量的是⻚面在加载和渲染时发生的不必要布局变化的数量和程度，例如当⻚面元素在加载时

##### 被推下或移动时发生的不必要跳动。CLS 值应该越小越好，建议小于 0.1

### 3 、DNS 预解析是什么？怎么实现？

#### 官方解析

DNS 预解析（DNS Prefetching）是一种网络性能优化技术，用于提前解析用户可能访问的域名，以减少实际请求
时的 DNS 解析时间。通过预解析，浏览器可以在用户实际访问一个链接之前就已经获取到对应的 IP 地址，从而降
低网络延迟，加快⻚面加载速度。

DNS 预解析主要有两种实现方式：

自动预解析：现代浏览器通常会自动进行 DNS 预解析。浏览器会根据用户的浏览历史和⻚面内容分析可能需要预
解析的域名，然后在后台进行 DNS 解析。这种方式无需开发者进行任何操作，浏览器会自动进行预解析。

手动预解析：开发者可以通过在 HTML 文档中添加标签来手动指定需要进行预解析的域名。这种方式可以让开发者
更精确地控制哪些域名需要进行预解析。示例如下：

在这个示例中，使用标签并设置 rel 属性为 dns-prefetch，将 href 属性设置为需要预解析的域名。注意，域名前
需要加上//，表示使用当前⻚面的协议（HTTP 或 HTTPS）。

使用 DNS 预解析可以在一定程度上提高网⻚的加载速度和用户体验，但需要注意的是，过多的预解析可能会消耗用
户的网络资源和带宽。因此，在实际应用中，应该根据实际需求合理地使用 DNS 预解析。

#### ⻥友的精彩回答

##### 会冒泡的可乐的回答

##### DNS 预解析就是让浏览器在用户访问链接之前解析域名，其范围包括文档的所有链接，无论是图片的，CSS 的，还

是 JavaScript 等其他用户能够点击的 URL。

**实现流程：**

```
<head>
...
<link rel="dns-prefetch" href="//example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
...
</head>
```

1. 首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入 [http://www.zdns.cn](http://www.zdns.cn) 的域名，它首先是由
   浏览器发起一个 DNS 解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里
   面记录的都是各个顶级域所在的服务器的位置，当向根请求 [http://www.zdns.cn](http://www.zdns.cn) 的时候，根服务器就会返回
   .cn 服务器的位置信息。
2. 递归服务器拿到.cn 的权威服务器地址以后，就会寻问 cn 的权威服务器，知不知道 [http://www.zdns.cn](http://www.zdns.cn) 的位
   置。这个时候 cn 权威服务器查找并返回http://zdns.cn服务器的地址。
3. 继续向 [http://zdns.cn](http://zdns.cn) 的权威服务器去查询这个地址，由 [http://zdns.cn](http://zdns.cn) 的服务器给出了地址：
   202.173.11.10
4. 最终才能进行 http 的链接，顺利访问网站。

当递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的
时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把http://www.zdns.cn
的 A 记录返回给客户端就可以了。

##### 悟道的回答

DNS 预解析（DNS prefetching）是指在网⻚加载时，提前获取该网⻚中需要引用的外部资源的 DNS 解析结果，
以便在浏览器发起请求时，可以直接使用已经解析好的 IP 地址，加快网⻚加载速度。

DNS 预解析可以通过以下两种方式实现：

1 、HTML 标签方式： 在网⻚ head 标签内，使用标签指定需要预解析的 DNS 域名：

```
<head>
<link rel="dns-prefetch" href="//example.com">
</head>
```

##### 这样浏览器在解析 HTML 时，就会提前进行 DNS 解析，减少后续请求时的解析时间。

2 、JavaScript 方式： 在网⻚中使用 JavaScript 代码实现 DNS 预解析：

该代码会创建一个 Image 对象，使用其 src 属性指定需要预解析的域名。这样在网⻚加载时，浏览器就会提前解析
该域名的 DNS，加快后续请求的速度。

需要注意的是，DNS 预解析虽然可以提高网⻚加载速度，但过多的 DNS 预解析可能会增加网络流量，甚至会对服
务器造成压力。因此，应该根据网⻚实际情况进行适当的 DNS 预解析。

**Kristen 的回答**

**DNS 解析**

大多数人是通过域名访问网站，当浏览器从（第三方）服务器请求资源时，必须先将该域名解析为 IP 地址，然后
浏览器才能向该域名发出请求，域名到 IP 这一过程称为 DNS 解析。 一般来说，一次 DNS 解析需要耗费 20-120
ms，所以为了优化 DNS，我们可以考虑两个方向： 减少 DNS 请求次数 缩短 DNS 解析时间 dns-prefetch

**为什么要有 DNS 预解析**

因为 DNS 解析需要时间，就衍生出了 DNS 预解析作为一个优化。

当你的网站第一次请求某个跨域域名时，需要先解析该域名（例如⻚面访问 cdn 资源，第一次访问需要先解析
cdn）。可以在请求的 Timing 上看到有一个 DNS Lookup 阶段，而在这个请求之后的其他该域名的请求都没有这
项时间支出。

DNS 解析时间可能导致大量用户感知延迟（在移动端可能比较明显），DNS 解析所需的时间差异非常大，延迟范
围可以从 0 ms（本地缓存结果）到几秒钟时间(网络极差)。

**什么是 DNS 预解析**

DNS 预解析是一项让浏览器主动去执行域名解析的功能。 浏览器试图在用户访问链接之前解析域名，其范围包括
文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。 因为预读取会在后台执
行，所以 DNS 很可能在链接对应的东⻄出现之前就已经解析完毕，这能够减少用户点击链接时的延迟。

**如何开启 DNS 预解析**

##### 简单的一行代码就能让支持该特性的浏览器提前解析 DNS。也就是说在浏览器请求资源时，DNS 查询就已经准备

##### 好了。

**什么是 dns-prefetch？** dns-prefetch(DNS 预获取)是前端网络性能优化的一种措施。它根据浏览器定义的规则，
提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度。

```
<script>
var dns = new Image();
dns.src = "//example.com";
</script>
```

```
<link rel="dns-prefetch" href="xxx.com">
```

**为什么要用 dns-prefetch？** 每当浏览器从（第三方）服务器发送一次请求时，都要先通过 DNS 解析将该跨域域名
解析为 IP 地址，然后浏览器才能发出请求。

如果某一时间内，有多个请求都发送给同一个服务器，那么 DNS 解析会多次并且重复触发。这样会导致整体的网
⻚加载有延迟的情况。

虽然 DNS 解析占用不了多大带宽，但是它会产生很高的延迟，尤其是对于移动网络会更为明显。

因此，为了减少 DNS 解析产生的延迟，我们可以通过 dns-prefetch 预解析技术有效地缩短 DNS 解析时间。

**注意** http ⻚面下所有的 a 标签的 href 都会自动去启用 DNS Prefetch，也就是说，网⻚的 a 标签 href 带的域名，
是不需要在 head 里面加上 link 手动设置的。https ⻚面需要使用 meta 标签强制开启：

dns-prefetch 适用于网⻚引用了大量其他域名的资源，例如淘宝。

### 4 、怎么进行站点内的图片性能优化？

#### 官方解析

##### 站点内的图片性能优化可以从以下几个方面入手：

1. **图片压缩** ：通过压缩图片的大小和质量，可以减少图片的加载时间。可以使用图片压缩工具（如 TinyPNG、
   JPEGmini 等）来压缩图片。
2. **图片格式优化** ：选择正确的图片格式可以减少图片的大小。常⻅的图片格式有 JPEG、PNG 和 GIF，可以根据
   图片的特点和用途选择合适的格式。
   延迟加载：对于⻚面中的⻓列表或懒加载场景，可以延迟加载图片，减少⻚面加载时间。可以使用工具（如
   lazysizes、Lozad.js 等）来实现图片的延迟加载。 3. **图片预加载** ：在用户访问⻚面之前，可以预加载一些重要的图片，从而提高用户体验。可以使用工具（如
   PreloadJS、image-preload 等）来实现图片的预加载。
3. **响应式图片** ：对于不同大小的屏幕，可以使用不同大小的图片来提高用户体验。可以使用 HTML 标签的
   srcset 和 sizes 属性来实现响应式图片。 5. **CDN 加速** ：使用 CDN 可以加速图片的加载速度，缩短图片的响应时间。可以选择静态文件托管服务商（如
   七牛云、阿里云等）来实现 CDN 加速。
4. **图片懒加载** ：对于网⻚中需要加载大量图片的场景，可以使用图片懒加载技术，即当⻚面滚动到某个区域时再
   加载该区域内的图片，从而减少⻚面加载时间和网络带宽的消耗。可以使用工具（如 lazyload、intersection-
   observer 等）来实现图片懒加载。

需要注意的是，以上优化策略都是针对特定场景和需求进行优化的，需要根据实际情况选择合适的优化策略。同
时，在进行图片优化时，需要保证图片质量和用户体验，并注意不要过度压缩图片，影响用户体验。

总结一下：减少传输时间（减小图片尺寸、网络优化），按需传图（懒加载、延迟加载、响应式）

```
<link rel="dns-prefetch" href="https://baidu.com/">
```

```
<meta http-equiv="x-dns-prefetch-control" content="on">
```

#### ⻥友的精彩回答

**玄德 ь 的回答**

优化站点内的图片性能可以尝试以下方法：

1. 采用图片压缩技术，减少图片大小，提升网⻚加载速度； 2.使用矢量图，替换位图；
2. 使用 CSS Sprites 技术，将多个图片组合成一个，减少 HTTP 请求次数；
3. 使用图片缓存机制，避免反复请求图片资源；
4. 使用 CDN 加速：使用 CDN 可以将图片缓存到离用户更近的服务器上，从而提高图片的加载速度。
5. 使用图片懒加载技术，减少无效网络请求；
6. 使用 webP 格式代替 JPG/PNG 格式，提升图片显示质量。

以上是一些常⻅的图片性能优化方法，根据具体的业务需求和网站特点，可以选择适合的方法进行优化。同时，也
可以使用一些工具和技术来辅助进行图片性能优化，例如图片压缩工具、CDN 服务、lazy load 插件等。

### 5 、SPA（单⻚应用）首屏加载速度慢怎么解决？

#### 官方解析

##### 单⻚应用（SPA）由于其特点，在首屏加载时，可能会出现加载速度慢的问题。为了解决这个问题，可以采用以下

##### 策略和技巧：

1. 代码拆分（Code Splitting）：将大型 JavaScript 文件拆分成更小的文件，按需加载。这可以通过使用动态导
   入（import() 语法）和 Webpack 等打包工具实现。代码拆分可以确保仅加载当前⻚面所需的代码，从而减少
   首屏加载时间。
2. 懒加载（Lazy Loading）：只在需要时加载某些资源，如图片、视频和其他媒体内容。懒加载可以通过^
   JavaScript 代码实现，或使用新的 loading="lazy" 属性（适用于部分现代浏览器）。
3. 缓存策略：利用浏览器缓存来存储静态资源，如 CSS、JavaScript、图片等。可以通过设置 HTTP 缓存头来实
   现，如 Cache-Control、ETag 等。合理的缓存策略可以减少重复请求，提高首屏加载速度。
4. 优化 JavaScript、CSS 和 HTML：压缩、混淆和缩小 JavaScript 和 CSS 文件，移除不必要的空格、注释和代
   码。对 HTML 文件进行类似的处理。可以使用诸如 UglifyJS、Terser、CSSNano 等工具进行优化。
5. 使用 CDN（内容分发网络）：将静态资源部署到 CDN 上，可以使用户从最近的服务器获取资源，从而加速
   首屏加载速度。
6. 服务端渲染（SSR）或预渲染（Prerendering）：通过在服务器端渲染初始 HTML，加快首次渲染速度。预渲
   染可以在构建阶段生成静态 HTML 文件，从而避免客户端在首次加载时执行过多的 JavaScript 代码。
7. 优化网络请求：减少不必要的网络请求，合并多个请求（如使用 CSS Sprites 或 HTTP/2 多路复用），以及优
   先加载关键资源。
8. 优先加载关键路径（Critical Path）：确保首屏渲染所需的关键 CSS 和 JavaScript 代码优先加载。可以将关键
   CSS 内联到 HTML 中，以避免额外的请求。

9. 使用性能分析工具：利用诸如 Lighthouse、WebPageTest 和 Chrome DevTools 等工具分析应用性能，找出
   瓶颈并进行优化。
   通过采用以上策略，可以有效地提高 SPA 首屏加载速度，提升用户体验。这些方法需要针对具体的项目进行
   调整和实施，从而达到最佳效果。

##### 作者：编程导航知识星球 + 星球⻥友们

## Git

### 1 、git stash 命令有什么作用？什么时候适合用它？

#### 官方解析

git stash 命令用于 **临时保存当前工作区的修改** ，以便你可以在干净的工作区上执行其他操作，如切换分支、拉取更
新等。当你完成其他操作后，可以使用 git stash apply 或 git stash pop 将之前保存的修改重新应用到工作区。

git stash 在以下场景中非常有用：

1. 当你正在进行一项尚未完成的任务，但需要切换到其他分支处理紧急问题或更新时。你可以使用 git stash 临
   时保存当前修改，然后切换分支并处理其他任务。完成后，切换回原来的分支，并使用 git stash apply 或 git
   stash pop 恢复之前的修改，继续完成未完成的任务。
2. 当你需要拉取远程仓库的更新，但当前工作区有未提交的修改时。使用 git stash 保存当前修改，拉取远程更
   新，然后使用 git stash apply 或 git stash pop 恢复修改。

以下是一些常用的 git stash 子命令：

```
git stash save [message]：将当前工作区的修改保存到一个新的存储，并可以添加一个可选的描述信息。
git stash list：列出所有的存储。
git stash apply [stash_name]：将指定的存储应用到当前工作区，不删除存储。如果未指定存储名，则默认
应用最近的存储。
git stash pop [stash_name]：将指定的存储应用到当前工作区，并从存储列表中删除。如果未指定存储名，
则默认应用并删除最近的存储。
git stash drop [stash_name]：删除指定的存储。如果未指定存储名，则默认删除最近的存储。
git stash branch <branch_name> [stash_name]：基于指定存储创建一个新分支，并将存储应用到新分支。
如果未指定存储名，则默认使用最近的存储。
git stash clear：删除所有的存储。
```

总之，git stash 是一个非常有用的命令，用于临时保存工作区的修改，以便在干净的工作区上执行其他操作。在处
理紧急任务、更新代码或切换分支时，git stash 都可以帮助你轻松管理工作区的状态。

#### ⻥友的精彩回答

##### 九仞的回答

在切换分支时，假设我们已经对分支代码做了更改，但并不想提交 commit，此时切换到其他分支可能会把对当前
分支的修改带到其他分支去，或者直接丢失更改，这也许不是我们想要的效果。 git stash 命令对应的使用场景就
是这种情况。他允许我们临时保存当前工作去的修改，然后以干净的工作区切换到另一分支进行其他修改，等修改
完毕后切换回原分支时也能快去恢复之前的修改。

**useGieGie 的回答**

git stash 命令的作用是将当前工作目录中的修改暂时保存起来，以便在需要时可以重新应用这些修改。使用 git
stash 命令可以避免在切换分支或者回滚代码时丢失未提交的修改。

适合使用 git stash 命令的情况包括：

1. 当你需要切换到其他分支进行开发，但是当前分支中还有未提交的修改时，可以使用 git stash 命令将这些修
   改暂时保存起来，然后切换到其他分支进行开发。
2. 当你需要回滚代码到之前的某个版本时，但是当前工作目录中还有未提交的修改时，可以使用 git stash 命令
   将这些修改暂时保存起来，然后回滚代码到指定的版本。
3. 当你需要进行一些临时的修改，但是不想将这些修改提交到版本库中时，可以使用 git stash 命令将这些修改
   暂时保存起来，然后在需要时再重新应用这些修改。

适合使用 git stash 命令的场景包括：

1. 当你正在进行某些修改，但需要切换到其他分支或者处理其他任务时，可以使用 git stash 命令将当前的修改
   暂存起来，以免对其他任务造成干扰。
2. 当你在处理某个 bug 或者其他问题时，需要暂时回到上一个提交状态进行一些测试或者比较代码时，可以使
   用 git stash 命令将当前修改暂存起来，以便稍后恢复。
   需要注意的是，git stash 命令只能将未提交的修改暂存起来，如果已经提交了修改，则无法使用该命令。另
   外，使用 git stash 命令时需要注意保存的修改内容，以免丢失重要的修改。

### 2 、git pull 和 git fetch 命令分别有什么作用？二者有什么区别？

#### 官方解析

git pull 和 git fetch 命令都是用于将远程仓库的代码同步到本地仓库。它们的作用如下：

```
git pull 命令用于将远程仓库的代码同步到本地仓库，并且合并（merge）到当前分支。相当于先执行 git
fetch 命令获取远程仓库的最新代码，然后执行 git merge 命令合并代码到当前分支。
git fetch 命令用于将远程仓库的代码同步到本地仓库，但不会自动将远程分支合并到本地分支。它只是将远
程仓库的代码下载到本地仓库，并更新本地仓库对应的远程分支的指针位置。
```

二者的区别在于，git pull 命令会自动将远程分支合并到本地分支，而 git fetch 命令则只是更新本地仓库的远程分
支指针位置，不会自动合并代码。

因此，在多人协作开发的场景下，如果本地分支与远程分支有冲突，建议先使用 git fetch 命令将远程代码同步到本
地仓库，然后手动合并代码，再进行提交。这样可以避免自动合并代码导致的冲突问题。

总的来说，git pull 命令适用于简单的场景，而 git fetch 命令适用于复杂的场景，比如需要手动合并代码的情况。

#### ⻥友的精彩回答

##### 猫十二懿的回答

git pull 和 git fetch 都是用于拉取远程代码的命令，但它们在执行过程中有一些区别。

1. git fetch：

使用 git fetch 可以从远程仓库获取最新代码。执行 git fetch 后，并不会对当前本地代码进行任何改动，也不会自
动合并代码。它会将远程仓库的代码更新到本地的一个单独的分支上（例如，origin/master 分支），并且该分支
的指针会向前移动到最新的提交记录。这个过程只会更新本地代码库的信息，但是不会合并到你的工作区。如果要
将远程分支合并到本地分支，则需要使用 git merge 命令进行合并操作。

示例：

2. git pull：

git pull 是将远程仓库的最新代码更新到本地，并与本地仓库合并的操作。

它的执行过程大致可以分为以下步骤：

1. 获取远程仓库的更新信息

使用 git fetch 命令获取远程仓库的最新（或指定）分支的相关更新信息，包括分支名称、最新的提交记录等，在本
地创建一个对应于远程分支的本地分支（默认情况下名称为 origin/remote_branch_name）。

2. 合并远程分支到本地分支

使用 git merge 命令将本地分支与远程分支进行合并，这个过程会将本地分支里的代码与远程分支里的代码进行比
较，然后执行一个三方合并操作，将两者的差异代码融合在一起。

3. 解决合并冲突

如果本地分支和远程分支之间存在代码冲突，那么在执行合并操作时就会出现合并冲突。此时需要手动解决冲突，
然后重新添加、提交、推送本地分支。

4. 更新工作区

最后，将合并后的代码更新到工作区，使得工作区的代码也同步到最新的状态。

因此，git pull 可以看做是 git fetch 和 git merge 命令的组合，先获取远程仓库的更新信息，再将其与本地分支进
行合并，并将合并后的代码更新到工作区。在合并过程中，如果出现代码冲突，则需要手动解决冲突，然后重新提
交本地分支。

示例：

```
git fetch origin master // 从远程的origin仓库的master分支获取最新版本到本地的origin/master
分支
git merge origin/master // 将本地的origin/master分支合并到当前所在的分支
```

```
git pull origin master //将远程的origin仓库的master分支获取最新版本并merge到当前分支
```

git fetch 和 git pull 的区别：

```
git fetch 只是将远程仓库的代码下载到本地，可以选择合并或不合并到本地分支
git pull 则是将远程仓库的最新代码下载到本地，并直接合并到当前分支中，它相当于是先执行 git fetch，再
执行 git merge 的操作。
```

## 前沿技术

### 1 、什么是低代码？你用过哪些低代码工具？

#### 官方解析

低代码（Low-Code）是一种软件开发方法，它允许开发者通过可视化界面、拖拽组件和一些简单的逻辑配置来构
建应用程序，而无需编写大量的代码。低代码平台的目标是提高开发效率，降低开发难度，使非专业开发人员（如
业务分析师、产品经理等）也能参与到应用程序的开发过程中。

低代码平台的主要特点包括：

1. 可视化界面：低代码平台通常提供可视化的界面设计工具，开发者可以通过拖拽组件、配置属性等方式来构建
   应用程序界面。
2. 预构建组件：低代码平台提供一系列预构建的组件和模板，开发者可以直接使用这些组件，而无需从头编写代
   码。
3. 逻辑配置：低代码平台允许开发者通过图形化界面或简单的脚本语言来配置应用程序的逻辑，降低了编程难
   度。
4. 一键部署：低代码平台通常提供一键部署功能，开发者可以轻松地将应用程序发布到目标环境中。
   一些常⻅的低代码工具和平台包括：
5. OutSystems：一款功能强大的低代码开发平台，适用于构建企业级应用程序，支持 Web 和移动应用开发。
6. Appian：提供低代码开发和业务流程管理功能，适用于构建企业应用程序，特别是需要复杂流程控制的场
   景。
7. Microsoft Power Apps：Microsoft 推出的低代码应用程序开发平台，可以轻松地与其他 Microsoft 365 服务
   集成。
8. Mendix：一款低代码开发平台，提供丰富的预构建组件和可视化开发工具，适用于构建企业应用程序。
   虽然低代码平台可以提高开发效率，但在某些场景下，它们可能无法满足复杂的定制需求或实现高度优化的性
   能。因此，在选择低代码平台时，需要根据项目需求和团队技能来权衡。

##### ⻥皮的评论：大家在回答时可以简单补充 “低代码的实现原理”，比如通过配置生成界面

### 2 、什么是前端跨平台？你用过哪些跨平台框架？

#### 官方解析

##### 前端跨平台是指可以在不同的操作系统、不同的浏览器或设备上运行相同的前端应用程序，达到统一的用户体验。

##### 目前主要的前端跨平台技术包括以下几种：

##### 1. 响应式设计：通过 CSS3 媒体查询和弹性布局等技术，使得网站在不同的设备上能够自适应地显示，并提供统

##### 一的用户体验。

2. Progressive Web App（PWA）：是一种利用现代 Web 技术开发的应用程序，具有类似于原生应用的交互和
   体验。PWA 可以在任何平台上运行，可以通过安装到设备主屏幕、离线访问等方式提供更好的用户体验。
3. 跨平台框架：使用跨平台框架可以开发出一份代码，然后通过框架提供的工具将代码转换成可以在多个平台上
   运行的应用程序。主要的跨平台框架包括 React Native、Flutter、Ionic、Electron 等。

我用过的跨平台框架包括 React Native 和 Electron。React Native 可以在 iOS 和 Android 平台上开发原生应用，
同时也可以在 Web 平台上使用 React 框架进行开发。Electron 可以将 Web 应用程序打包成桌面应用程序，可以
在 Windows、macOS 和 Linux 等多个平台上运行。这些跨平台框架可以大大简化开发过程，提高开发效率，同时
也可以保证应用程序在多个平台上的兼容性和用户体验。

```
作者：编程导航知识星球 + 星球⻥友们
```
